<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Minecraft 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
        }

        #ui div {
            margin: 5px 0;
        }

        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .inventory-slot {
            width: 70px;
            height: 70px;
            border: 3px solid #555;
            background: rgba(40, 40, 40, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .inventory-slot:hover {
            transform: scale(1.1);
            border-color: #888;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .inventory-slot.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            }

            50% {
                box-shadow: 0 0 35px rgba(0, 255, 136, 0.8);
            }
        }

        .inventory-slot .block-icon {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(20px);
            border: 3px solid #00ff88;
            max-width: 600px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
        }

        #instructions h2 {
            color: #00ff88;
            margin-bottom: 25px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            }

            to {
                text-shadow: 0 0 30px rgba(0, 255, 136, 1), 0 0 40px rgba(0, 255, 136, 0.8);
            }
        }

        #instructions p {
            margin: 12px 0;
            font-size: 1.2em;
            opacity: 0.9;
        }

        #startButton {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 20px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #startButton:hover {
            background: linear-gradient(45deg, #00cc6a, #00ff88);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.6);
        }

        #fps {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 15px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 2em;
            z-index: 300;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            margin: 20px auto;
            overflow: hidden;
            border: 1px solid #00ff88;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '';
            }

            40% {
                content: '.';
            }

            60% {
                content: '..';
            }

            80%,
            100% {
                content: '...';
            }
        }

        #debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0.7;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 300;
            border: 2px solid #ff4444;
        }

        /* ÈüøÊáâÂºèË®≠Ë®à */
        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 10px;
            }

            .inventory-slot {
                width: 60px;
                height: 60px;
            }

            #instructions {
                padding: 20px;
                max-width: 90%;
            }

            #instructions h2 {
                font-size: 2em;
            }

            #minimap {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair"></div>

        <div id="ui">
            <div>üåç Â∫ßÊ®ô: <span id="position">0, 0, 0</span></div>
            <div>üß≠ ÊñπÂêë: <span id="direction">0¬∞</span></div>
            <div>üì¶ ÊñπÂ°ä: <span id="blockCount">0</span></div>
            <div>üèîÔ∏è ÁîüÁâ©Áæ§ËêΩ: <span id="biome">Âπ≥Âéü</span></div>
            <div>‚ö° Ê∏≤Êüì: <span id="renderInfo">WebGL</span></div>
        </div>

        <div id="fps">FPS: <span id="fpsCounter">60</span></div>

        <canvas id="minimap"></canvas>

        <div id="inventory">
            <div class="inventory-slot active" data-block="grass">
                <div class="block-icon">üü©</div>
            </div>
            <div class="inventory-slot" data-block="stone">
                <div class="block-icon">‚¨ú</div>
            </div>
            <div class="inventory-slot" data-block="wood">
                <div class="block-icon">üü´</div>
            </div>
            <div class="inventory-slot" data-block="water">
                <div class="block-icon">üü¶</div>
            </div>
        </div>

        <div id="instructions">
            <h2>üéÆ WebGL Minecraft</h2>
            <p><strong>WASD</strong> - ÁßªÂãïËßíËâ≤</p>
            <p><strong>ÊªëÈº†</strong> - ËΩâÂãïË¶ñËßí</p>
            <p><strong>Â∑¶Èçµ</strong> - Á†¥Â£ûÊñπÂ°ä</p>
            <p><strong>Âè≥Èçµ</strong> - ÊîæÁΩÆÊñπÂ°ä</p>
            <p><strong>1-4</strong> - ÈÅ∏ÊìáÊñπÂ°äÈ°ûÂûã</p>
            <p><strong>Á©∫ÁôΩÈçµ</strong> - Ë∑≥Ë∫ç</p>
            <p><strong>Shift</strong> - ‰∏ãÈôç/ÊΩõË°å</p>
            <p><strong>F</strong> - È£õË°åÊ®°Âºè</p>
            <button id="startButton">üöÄ ÂïüÂãï WebGL ÂºïÊìé</button>
        </div>

        <div id="loading" class="loading" style="display: none;">
            Ê≠£Âú®ÂàùÂßãÂåñ WebGL ÂºïÊìé
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>

        <div id="debug">
            <div>‰∏âËßíÂΩ¢: <span id="triangleCount">0</span></div>
            <div>È†ÇÈªû: <span id="vertexCount">0</span></div>
            <div>Áπ™Ë£ΩË™øÁî®: <span id="drawCalls">0</span></div>
        </div>
    </div>

    <script>
        // WebGL Minecraft ÈÅäÊà≤‰ª£Á¢ºÂ∞áÂú®Á¨¨‰∫åÂíåÁ¨¨‰∏âÈÉ®ÂàÜ
        class WebGLMinecraft {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // ÂàùÂßãÂåñWebGL
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    this.showError('ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥WebGLÔºÅ');
                    return;
                }

                // Â∞èÂú∞ÂúñCanvas
                this.minimapCanvas = document.getElementById('minimap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.minimapCanvas.width = 180;
                this.minimapCanvas.height = 180;

                // ÊÄßËÉΩË®àÊï∏Âô®
                this.frameCount = 0;
                this.lastFrameTime = 0;
                this.fps = 60;
                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                // ÈÅäÊà≤ÁãÄÊÖã
                this.gameStarted = false;
                this.worldGenerated = false;
                this.flying = false;

                // Áé©ÂÆ∂
                this.player = {
                    x: 0, y: 10, z: 0,
                    angle: 0, pitch: 0,
                    velocity: { x: 0, y: 0, z: 0 },
                    onGround: false
                };

                // ‰∏ñÁïåË®≠ÂÆö
                this.world = new Map();
                // Âú® constructor ‰∏≠Á¢∫‰øùÈÄô‰∫õË®≠ÁΩÆ
                this.worldSize = 64; // ‰∏çË¶ÅÂ§™Â§ßÔºåÈÅøÂÖçÊÄßËÉΩÂïèÈ°å
                this.renderDistance = 24; // ÈÅ©‰∏≠ÁöÑÊ∏≤ÊüìË∑ùÈõ¢
                this.gravity = -0.02;
                this.jumpPower = 0.4;

                // ÊñπÂ°äÈ°ûÂûã
                // ÊñπÂ°äÈ°ûÂûãÔºàMinecraftÈ¢®Ê†ºÔºâ
                // Êõ¥ÁæéËßÄÁöÑÊñπÂ°äÈ°ûÂûã
                this.blockTypes = {
                    grass: {
                        colors: {
                            top: [0.3, 0.8, 0.2],     // ÈÆÆÁ∂†Ëâ≤ËçâÂú∞
                            side: [0.4, 0.5, 0.2],    // ËçâÂú∞ÂÅ¥Èù¢Â∏∂ÂúüËâ≤
                            bottom: [0.3, 0.2, 0.1]   // ÂúüËâ≤Â∫ïÈÉ®
                        },
                        id: 1
                    },
                    stone: {
                        colors: {
                            top: [0.8, 0.8, 0.8],     // ‰∫ÆÁÅ∞Ëâ≤
                            side: [0.6, 0.6, 0.6],    // ‰∏≠ÁÅ∞Ëâ≤
                            bottom: [0.4, 0.4, 0.4]   // Ê∑±ÁÅ∞Ëâ≤
                        },
                        id: 2
                    },
                    wood: {
                        colors: {
                            top: [0.7, 0.5, 0.2],     // Êú®È†≠Âπ¥Ëº™Ëâ≤
                            side: [0.4, 0.2, 0.1],    // Ê®πÁöÆËâ≤
                            bottom: [0.7, 0.5, 0.2]   // Êú®È†≠Âπ¥Ëº™Ëâ≤
                        },
                        id: 3
                    },
                    water: {
                        colors: {
                            top: [0.3, 0.6, 1.0],     // Ê∏ÖÊæàËóçËâ≤
                            side: [0.2, 0.5, 0.9],    // Ê∑±‰∏ÄÈªûÁöÑËóçËâ≤
                            bottom: [0.1, 0.4, 0.8]   // Ê∑±ËóçËâ≤
                        },
                        id: 4,
                        transparent: true
                    }
                };

                this.selectedBlock = 'grass';
                this.keys = {};
                this.mouse = { locked: false };

                // WebGLË≥áÊ∫ê
                this.shaderProgram = null;
                this.buffers = {};
                this.uniforms = {};
                this.attributes = {};

                // Ê∏≤ÊüìÊï∏Êìö
                this.vertices = [];
                this.indices = [];
                this.colors = [];
                this.normals = [];
                this.chunkMeshes = new Map();

                // Áü©Èô£ÔºàÈúÄË¶ÅÂºïÂÖ•gl-matrixÂ∫´ÊàñËá™ÂÆöÁæ©Ôºâ
                this.projectionMatrix = this.createMat4();
                this.viewMatrix = this.createMat4();
                this.modelMatrix = this.createMat4();

                this.initializeWebGL();
            }

            // Á∞°ÂåñÁöÑ4x4Áü©Èô£ÂâµÂª∫
            createMat4() {
                return new Float32Array(16);
            }

            // ÈÄèË¶ñÊäïÂΩ±Áü©Èô£
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
            }

            // Ë¶ñÂúñÁü©Èô£
            lookAt(out, eye, center, up) {
                const eyex = eye[0], eyey = eye[1], eyez = eye[2];
                const centerx = center[0], centery = center[1], centerz = center[2];
                const upx = up[0], upy = up[1], upz = up[2];

                const z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                const nz0 = z0 * len, nz1 = z1 * len, nz2 = z2 * len;

                const x0 = upy * nz2 - upz * nz1;
                const x1 = upz * nz0 - upx * nz2;
                const x2 = upx * nz1 - upy * nz0;
                len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                const nx0 = x0 * len, nx1 = x1 * len, nx2 = x2 * len;

                const y0 = nz1 * nx2 - nz2 * nx1;
                const y1 = nz2 * nx0 - nz0 * nx2;
                const y2 = nz0 * nx1 - nz1 * nx0;

                out[0] = nx0; out[1] = y0; out[2] = nz0; out[3] = 0;
                out[4] = nx1; out[5] = y1; out[6] = nz1; out[7] = 0;
                out[8] = nx2; out[9] = y2; out[10] = nz2; out[11] = 0;
                out[12] = -(nx0 * eyex + nx1 * eyey + nx2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(nz0 * eyex + nz1 * eyey + nz2 * eyez);
                out[15] = 1;
            }

            // ÂñÆ‰ΩçÁü©Èô£
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            }

            async initializeWebGL() {
                try {
                    this.showLoading();
                    await this.setupShaders();
                    this.setupBuffers();
                    this.setupMatrices();
                    this.setupEventListeners();
                    await this.generateWorld();
                    this.hideLoading();
                    this.gameLoop();
                } catch (error) {
                    this.showError('WebGLÂàùÂßãÂåñÂ§±Êïó: ' + error.message);
                }
            }

            async setupShaders() {
                // È†ÇÈªûËëóËâ≤Âô®
                const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        attribute vec3 aNormal;
        
        uniform mat4 uProjectionMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform vec3 uLightDirection;
        uniform vec3 uAmbientLight;
        
        varying vec3 vColor;
        varying float vLighting;
        
        void main() {
            vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
            gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
            
            // Ë®àÁÆóÂÖâÁÖß
            vec3 normal = normalize((uModelMatrix * vec4(aNormal, 0.0)).xyz);
            float directional = max(dot(normal, normalize(uLightDirection)), 0.0);
            vLighting = uAmbientLight.x + directional * 0.7;
            
            vColor = aColor;
        }
    `;

                // ÁâáÊÆµËëóËâ≤Âô®
                const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vColor;
        varying float vLighting;
        
        void main() {
            // Ê∑ªÂä†Áí∞Â¢ÉÂÖâÂíåÊº´ÂèçÂ∞ÑÂÖâÁÖß
            vec3 ambient = vColor * 0.3;
            vec3 diffuse = vColor * vLighting * 0.7;
            vec3 finalColor = ambient + diffuse;
            
            // Ê∑ªÂä†ËºïÂæÆÁöÑÈúßÊïàÊûú
            float fogFactor = clamp(gl_FragCoord.z * 2.0, 0.0, 1.0);
            vec3 fogColor = vec3(0.7, 0.8, 0.9);
            finalColor = mix(finalColor, fogColor, fogFactor * 0.3);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

                // Á∑®Ë≠ØËëóËâ≤Âô®
                const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

                // ÂâµÂª∫Á®ãÂ∫è
                this.shaderProgram = this.gl.createProgram();
                this.gl.attachShader(this.shaderProgram, vertexShader);
                this.gl.attachShader(this.shaderProgram, fragmentShader);
                this.gl.linkProgram(this.shaderProgram);

                if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
                    throw new Error('ËëóËâ≤Âô®Á®ãÂ∫èÈèàÊé•Â§±Êïó: ' + this.gl.getProgramInfoLog(this.shaderProgram));
                }

                this.gl.useProgram(this.shaderProgram);

                // Áç≤ÂèñÂ±¨ÊÄßÂíåÁµ±‰∏ÄËÆäÈáè‰ΩçÁΩÆ
                this.attributes = {
                    position: this.gl.getAttribLocation(this.shaderProgram, 'aPosition'),
                    color: this.gl.getAttribLocation(this.shaderProgram, 'aColor'),
                    normal: this.gl.getAttribLocation(this.shaderProgram, 'aNormal')
                };

                this.uniforms = {
                    projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                    viewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uViewMatrix'),
                    modelMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelMatrix'),
                    lightDirection: this.gl.getUniformLocation(this.shaderProgram, 'uLightDirection'),
                    ambientLight: this.gl.getUniformLocation(this.shaderProgram, 'uAmbientLight')
                };
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    this.gl.deleteShader(shader);
                    throw new Error('ËëóËâ≤Âô®Á∑®Ë≠ØÂ§±Êïó: ' + error);
                }

                return shader;
            }

            setupBuffers() {
                // È†ÇÈªûÁ∑©Ë°ùÂçÄ
                this.buffers.position = this.gl.createBuffer();
                this.buffers.color = this.gl.createBuffer();
                this.buffers.normal = this.gl.createBuffer();
                this.buffers.index = this.gl.createBuffer();
            }

            setupMatrices() {
                // ÊäïÂΩ±Áü©Èô£
                const aspect = this.canvas.width / this.canvas.height;
                this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);

                // Ë®≠ÁΩÆWebGLÁãÄÊÖã - ‰øÆÂæ©Ê∑±Â∫¶Ê∏¨Ë©¶
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.depthFunc(this.gl.LESS);  // ÊîπÁÇ∫LESS
                this.gl.depthMask(true);          // Á¢∫‰øùÊ∑±Â∫¶ÂØ´ÂÖ•ÈñãÂïü

                // Èù¢ÂâîÈô§Ë®≠ÁΩÆ
                this.gl.enable(this.gl.CULL_FACE);
                this.gl.cullFace(this.gl.BACK);
                this.gl.frontFace(this.gl.CCW);

                // Á¶ÅÁî®Ê∑∑ÂêàÊ®°ÂºèÔºàÂÖà‰øÆÂæ©Âü∫Êú¨Ê∏≤ÊüìÔºâ
                this.gl.disable(this.gl.BLEND);

                // Ë®≠ÁΩÆÊ∏ÖÁ©∫ÂÄº
                this.gl.clearColor(0.5, 0.7, 1.0, 1.0);
                this.gl.clearDepth(1.0);

                // Ë®≠ÁΩÆË¶ñÂè£
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            showLoading() {
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
            <h3>‚ùå ÈåØË™§</h3>
            <p>${message}</p>
            <button onclick="location.reload()">ÈáçÊñ∞ËºâÂÖ•</button>
        `;
                document.body.appendChild(errorDiv);
            }
            async generateWorld() {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    let progress = 0;

                    // ÁîüÊàêÈ´òÂ∫¶Âúñ
                    const heightMap = this.generateHeightMap();

                    const generateChunk = (chunkX, chunkZ) => {
                        console.log(`ÈñãÂßãÁîüÊàêÂçÄÂ°ä (${chunkX}, ${chunkZ})`);

                        const chunkSize = 16;
                        const startX = chunkX * chunkSize - this.worldSize / 2;
                        const startZ = chunkZ * chunkSize - this.worldSize / 2;

                        let blocksGenerated = 0;

                        for (let x = 0; x < chunkSize; x++) {
                            for (let z = 0; z < chunkSize; z++) {
                                const worldX = startX + x;
                                const worldZ = startZ + z;

                                if (Math.abs(worldX) >= this.worldSize / 2 || Math.abs(worldZ) >= this.worldSize / 2) continue;

                                const height = heightMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];

                                // Âü∫Â≤©Â±§ÔºàÊúÄÂ∫ïÂ±§Ôºâ
                                for (let y = -3; y <= -1; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                    blocksGenerated++;
                                }

                                // Âú∞‰∏ãÁü≥È†≠Â±§
                                for (let y = 0; y < height - 1; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                    blocksGenerated++;
                                }

                                // Ë°®Èù¢ËçâÂú∞
                                if (height >= 0) {
                                    this.setBlock(worldX, height, worldZ, 'grass');
                                    blocksGenerated++;
                                }

                                // ÁîüÊàêÊ®πÊú®ÔºàÈôç‰ΩéÂØÜÂ∫¶Ôºâ
                                if (Math.random() < 0.02 && height > 2) {
                                    this.generateSimpleTree(worldX, height + 1, worldZ);
                                }

                                // Ê∞¥È´îÔºàÊµ∑Âπ≥Èù¢ÁÇ∫0Ôºâ
                                if (height < 0) {
                                    for (let y = height + 1; y <= 0; y++) {
                                        this.setBlock(worldX, y, worldZ, 'water');
                                        blocksGenerated++;
                                    }
                                }
                            }
                        }

                        console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) ÁîüÊàê‰∫Ü ${blocksGenerated} ÂÄãÊñπÂ°ä`);

                        try {
                            this.generateChunkMesh(chunkX, chunkZ);
                            console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Á∂≤Ê†ºÁîüÊàêÊàêÂäü`);
                        } catch (error) {
                            console.error(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Á∂≤Ê†ºÁîüÊàêÂ§±Êïó:`, error);
                        }
                    };

                    const totalChunks = Math.pow(Math.ceil(this.worldSize / 16), 2);
                    let processedChunks = 0;

                    const processNextChunk = () => {
                        const chunksPerFrame = 2;
                        const chunksPerSide = Math.ceil(this.worldSize / 16);

                        console.log(`ËôïÁêÜÂçÄÂ°äÊâπÊ¨°ÔºåÁï∂ÂâçÈÄ≤Â∫¶: ${processedChunks}/${totalChunks}`);
                        console.log(`ÊØèÈÇäÂçÄÂ°äÊï∏: ${chunksPerSide}, Á∏ΩÂçÄÂ°äÊï∏: ${totalChunks}`);

                        for (let i = 0; i < chunksPerFrame && processedChunks < totalChunks; i++) {
                            const chunkX = Math.floor(processedChunks / chunksPerSide);
                            const chunkZ = processedChunks % chunksPerSide;

                            console.log(`ÁîüÊàêÂçÄÂ°ä (${chunkX}, ${chunkZ}), Á¥¢Âºï: ${processedChunks}`);

                            try {
                                generateChunk(chunkX, chunkZ);
                                processedChunks++;
                                console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) ÁîüÊàêÊàêÂäü`);
                            } catch (error) {
                                console.error(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) ÁîüÊàêÂ§±Êïó:`, error);
                                processedChunks++; // Ë∑≥ÈÅéÈåØË™§ÁöÑÂçÄÂ°ä
                            }
                        }

                        progress = (processedChunks / totalChunks) * 100;
                        const progressBar = document.getElementById('loadingProgress');
                        const loadingText = document.querySelector('.loading');

                        if (progressBar) {
                            progressBar.style.width = progress + '%';
                        }
                        if (loadingText) {
                            loadingText.textContent = `ÁîüÊàê‰∏ñÁïå ${Math.floor(progress)}%`;
                        }

                        console.log(`Áï∂ÂâçÈÄ≤Â∫¶: ${Math.floor(progress)}%`);

                        if (processedChunks >= totalChunks) {
                            this.worldGenerated = true;
                            console.log(`‰∏ñÁïåÁîüÊàêÂÆåÊàêÔºåËÄóÊôÇ: ${Date.now() - startTime}ms`);
                            console.log(`Á∏ΩÂÖ±ÁîüÊàê‰∫Ü ${this.world.size} ÂÄãÊñπÂ°ä`);
                            resolve();
                        } else {
                            requestAnimationFrame(processNextChunk);
                        }
                    };

                    processNextChunk();
                });
            }

            generateHeightMap() {
                const heightMap = [];
                for (let x = 0; x < this.worldSize; x++) {
                    heightMap[x] = [];
                    for (let z = 0; z < this.worldSize; z++) {
                        // ÊîπÈÄ≤ÁöÑÂô™ËÅ≤ÁÆóÊ≥ï
                        const nx = (x - this.worldSize / 2) / this.worldSize;
                        const nz = (z - this.worldSize / 2) / this.worldSize;

                        // Â§öÂ±§Âô™ËÅ≤ÁñäÂä†
                        const noise1 = this.improvedNoise(nx * 4, nz * 4) * 6;
                        const noise2 = this.improvedNoise(nx * 8, nz * 8) * 3;
                        const noise3 = this.improvedNoise(nx * 16, nz * 16) * 1.5;

                        // Âü∫Á§éÈ´òÂ∫¶ + Âô™ËÅ≤
                        const baseHeight = 2;
                        heightMap[x][z] = Math.floor(baseHeight + noise1 + noise2 + noise3);
                    }
                }
                return heightMap;
            }

            // Ê∑ªÂä†ÊîπÈÄ≤ÁöÑÂô™ËÅ≤ÂáΩÊï∏
            improvedNoise(x, z) {
                // ‰ΩøÁî®Â§öÂÄãÊ≠£Âº¶Ê≥¢ÁñäÂä†Áî¢ÁîüÊõ¥Ëá™ÁÑ∂ÁöÑÂô™ËÅ≤
                const n1 = Math.sin(x * 2.1 + z * 1.7) * 0.5;
                const n2 = Math.sin(x * 1.3 - z * 2.3) * 0.3;
                const n3 = Math.sin(x * 3.7 + z * 0.9) * 0.2;
                return (n1 + n2 + n3);
            }

            noise(x, z) {
                const n = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }

            generateTree(x, y, z) {
                // Ê®πÂππ
                for (let i = 0; i < 4; i++) {
                    this.setBlock(x, y + i, z, 'wood');
                }

                // Ê®πËëâ
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dy = 3; dy <= 5; dy++) {
                            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy - 4) <= 3 && Math.random() < 0.8) {
                                this.setBlock(x + dx, y + dy, z + dz, 'grass');
                            }
                        }
                    }
                }
            }

            generateSimpleTree(x, y, z) {
                // Á∞°ÂñÆÁöÑÊ®πÂππÔºà3Ê†ºÈ´òÔºâ
                for (let i = 0; i < 3; i++) {
                    this.setBlock(x, y + i, z, 'wood');
                }

                // Á∞°ÂñÆÁöÑÊ®πËëâÔºàÂçÅÂ≠óÂΩ¢Ôºâ
                const leafY = y + 3;
                this.setBlock(x, leafY, z, 'grass'); // ‰∏≠ÂøÉ
                this.setBlock(x + 1, leafY, z, 'grass');
                this.setBlock(x - 1, leafY, z, 'grass');
                this.setBlock(x, leafY, z + 1, 'grass');
                this.setBlock(x, leafY, z - 1, 'grass');

                // È†ÇÈÉ®
                this.setBlock(x, leafY + 1, z, 'grass');
            }

            generateChunkMesh(chunkX, chunkZ) {
                console.log(`ÈñãÂßãÁîüÊàêÂçÄÂ°äÁ∂≤Ê†º (${chunkX}, ${chunkZ})`);

                // Ê∑ªÂä†ÈÇäÁïåÊ™¢Êü•
                if (chunkX < 0 || chunkZ < 0 ||
                    chunkX >= Math.ceil(this.worldSize / 16) ||
                    chunkZ >= Math.ceil(this.worldSize / 16)) {
                    console.warn(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Ë∂ÖÂá∫ÈÇäÁïåÔºåË∑≥ÈÅé`);
                    return;
                }

                const chunkSize = 16;
                const vertices = [];
                const colors = [];
                const normals = [];
                const indices = [];
                let indexOffset = 0;

                const startX = chunkX * chunkSize - this.worldSize / 2;
                const startZ = chunkZ * chunkSize - this.worldSize / 2;

                for (let x = 0; x < chunkSize; x++) {
                    for (let z = 0; z < chunkSize; z++) {
                        for (let y = -5; y < 20; y++) {
                            const worldX = startX + x;
                            const worldZ = startZ + z;
                            const blockType = this.getBlock(worldX, y, worldZ);

                            if (!blockType) continue;

                            // Ê™¢Êü•ÊØèÂÄãÈù¢ÊòØÂê¶ÈúÄË¶ÅÊ∏≤Êüì
                            // Ê™¢Êü•ÊØèÂÄãÈù¢ÊòØÂê¶ÈúÄË¶ÅÊ∏≤ÊüìÔºàÊîπÈÄ≤ÁâàÔºâ
                            // Ê™¢Êü•ÊØèÂÄãÈù¢ÊòØÂê¶ÈúÄË¶ÅÊ∏≤ÊüìÔºàÊîπÈÄ≤ÁâàÔºâ
                            const faces = [
                                { dir: [0, 1, 0], visible: this.shouldRenderFace(worldX, y + 1, worldZ, blockType) }, // ‰∏ä
                                { dir: [0, -1, 0], visible: this.shouldRenderFace(worldX, y - 1, worldZ, blockType) }, // ‰∏ã
                                { dir: [1, 0, 0], visible: this.shouldRenderFace(worldX + 1, y, worldZ, blockType) }, // Âè≥
                                { dir: [-1, 0, 0], visible: this.shouldRenderFace(worldX - 1, y, worldZ, blockType) }, // Â∑¶
                                { dir: [0, 0, 1], visible: this.shouldRenderFace(worldX, y, worldZ + 1, blockType) }, // Ââç
                                { dir: [0, 0, -1], visible: this.shouldRenderFace(worldX, y, worldZ - 1, blockType) } // Âæå
                            ];

                            // Âú® generateChunkMesh ÂáΩÊï∏‰∏≠Ôºå‰øÆÊîπÈ°èËâ≤ÂàÜÈÖçÈÇèËºØ
                            faces.forEach((face, faceIndex) => {
                                if (!face.visible) return;

                                const faceVertices = this.getFaceVertices(worldX, y, worldZ, faceIndex);

                                // Á¢∫‰øùÊñπÂ°äÈ°ûÂûãÂ≠òÂú®
                                const blockInfo = this.blockTypes[blockType];
                                if (!blockInfo) {
                                    console.warn(`Êú™Áü•ÊñπÂ°äÈ°ûÂûã: ${blockType}`);
                                    return;
                                }

                                // Ê†πÊìöÈù¢ÁöÑÊñπÂêëÈÅ∏ÊìáÈ°èËâ≤
                                let blockColor;
                                if (blockInfo.colors) {
                                    switch (faceIndex) {
                                        case 0: // ‰∏äÈù¢
                                            blockColor = blockInfo.colors.top;
                                            break;
                                        case 1: // ‰∏ãÈù¢
                                            blockColor = blockInfo.colors.bottom;
                                            break;
                                        default: // ÂÅ¥Èù¢ (2,3,4,5)
                                            blockColor = blockInfo.colors.side;
                                            break;
                                    }
                                } else {
                                    blockColor = blockInfo.color || [0.5, 0.5, 0.5];
                                }

                                // Á¢∫‰øùÈ°èËâ≤Êï∏ÁµÑÊúâÊïà
                                if (!blockColor || blockColor.length !== 3) {
                                    console.warn(`ÁÑ°ÊïàÁöÑÊñπÂ°äÈ°èËâ≤: ${blockType}`, blockColor);
                                    blockColor = [0.5, 0.5, 0.5]; // È†êË®≠ÁÅ∞Ëâ≤
                                }

                                // Ê∑ªÂä†Èù¢ÂêëÂÖâÁÖßÁöÑÈô∞ÂΩ±ÊïàÊûú
                                const shadeFactor = this.calculateFaceShading(faceIndex, face.dir);
                                const shadedColor = [
                                    Math.max(0, Math.min(1, blockColor[0] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[1] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[2] * shadeFactor))
                                ];

                                // Ê∑ªÂä†È†ÇÈªû
                                for (let i = 0; i < 4; i++) {
                                    vertices.push(...faceVertices[i]);
                                    colors.push(...shadedColor);
                                    normals.push(...face.dir);
                                }

                                indices.push(
                                    indexOffset, indexOffset + 1, indexOffset + 2,
                                    indexOffset, indexOffset + 2, indexOffset + 3
                                );
                                indexOffset += 4;
                            });
                        }
                    }
                }

                console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Á∂≤Ê†ºÁµ±Ë®à: È†ÇÈªû=${vertices.length / 3}, Á¥¢Âºï=${indices.length}`);

                // Â≠òÂÑ≤ÂçÄÂ°äÁ∂≤Ê†º
                this.chunkMeshes.set(`${chunkX},${chunkZ}`, {
                    vertices: new Float32Array(vertices),
                    colors: new Float32Array(colors),
                    normals: new Float32Array(normals),
                    indices: new Uint16Array(indices),
                    vertexCount: vertices.length / 3,
                    indexCount: indices.length
                });

                console.log(`ÂçÄÂ°äÁ∂≤Ê†º (${chunkX}, ${chunkZ}) Â∑≤Â≠òÂÑ≤`);
            }

            calculateFaceShading(faceIndex, normal) {
                // Âü∫ÊñºÈù¢ÁöÑÊñπÂêëË®àÁÆóÂÖâÁÖßÂº∑Â∫¶
                const lightDirection = [0.3, 0.8, 0.5]; // ÂÖâÊ∫êÊñπÂêë

                // Ë®àÁÆóÊ≥ïÁ∑öËàáÂÖâÊ∫êÁöÑÈªûÁ©ç
                const dotProduct = normal[0] * lightDirection[0] +
                    normal[1] * lightDirection[1] +
                    normal[2] * lightDirection[2];

                // Âü∫Á§é‰∫ÆÂ∫¶ + ÊñπÂêëÂÖâÁÖß
                const baseBrightness = 0.6;
                const directionalLight = Math.max(0, dotProduct) * 0.4;

                return Math.max(0.3, Math.min(1.0, baseBrightness + directionalLight));
            }

            shouldRenderFace(x, y, z, currentBlockType) {
                const neighborBlock = this.getBlock(x, y, z);

                // Â¶ÇÊûúÈÑ∞Â±Ö‰ΩçÁΩÆÊ≤íÊúâÊñπÂ°äÔºåÂâáÊ∏≤ÊüìÈÄôÂÄãÈù¢
                if (!neighborBlock) {
                    return true;
                }

                // Â¶ÇÊûúÈÑ∞Â±ÖÊòØÈÄèÊòéÊñπÂ°äÔºàÂ¶ÇÊ∞¥ÔºâÔºåÂâáÊ∏≤ÊüìÈÄôÂÄãÈù¢
                if (this.blockTypes[neighborBlock] && this.blockTypes[neighborBlock].transparent) {
                    return true;
                }

                // Â¶ÇÊûúÁï∂ÂâçÊñπÂ°äÊòØÈÄèÊòéÁöÑÔºå‰∏îÈÑ∞Â±Ö‰∏çÊòØÂêåÈ°ûÂûãÔºåÂâáÊ∏≤Êüì
                if (this.blockTypes[currentBlockType] && this.blockTypes[currentBlockType].transparent) {
                    return neighborBlock !== currentBlockType;
                }

                // Âê¶Ââá‰∏çÊ∏≤ÊüìÔºàË¢´ÈÅÆÊìãÔºâ
                return false;
            }

            getFaceVertices(x, y, z, faceIndex) {
                const vertices = [
                    // ‰∏äÈù¢ (y+1) - ÈÄÜÊôÇÈáù
                    [[x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x + 1, y + 1, z]],
                    // ‰∏ãÈù¢ (y) - È†ÜÊôÇÈáù
                    [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]],
                    // Âè≥Èù¢ (x+1) - ÈÄÜÊôÇÈáù
                    [[x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1], [x + 1, y, z + 1]],
                    // Â∑¶Èù¢ (x) - È†ÜÊôÇÈáù
                    [[x, y, z + 1], [x, y + 1, z + 1], [x, y + 1, z], [x, y, z]],
                    // ÂâçÈù¢ (z+1) - ÈÄÜÊôÇÈáù
                    [[x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1]],
                    // ÂæåÈù¢ (z) - È†ÜÊôÇÈáù
                    [[x + 1, y, z], [x, y, z], [x, y + 1, z], [x + 1, y + 1, z]]
                ];

                return vertices[faceIndex];
            }

            setBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                this.world.set(key, type);
            }

            getBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                return this.world.get(key);
            }

            isTransparent(x, y, z) {
                const blockType = this.getBlock(x, y, z);
                return blockType === 'water'; // Ê∞¥ÊòØÈÄèÊòéÁöÑ
            }

            removeBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                this.world.delete(key);

                // Ê≠£Á¢∫Ë®àÁÆóÂçÄÂ°äÁ¥¢Âºï
                const chunkX = Math.floor((x + this.worldSize / 2) / 16);
                const chunkZ = Math.floor((z + this.worldSize / 2) / 16);

                console.log(`Âà™Èô§ÊñπÂ°ä (${x},${y},${z}), ÈáçÊñ∞ÁîüÊàêÂçÄÂ°ä (${chunkX},${chunkZ})`);

                // ÈáçÊñ∞ÁîüÊàêÂèóÂΩ±ÈüøÁöÑÂçÄÂ°äÁ∂≤Ê†º
                this.generateChunkMesh(chunkX, chunkZ);

                // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞ÁîüÊàêÁõ∏ÈÑ∞ÂçÄÂ°ä
                const localX = (x + this.worldSize / 2) % 16;
                const localZ = (z + this.worldSize / 2) % 16;

                const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                if (localX === 0 && chunkX > 0) {
                    this.generateChunkMesh(chunkX - 1, chunkZ);
                }
                if (localX === 15 && chunkX < maxChunkIndex) {
                    this.generateChunkMesh(chunkX + 1, chunkZ);
                }
                if (localZ === 0 && chunkZ > 0) {
                    this.generateChunkMesh(chunkX, chunkZ - 1);
                }
                if (localZ === 15 && chunkZ < maxChunkIndex) {
                    this.generateChunkMesh(chunkX, chunkZ + 1);
                }
            }
            setupEventListeners() {
                // ÈñãÂßãÊåâÈàï
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                // ÈçµÁõ§‰∫ã‰ª∂
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    // ÈÅ∏ÊìáÊñπÂ°äÈ°ûÂûã
                    if (e.code >= 'Digit1' && e.code <= 'Digit4') {
                        const index = parseInt(e.code.slice(-1)) - 1;
                        const types = Object.keys(this.blockTypes);
                        if (types[index]) {
                            this.selectedBlock = types[index];
                            this.updateInventoryUI();
                        }
                    }

                    // È£õË°åÊ®°ÂºèÂàáÊèõ
                    if (e.code === 'KeyF') {
                        this.flying = !this.flying;
                        this.player.velocity.y = 0;
                    }

                    // Èò≤Ê≠¢Á©∫ÁôΩÈçµÊªæÂãïÈ†ÅÈù¢
                    if (e.code === 'Space') {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // ÊªëÈº†‰∫ã‰ª∂
                this.canvas.addEventListener('click', () => {
                    if (this.gameStarted) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.player.angle += e.movementX * 0.003;
                        this.player.pitch -= e.movementY * 0.003;
                        this.player.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.player.pitch));
                    }
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.gameStarted || !this.worldGenerated) return;

                    const target = this.getTargetBlock();
                    if (target) {
                        if (e.button === 0) { // Â∑¶Èçµ - Á†¥Â£û
                            this.removeBlock(target.x, target.y, target.z);
                        } else if (e.button === 2) { // Âè≥Èçµ - ÊîæÁΩÆ
                            const place = this.getPlacePosition(target);
                            if (place && !this.isPlayerColliding(place.x, place.y, place.z)) {
                                this.setBlock(place.x, place.y, place.z, this.selectedBlock);

                                console.log(`ÊîæÁΩÆÊñπÂ°ä (${place.x},${place.y},${place.z})`);

                                // Ê≠£Á¢∫Ë®àÁÆó‰∏¶ÈáçÊñ∞ÁîüÊàêÁ∂≤Ê†º
                                const chunkX = Math.floor((place.x + this.worldSize / 2) / 16);
                                const chunkZ = Math.floor((place.z + this.worldSize / 2) / 16);

                                this.generateChunkMesh(chunkX, chunkZ);

                                // Ê™¢Êü•Áõ∏ÈÑ∞ÂçÄÂ°ä
                                const localX = (place.x + this.worldSize / 2) % 16;
                                const localZ = (place.z + this.worldSize / 2) % 16;
                                const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                                if (localX === 0 && chunkX > 0) {
                                    this.generateChunkMesh(chunkX - 1, chunkZ);
                                }
                                if (localX === 15 && chunkX < maxChunkIndex) {
                                    this.generateChunkMesh(chunkX + 1, chunkZ);
                                }
                                if (localZ === 0 && chunkZ > 0) {
                                    this.generateChunkMesh(chunkX, chunkZ - 1);
                                }
                                if (localZ === 15 && chunkZ < maxChunkIndex) {
                                    this.generateChunkMesh(chunkX, chunkZ + 1);
                                }
                            }
                        }
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Áâ©ÂìÅÊ¨ÑÈªûÊìä
                document.querySelectorAll('.inventory-slot').forEach((slot) => {
                    slot.addEventListener('click', () => {
                        const blockType = slot.dataset.block;
                        this.selectedBlock = blockType;
                        this.updateInventoryUI();
                    });
                });

                // Ë¶ñÁ™óÂ§ßÂ∞èË™øÊï¥
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                    // ÈáçÊñ∞Ë®àÁÆóÊäïÂΩ±Áü©Èô£
                    const aspect = this.canvas.width / this.canvas.height;
                    this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);
                });
            }

            startGame() {
                if (!this.worldGenerated) {
                    alert('‰∏ñÁïåÈÇÑÂú®ÁîüÊàê‰∏≠ÔºåË´ãÁ®çÂÄô...');
                    return;
                }
                this.gameStarted = true;
                document.getElementById('instructions').style.display = 'none';

                // Â∞áÁé©ÂÆ∂ÊîæÁΩÆÂú®Êõ¥ÂÆâÂÖ®ÁöÑ‰ΩçÁΩÆ
                this.player.x = 0;
                this.player.z = 0;
                this.player.y = Math.max(5, this.getHighestBlock(0, 0) + 3);

                console.log(`Áé©ÂÆ∂‰ΩçÁΩÆ: (${this.player.x}, ${this.player.y}, ${this.player.z})`);
                console.log('ÈÅäÊà≤Â∑≤ÂïüÂãïÔºÅ');
            }

            getHighestBlock(x, z) {
                for (let y = 20; y >= -10; y--) {
                    if (this.getBlock(Math.floor(x), y, Math.floor(z))) {
                        return y;
                    }
                }
                return 0;
            }

            updateInventoryUI() {
                document.querySelectorAll('.inventory-slot').forEach(slot => {
                    slot.classList.remove('active');
                    if (slot.dataset.block === this.selectedBlock) {
                        slot.classList.add('active');
                    }
                });
            }

            getTargetBlock() {
                const range = 8;
                const step = 0.05; // Êõ¥Â∞èÁöÑÊ≠•Èï∑ÔºåÊõ¥Á≤æÁ¢∫

                const startX = this.player.x;
                const startY = this.player.y + 1.6; // ÁúºÁùõÈ´òÂ∫¶
                const startZ = this.player.z;

                // Ë®àÁÆóÂ∞ÑÁ∑öÊñπÂêë
                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                for (let d = 0; d < range; d += step) {
                    const x = Math.floor(startX + dirX * d);
                    const y = Math.floor(startY + dirY * d);
                    const z = Math.floor(startZ + dirZ * d);

                    if (this.getBlock(x, y, z)) {
                        return {
                            x, y, z,
                            hitX: startX + dirX * d,
                            hitY: startY + dirY * d,
                            hitZ: startZ + dirZ * d
                        };
                    }
                }
                return null;
            }

            getPlacePosition(target) {
                if (!target) return null;

                // Ë®àÁÆóÂ∞ÑÁ∑öÊñπÂêë
                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                // Ê†πÊìöÊíûÊìäÈªûÁ¢∫ÂÆöÊîæÁΩÆÈù¢
                const hitX = target.hitX - target.x;
                const hitY = target.hitY - target.y;
                const hitZ = target.hitZ - target.z;

                let placeX = target.x;
                let placeY = target.y;
                let placeZ = target.z;

                // Á¢∫ÂÆöÊúÄÊé•ËøëÁöÑÈù¢
                const absX = Math.abs(hitX - 0.5);
                const absY = Math.abs(hitY - 0.5);
                const absZ = Math.abs(hitZ - 0.5);

                if (absX > absY && absX > absZ) {
                    // XÈù¢
                    placeX += hitX > 0.5 ? 1 : -1;
                } else if (absY > absZ) {
                    // YÈù¢
                    placeY += hitY > 0.5 ? 1 : -1;
                } else {
                    // ZÈù¢
                    placeZ += hitZ > 0.5 ? 1 : -1;
                }

                // Ê™¢Êü•‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà
                if (!this.getBlock(placeX, placeY, placeZ)) {
                    return { x: placeX, y: placeY, z: placeZ };
                }

                return null;
            }

            isPlayerColliding(x, y, z) {
                const px = Math.floor(this.player.x);
                const py = Math.floor(this.player.y);
                const pz = Math.floor(this.player.z);

                return (Math.abs(x - px) <= 1 && Math.abs(y - py) <= 2 && Math.abs(z - pz) <= 1);
            }

            checkCollision(x, y, z) {
                const blockX = Math.floor(x);
                const blockY = Math.floor(y);
                const blockZ = Math.floor(z);

                // Ê™¢Êü•Áé©ÂÆ∂‰ΩîÁî®ÁöÑÁ©∫ÈñìÔºà2Ê†ºÈ´òÔºâ
                for (let dy = 0; dy < 2; dy++) {
                    if (this.getBlock(blockX, blockY + dy, blockZ)) {
                        return true;
                    }
                }
                return false;
            }

            updatePlayer() {
                if (!this.gameStarted || !this.worldGenerated) return;

                const speed = 0.15;
                const sprintMultiplier = this.keys['ShiftLeft'] && !this.flying ? 0.5 : (this.keys['ControlLeft'] ? 2 : 1);
                const moveSpeed = speed * sprintMultiplier;

                // ÁßªÂãïË®àÁÆó
                let moveX = 0, moveZ = 0;

                if (this.keys['KeyW']) {
                    moveX += Math.cos(this.player.angle) * moveSpeed;
                    moveZ += Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['KeyS']) {
                    moveX -= Math.cos(this.player.angle) * moveSpeed;
                    moveZ -= Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['KeyA']) {
                    moveX += Math.cos(this.player.angle - Math.PI / 2) * moveSpeed;
                    moveZ += Math.sin(this.player.angle - Math.PI / 2) * moveSpeed;
                }
                if (this.keys['KeyD']) {
                    moveX += Math.cos(this.player.angle + Math.PI / 2) * moveSpeed;
                    moveZ += Math.sin(this.player.angle + Math.PI / 2) * moveSpeed;
                }

                // Á¢∞ÊíûÊ™¢Ê∏¨
                const newX = this.player.x + moveX;
                const newZ = this.player.z + moveZ;

                if (!this.checkCollision(newX, this.player.y, this.player.z)) {
                    this.player.x = newX;
                }
                if (!this.checkCollision(this.player.x, this.player.y, newZ)) {
                    this.player.z = newZ;
                }

                // È£õË°åÊ®°Âºè
                if (this.flying) {
                    if (this.keys['Space']) this.player.y += moveSpeed;
                    if (this.keys['ShiftLeft']) this.player.y -= moveSpeed;
                    this.player.velocity.y = 0;
                    this.player.onGround = false;
                } else {
                    // ÈáçÂäõÂíåË∑≥Ë∫ç
                    this.player.velocity.y += this.gravity;

                    if (this.keys['Space'] && this.player.onGround) {
                        this.player.velocity.y = this.jumpPower;
                        this.player.onGround = false;
                    }

                    // ÂûÇÁõ¥ÁßªÂãï
                    const newY = this.player.y + this.player.velocity.y;
                    if (!this.checkCollision(this.player.x, newY, this.player.z)) {
                        this.player.y = newY;
                        this.player.onGround = false;
                    } else {
                        if (this.player.velocity.y < 0) {
                            this.player.onGround = true;
                        }
                        this.player.velocity.y = 0;
                    }
                }
            }

            updateUI() {
                document.getElementById('position').textContent =
                    `${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)}`;
                document.getElementById('direction').textContent =
                    `${(this.player.angle * 180 / Math.PI).toFixed(0)}¬∞`;
                document.getElementById('blockCount').textContent = this.world.size;
                document.getElementById('renderInfo').textContent =
                    `WebGL ${this.flying ? '(È£õË°å)' : '(ÁîüÂ≠ò)'}`;

                // Êõ¥Êñ∞ÁîüÁâ©Áæ§ËêΩ
                const biome = this.getBiome(this.player.x, this.player.z);
                document.getElementById('biome').textContent = biome;

                // Êõ¥Êñ∞Ë™øË©¶‰ø°ÊÅØ
                document.getElementById('triangleCount').textContent = this.triangleCount;
                document.getElementById('vertexCount').textContent = this.vertexCount;
                document.getElementById('drawCalls').textContent = this.drawCalls;
            }

            getBiome(x, z) {
                const height = this.getHighestBlock(x, z);
                if (height < -1) return 'Êµ∑Ê¥ã';
                if (height > 5) return 'Â±±Âú∞';
                return 'Âπ≥Âéü';
            }

            updateMinimap() {
                this.minimapCtx.fillStyle = '#000';
                this.minimapCtx.fillRect(0, 0, 180, 180);

                const mapRange = 20;
                const scale = 180 / (mapRange * 2);

                // Áπ™Ë£ΩÂú∞ÂΩ¢
                for (let x = -mapRange; x <= mapRange; x++) {
                    for (let z = -mapRange; z <= mapRange; z++) {
                        const worldX = Math.floor(this.player.x) + x;
                        const worldZ = Math.floor(this.player.z) + z;
                        const height = this.getHighestBlock(worldX, worldZ);

                        if (height > -10) {
                            const brightness = Math.max(0, Math.min(1, (height + 5) / 15));
                            this.minimapCtx.fillStyle = `rgb(${Math.floor(76 * brightness)}, ${Math.floor(175 * brightness)}, ${Math.floor(80 * brightness)})`;
                            this.minimapCtx.fillRect(
                                90 + x * scale - scale / 2,
                                90 + z * scale - scale / 2,
                                scale, scale
                            );
                        }
                    }
                }

                // Áπ™Ë£ΩÁé©ÂÆ∂‰ΩçÁΩÆ
                this.minimapCtx.fillStyle = '#00ff88';
                this.minimapCtx.fillRect(88, 88, 4, 4);

                // Áπ™Ë£ΩÊñπÂêëÊåáÁ§∫Âô®
                this.minimapCtx.strokeStyle = '#00ff88';
                this.minimapCtx.lineWidth = 2;
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(90, 90);
                this.minimapCtx.lineTo(
                    90 + Math.cos(this.player.angle) * 15,
                    90 + Math.sin(this.player.angle) * 15
                );
                this.minimapCtx.stroke();
            }

            updateViewMatrix() {
                // Ë®àÁÆóÊîùÂÉèÊ©ü‰ΩçÁΩÆÂíåÁõÆÊ®ô
                const eye = [this.player.x, this.player.y + 1.6, this.player.z]; // Áé©ÂÆ∂ÁúºÁùõÈ´òÂ∫¶
                const target = [
                    this.player.x + Math.cos(this.player.angle) * Math.cos(this.player.pitch),
                    this.player.y + 1.6 + Math.sin(this.player.pitch),
                    this.player.z + Math.sin(this.player.angle) * Math.cos(this.player.pitch)
                ];
                const up = [0, 1, 0];

                this.lookAt(this.viewMatrix, eye, target, up);
            }

            // Âú® render ÂáΩÊï∏‰∏≠Ôºå‰øÆÊîπÂÖâÁÖßË®≠ÁΩÆ
            render() {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                if (!this.gameStarted || !this.worldGenerated) return;

                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                this.updateViewMatrix();

                this.identity(this.modelMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, this.projectionMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.viewMatrix, false, this.viewMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix);

                // ÊîπÈÄ≤ÁöÑÂÖâÁÖßË®≠ÁΩÆ
                this.gl.uniform3f(this.uniforms.lightDirection, 0.3, 0.8, 0.5); // Êõ¥Ëá™ÁÑ∂ÁöÑÂÖâÁÖßÊñπÂêë
                this.gl.uniform3f(this.uniforms.ambientLight, 0.6, 0.6, 0.6);   // Êõ¥‰∫ÆÁöÑÁí∞Â¢ÉÂÖâ

                this.renderVisibleChunks();
            }

            renderVisibleChunks() {
                const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                let renderedChunks = 0;
                let skippedChunks = 0;

                // ÂæûÁé©ÂÆ∂‰ΩçÁΩÆÂêëÂ§ñÊ∏≤ÊüìÔºåÁ¢∫‰øùËøëËôïÂÑ™ÂÖà
                for (let radius = 0; radius <= renderChunkDistance; radius++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dz = -radius; dz <= radius; dz++) {
                            if (Math.abs(dx) !== radius && Math.abs(dz) !== radius) continue;

                            const chunkX = playerChunkX + dx;
                            const chunkZ = playerChunkZ + dz;

                            // ÈÇäÁïåÊ™¢Êü•
                            if (chunkX < 0 || chunkZ < 0 ||
                                chunkX >= Math.ceil(this.worldSize / 16) ||
                                chunkZ >= Math.ceil(this.worldSize / 16)) continue;

                            const chunkKey = `${chunkX},${chunkZ}`;
                            const mesh = this.chunkMeshes.get(chunkKey);

                            if (!mesh || mesh.indexCount === 0) {
                                skippedChunks++;
                                continue;
                            }

                            this.renderChunk(chunkX, chunkZ);
                            renderedChunks++;
                        }
                    }
                }

                // Êõ¥Êñ∞Ë™øË©¶‰ø°ÊÅØ
                if (this.frameCount % 60 === 0) {
                    console.log(`Ê∏≤ÊüìÁµ±Ë®à: ${renderedChunks} ÂÄãÂçÄÂ°ä, Ë∑≥ÈÅé: ${skippedChunks} ÂÄã`);
                }
            }

            renderChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX},${chunkZ}`;
                const mesh = this.chunkMeshes.get(chunkKey);

                if (!mesh || mesh.indexCount === 0) {
                    return;
                }

                // Á¢∫‰øùÊ∑±Â∫¶Ê∏¨Ë©¶ÁãÄÊÖãÊ≠£Á¢∫
                if (!this.gl.getParameter(this.gl.DEPTH_TEST)) {
                    console.warn('Ê∑±Â∫¶Ê∏¨Ë©¶Êú™ÂïüÁî®ÔºåÈáçÊñ∞ÂïüÁî®');
                    this.gl.enable(this.gl.DEPTH_TEST);
                }

                // Ê™¢Êü•WebGLÁãÄÊÖã
                if (this.gl.isContextLost()) {
                    console.error('WebGL‰∏ä‰∏ãÊñá‰∏üÂ§±');
                    return;
                }

                try {
                    // Á∂ÅÂÆöÈ†ÇÈªûÊï∏Êìö
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.vertices, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.position);
                    this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                    // Á∂ÅÂÆöÈ°èËâ≤Êï∏Êìö
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.colors, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.color);
                    this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                    // Á∂ÅÂÆöÊ≥ïÁ∑öÊï∏Êìö
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.normals, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.normal);
                    this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                    // Á∂ÅÂÆöÁ¥¢ÂºïÊï∏Êìö
                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices, this.gl.STATIC_DRAW);

                    // Ê™¢Êü•WebGLÈåØË™§
                    const error = this.gl.getError();
                    if (error !== this.gl.NO_ERROR) {
                        console.error(`WebGLÈåØË™§: ${error}`);
                        return;
                    }

                    // Áπ™Ë£Ω
                    this.gl.drawElements(this.gl.TRIANGLES, mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);

                    // Êõ¥Êñ∞Áµ±Ë®à
                    this.triangleCount += mesh.indexCount / 3;
                    this.vertexCount += mesh.vertexCount;
                    this.drawCalls++;

                } catch (error) {
                    console.error(`Ê∏≤ÊüìÂçÄÂ°ä ${chunkKey} ÊôÇÁôºÁîüÈåØË™§:`, error);
                }
            }

            update(currentTime) {
                // Ë®àÁÆóFPS
                if (this.lastFrameTime) {
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.frameCount++;

                    if (this.frameCount % 60 === 0) {
                        this.fps = Math.round(1000 / deltaTime);
                        document.getElementById('fpsCounter').textContent = this.fps;
                    }
                }
                this.lastFrameTime = currentTime;

                // Êõ¥Êñ∞ÈÅäÊà≤ÈÇèËºØ
                this.updatePlayer();
                this.updateUI();
                this.updateMinimap();
            }

            gameLoop() {
                const currentTime = performance.now();

                this.update(currentTime);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }
        } // ÈÄôË£°ÁµêÊùü WebGLMinecraft È°ûÂà•

        // ÂïüÂãïÈÅäÊà≤
        window.addEventListener('load', () => {
            // ... ÂÖ∂È§ò‰ª£Á¢º
        });


        // ÂïüÂãïÈÅäÊà≤
        window.addEventListener('load', () => {
            // Ê™¢Êü•WebGLÊîØÊè¥
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                document.body.innerHTML = `
            <div class="error-message">
                <h3>‚ùå WebGL ‰∏çÊîØÊè¥</h3>
                <p>ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥WebGLÔºåÁÑ°Ê≥ïÈÅãË°åÊ≠§ÈÅäÊà≤„ÄÇ</p>
                <p>Ë´ãÂòóË©¶‰ΩøÁî®Áèæ‰ª£ÁÄèË¶ΩÂô®Â¶ÇChrome„ÄÅFirefoxÊàñEdge„ÄÇ</p>
                <button onclick="location.reload()">ÈáçÊñ∞Ê™¢Ê∏¨</button>
            </div>
        `;
                return;
            }

            try {
                new WebGLMinecraft();
            } catch (error) {
                console.error('ÈÅäÊà≤ÂïüÂãïÂ§±Êïó:', error);
                document.body.innerHTML = `
            <div class="error-message">
                <h3>‚ùå ÂïüÂãïÂ§±Êïó</h3>
                <p>ÈÅäÊà≤ÂïüÂãïÊôÇÁôºÁîüÈåØË™§: ${error.message}</p>
                <button onclick="location.reload()">ÈáçÊñ∞ÂïüÂãï</button>
            </div>
        `;
            }
        });

        // Ê∑ªÂä†‰∏Ä‰∫õÂØ¶Áî®ÁöÑÂÖ®ÂüüÂáΩÊï∏
        window.toggleFullscreen = function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        };

        // ÊÄßËÉΩÁõ£Êéß
        window.addEventListener('beforeunload', () => {
            console.log('ÈÅäÊà≤ÊúÉË©±ÁµêÊùü');
        });

        // ËôïÁêÜÈ†ÅÈù¢ÂèØË¶ãÊÄßËÆäÂåñ
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('ÈÅäÊà≤Êö´ÂÅú');
            } else {
                console.log('ÈÅäÊà≤ÊÅ¢Âæ©');
            }
        });

    </script>
</body>

</html>