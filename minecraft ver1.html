<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Minecraft 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
        }

        #ui div {
            margin: 5px 0;
        }

        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .inventory-slot {
            width: 70px;
            height: 70px;
            border: 3px solid #555;
            background: rgba(40, 40, 40, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .inventory-slot:hover {
            transform: scale(1.1);
            border-color: #888;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .inventory-slot.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            }

            50% {
                box-shadow: 0 0 35px rgba(0, 255, 136, 0.8);
            }
        }

        .inventory-slot .block-icon {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(20px);
            border: 3px solid #00ff88;
            max-width: 600px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
        }

        #instructions h2 {
            color: #00ff88;
            margin-bottom: 25px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            }

            to {
                text-shadow: 0 0 30px rgba(0, 255, 136, 1), 0 0 40px rgba(0, 255, 136, 0.8);
            }
        }

        #instructions p {
            margin: 12px 0;
            font-size: 1.2em;
            opacity: 0.9;
        }

        #startButton {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 20px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #startButton:hover {
            background: linear-gradient(45deg, #00cc6a, #00ff88);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.6);
        }

        #fps {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 15px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 2em;
            z-index: 300;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            margin: 20px auto;
            overflow: hidden;
            border: 1px solid #00ff88;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '';
            }

            40% {
                content: '.';
            }

            60% {
                content: '..';
            }

            80%,
            100% {
                content: '...';
            }
        }

        #debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0.7;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 300;
            border: 2px solid #ff4444;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 10px;
            }

            .inventory-slot {
                width: 60px;
                height: 60px;
            }

            #instructions {
                padding: 20px;
                max-width: 90%;
            }

            #instructions h2 {
                font-size: 2em;
            }

            #minimap {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair"></div>

        <div id="ui">
            <div>ğŸŒ åº§æ¨™: <span id="position">0, 0, 0</span></div>
            <div>ğŸ§­ æ–¹å‘: <span id="direction">0Â°</span></div>
            <div>ğŸ“¦ æ–¹å¡Š: <span id="blockCount">0</span></div>
            <div>ğŸ”ï¸ ç”Ÿç‰©ç¾¤è½: <span id="biome">å¹³åŸ</span></div>
            <div>âš¡ æ¸²æŸ“: <span id="renderInfo">WebGL</span></div>
        </div>

        <div id="fps">FPS: <span id="fpsCounter">60</span></div>

        <canvas id="minimap"></canvas>

        <div id="inventory">
            <div class="inventory-slot active" data-block="grass">
                <div class="block-icon">ğŸŸ©</div>
            </div>
            <div class="inventory-slot" data-block="stone">
                <div class="block-icon">â¬œ</div>
            </div>
            <div class="inventory-slot" data-block="wood">
                <div class="block-icon">ğŸŸ«</div>
            </div>
            <div class="inventory-slot" data-block="water">
                <div class="block-icon">ğŸŸ¦</div>
            </div>
        </div>

        <div id="instructions">
            <h2>ğŸ® WebGL Minecraft</h2>
            <p><strong>WASD</strong> - ç§»å‹•è§’è‰²</p>
            <p><strong>æ»‘é¼ </strong> - è½‰å‹•è¦–è§’</p>
            <p><strong>å·¦éµ</strong> - ç ´å£æ–¹å¡Š</p>
            <p><strong>å³éµ</strong> - æ”¾ç½®æ–¹å¡Š</p>
            <p><strong>1-4</strong> - é¸æ“‡æ–¹å¡Šé¡å‹</p>
            <p><strong>ç©ºç™½éµ</strong> - è·³èº</p>
            <p><strong>Shift</strong> - ä¸‹é™/æ½›è¡Œ</p>
            <p><strong>F</strong> - é£›è¡Œæ¨¡å¼</p>
            <button id="startButton">ğŸš€ å•Ÿå‹• WebGL å¼•æ“</button>
        </div>

        <div id="loading" class="loading" style="display: none;">
            æ­£åœ¨åˆå§‹åŒ– WebGL å¼•æ“
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>

        <div id="debug">
            <div>ä¸‰è§’å½¢: <span id="triangleCount">0</span></div>
            <div>é ‚é»: <span id="vertexCount">0</span></div>
            <div>ç¹ªè£½èª¿ç”¨: <span id="drawCalls">0</span></div>
        </div>
    </div>

    <script>
        // WebGL Minecraft éŠæˆ²ä»£ç¢¼å°‡åœ¨ç¬¬äºŒå’Œç¬¬ä¸‰éƒ¨åˆ†
        class WebGLMinecraft {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // åˆå§‹åŒ–WebGL
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    this.showError('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´WebGLï¼');
                    return;
                }

                // å°åœ°åœ–Canvas
                this.minimapCanvas = document.getElementById('minimap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.minimapCanvas.width = 180;
                this.minimapCanvas.height = 180;

                // æ€§èƒ½è¨ˆæ•¸å™¨
                this.frameCount = 0;
                this.lastFrameTime = 0;
                this.fps = 60;
                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                // éŠæˆ²ç‹€æ…‹
                this.gameStarted = false;
                this.worldGenerated = false;
                this.flying = false;

                // ç©å®¶
                this.player = {
                    x: 0, y: 10, z: 0,
                    angle: 0, pitch: 0,
                    velocity: { x: 0, y: 0, z: 0 },
                    onGround: false
                };

                // ä¸–ç•Œè¨­å®š
                this.world = new Map();
                // åœ¨ constructor ä¸­ç¢ºä¿é€™äº›è¨­ç½®
                this.worldSize = 64; // ä¸è¦å¤ªå¤§ï¼Œé¿å…æ€§èƒ½å•é¡Œ
                this.renderDistance = 24; // é©ä¸­çš„æ¸²æŸ“è·é›¢
                this.gravity = -0.02;
                this.jumpPower = 0.4;

                // æ–¹å¡Šé¡å‹
                // æ–¹å¡Šé¡å‹ï¼ˆMinecrafté¢¨æ ¼ï¼‰
                // æ›´ç¾è§€çš„æ–¹å¡Šé¡å‹
                this.blockTypes = {
                    grass: {
                        colors: {
                            top: [0.3, 0.8, 0.2],     // é®®ç¶ è‰²è‰åœ°
                            side: [0.4, 0.5, 0.2],    // è‰åœ°å´é¢å¸¶åœŸè‰²
                            bottom: [0.3, 0.2, 0.1]   // åœŸè‰²åº•éƒ¨
                        },
                        id: 1
                    },
                    stone: {
                        colors: {
                            top: [0.8, 0.8, 0.8],     // äº®ç°è‰²
                            side: [0.6, 0.6, 0.6],    // ä¸­ç°è‰²
                            bottom: [0.4, 0.4, 0.4]   // æ·±ç°è‰²
                        },
                        id: 2
                    },
                    wood: {
                        colors: {
                            top: [0.7, 0.5, 0.2],     // æœ¨é ­å¹´è¼ªè‰²
                            side: [0.4, 0.2, 0.1],    // æ¨¹çš®è‰²
                            bottom: [0.7, 0.5, 0.2]   // æœ¨é ­å¹´è¼ªè‰²
                        },
                        id: 3
                    },
                    water: {
                        colors: {
                            top: [0.3, 0.6, 1.0],     // æ¸…æ¾ˆè—è‰²
                            side: [0.2, 0.5, 0.9],    // æ·±ä¸€é»çš„è—è‰²
                            bottom: [0.1, 0.4, 0.8]   // æ·±è—è‰²
                        },
                        id: 4,
                        transparent: true
                    }
                };

                this.selectedBlock = 'grass';
                this.keys = {};
                this.mouse = { locked: false };

                // WebGLè³‡æº
                this.shaderProgram = null;
                this.buffers = {};
                this.uniforms = {};
                this.attributes = {};

                // æ¸²æŸ“æ•¸æ“š
                this.vertices = [];
                this.indices = [];
                this.colors = [];
                this.normals = [];
                this.chunkMeshes = new Map();

                // çŸ©é™£ï¼ˆéœ€è¦å¼•å…¥gl-matrixåº«æˆ–è‡ªå®šç¾©ï¼‰
                this.projectionMatrix = this.createMat4();
                this.viewMatrix = this.createMat4();
                this.modelMatrix = this.createMat4();

                this.initializeWebGL();
            }

            // ç°¡åŒ–çš„4x4çŸ©é™£å‰µå»º
            createMat4() {
                return new Float32Array(16);
            }

            // é€è¦–æŠ•å½±çŸ©é™£
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
            }

            // è¦–åœ–çŸ©é™£
            lookAt(out, eye, center, up) {
                const eyex = eye[0], eyey = eye[1], eyez = eye[2];
                const centerx = center[0], centery = center[1], centerz = center[2];
                const upx = up[0], upy = up[1], upz = up[2];

                const z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                const nz0 = z0 * len, nz1 = z1 * len, nz2 = z2 * len;

                const x0 = upy * nz2 - upz * nz1;
                const x1 = upz * nz0 - upx * nz2;
                const x2 = upx * nz1 - upy * nz0;
                len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                const nx0 = x0 * len, nx1 = x1 * len, nx2 = x2 * len;

                const y0 = nz1 * nx2 - nz2 * nx1;
                const y1 = nz2 * nx0 - nz0 * nx2;
                const y2 = nz0 * nx1 - nz1 * nx0;

                out[0] = nx0; out[1] = y0; out[2] = nz0; out[3] = 0;
                out[4] = nx1; out[5] = y1; out[6] = nz1; out[7] = 0;
                out[8] = nx2; out[9] = y2; out[10] = nz2; out[11] = 0;
                out[12] = -(nx0 * eyex + nx1 * eyey + nx2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(nz0 * eyex + nz1 * eyey + nz2 * eyez);
                out[15] = 1;
            }

            // å–®ä½çŸ©é™£
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            }

            async initializeWebGL() {
                try {
                    this.showLoading();
                    await this.setupShaders();
                    this.setupBuffers();
                    this.setupMatrices();
                    this.setupEventListeners();
                    await this.generateWorld();
                    this.hideLoading();
                    this.gameLoop();
                } catch (error) {
                    this.showError('WebGLåˆå§‹åŒ–å¤±æ•—: ' + error.message);
                }
            }

            async setupShaders() {
                // é ‚é»è‘—è‰²å™¨
                const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        attribute vec3 aNormal;
        
        uniform mat4 uProjectionMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform vec3 uLightDirection;
        uniform vec3 uAmbientLight;
        
        varying vec3 vColor;
        varying float vLighting;
        
        void main() {
            vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
            gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
            
            // è¨ˆç®—å…‰ç…§
            vec3 normal = normalize((uModelMatrix * vec4(aNormal, 0.0)).xyz);
            float directional = max(dot(normal, normalize(uLightDirection)), 0.0);
            vLighting = uAmbientLight.x + directional * 0.7;
            
            vColor = aColor;
        }
    `;

                // ç‰‡æ®µè‘—è‰²å™¨
                const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vColor;
        varying float vLighting;
        
        void main() {
            // æ·»åŠ ç’°å¢ƒå…‰å’Œæ¼«åå°„å…‰ç…§
            vec3 ambient = vColor * 0.3;
            vec3 diffuse = vColor * vLighting * 0.7;
            vec3 finalColor = ambient + diffuse;
            
            // æ·»åŠ è¼•å¾®çš„éœ§æ•ˆæœ
            float fogFactor = clamp(gl_FragCoord.z * 2.0, 0.0, 1.0);
            vec3 fogColor = vec3(0.7, 0.8, 0.9);
            finalColor = mix(finalColor, fogColor, fogFactor * 0.3);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

                // ç·¨è­¯è‘—è‰²å™¨
                const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

                // å‰µå»ºç¨‹åº
                this.shaderProgram = this.gl.createProgram();
                this.gl.attachShader(this.shaderProgram, vertexShader);
                this.gl.attachShader(this.shaderProgram, fragmentShader);
                this.gl.linkProgram(this.shaderProgram);

                if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
                    throw new Error('è‘—è‰²å™¨ç¨‹åºéˆæ¥å¤±æ•—: ' + this.gl.getProgramInfoLog(this.shaderProgram));
                }

                this.gl.useProgram(this.shaderProgram);

                // ç²å–å±¬æ€§å’Œçµ±ä¸€è®Šé‡ä½ç½®
                this.attributes = {
                    position: this.gl.getAttribLocation(this.shaderProgram, 'aPosition'),
                    color: this.gl.getAttribLocation(this.shaderProgram, 'aColor'),
                    normal: this.gl.getAttribLocation(this.shaderProgram, 'aNormal')
                };

                this.uniforms = {
                    projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                    viewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uViewMatrix'),
                    modelMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelMatrix'),
                    lightDirection: this.gl.getUniformLocation(this.shaderProgram, 'uLightDirection'),
                    ambientLight: this.gl.getUniformLocation(this.shaderProgram, 'uAmbientLight')
                };
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    this.gl.deleteShader(shader);
                    throw new Error('è‘—è‰²å™¨ç·¨è­¯å¤±æ•—: ' + error);
                }

                return shader;
            }

            setupBuffers() {
                // é ‚é»ç·©è¡å€
                this.buffers.position = this.gl.createBuffer();
                this.buffers.color = this.gl.createBuffer();
                this.buffers.normal = this.gl.createBuffer();
                this.buffers.index = this.gl.createBuffer();
            }

            setupMatrices() {
                // æŠ•å½±çŸ©é™£
                const aspect = this.canvas.width / this.canvas.height;
                this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);

                // è¨­ç½®WebGLç‹€æ…‹ - ä¿®å¾©æ·±åº¦æ¸¬è©¦
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.depthFunc(this.gl.LESS);  // æ”¹ç‚ºLESS
                this.gl.depthMask(true);          // ç¢ºä¿æ·±åº¦å¯«å…¥é–‹å•Ÿ

                // é¢å‰”é™¤è¨­ç½®
                this.gl.enable(this.gl.CULL_FACE);
                this.gl.cullFace(this.gl.BACK);
                this.gl.frontFace(this.gl.CCW);

                // ç¦ç”¨æ··åˆæ¨¡å¼ï¼ˆå…ˆä¿®å¾©åŸºæœ¬æ¸²æŸ“ï¼‰
                this.gl.disable(this.gl.BLEND);

                // è¨­ç½®æ¸…ç©ºå€¼
                this.gl.clearColor(0.5, 0.7, 1.0, 1.0);
                this.gl.clearDepth(1.0);

                // è¨­ç½®è¦–å£
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            showLoading() {
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
            <h3>âŒ éŒ¯èª¤</h3>
            <p>${message}</p>
            <button onclick="location.reload()">é‡æ–°è¼‰å…¥</button>
        `;
                document.body.appendChild(errorDiv);
            }
            async generateWorld() {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    let progress = 0;

                    // ç”Ÿæˆé«˜åº¦åœ–
                    const heightMap = this.generateHeightMap();

                    const generateChunk = (chunkX, chunkZ) => {
                        console.log(`é–‹å§‹ç”Ÿæˆå€å¡Š (${chunkX}, ${chunkZ})`);

                        const chunkSize = 16;
                        const startX = chunkX * chunkSize - this.worldSize / 2;
                        const startZ = chunkZ * chunkSize - this.worldSize / 2;

                        let blocksGenerated = 0;

                        for (let x = 0; x < chunkSize; x++) {
                            for (let z = 0; z < chunkSize; z++) {
                                const worldX = startX + x;
                                const worldZ = startZ + z;

                                if (Math.abs(worldX) >= this.worldSize / 2 || Math.abs(worldZ) >= this.worldSize / 2) continue;

                                const height = heightMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];

                                // åŸºå²©å±¤ï¼ˆæœ€åº•å±¤ï¼‰
                                for (let y = -3; y <= -1; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                    blocksGenerated++;
                                }

                                // åœ°ä¸‹çŸ³é ­å±¤
                                for (let y = 0; y < height - 1; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                    blocksGenerated++;
                                }

                                // è¡¨é¢è‰åœ°
                                if (height >= 0) {
                                    this.setBlock(worldX, height, worldZ, 'grass');
                                    blocksGenerated++;
                                }

                                // ç”Ÿæˆæ¨¹æœ¨ï¼ˆé™ä½å¯†åº¦ï¼‰
                                if (Math.random() < 0.02 && height > 2) {
                                    this.generateSimpleTree(worldX, height + 1, worldZ);
                                }

                                // æ°´é«”ï¼ˆæµ·å¹³é¢ç‚º0ï¼‰
                                if (height < 0) {
                                    for (let y = height + 1; y <= 0; y++) {
                                        this.setBlock(worldX, y, worldZ, 'water');
                                        blocksGenerated++;
                                    }
                                }
                            }
                        }

                        console.log(`å€å¡Š (${chunkX}, ${chunkZ}) ç”Ÿæˆäº† ${blocksGenerated} å€‹æ–¹å¡Š`);

                        try {
                            this.generateChunkMesh(chunkX, chunkZ);
                            console.log(`å€å¡Š (${chunkX}, ${chunkZ}) ç¶²æ ¼ç”ŸæˆæˆåŠŸ`);
                        } catch (error) {
                            console.error(`å€å¡Š (${chunkX}, ${chunkZ}) ç¶²æ ¼ç”Ÿæˆå¤±æ•—:`, error);
                        }
                    };

                    const totalChunks = Math.pow(Math.ceil(this.worldSize / 16), 2);
                    let processedChunks = 0;

                    const processNextChunk = () => {
                        const chunksPerFrame = 2;
                        const chunksPerSide = Math.ceil(this.worldSize / 16);

                        console.log(`è™•ç†å€å¡Šæ‰¹æ¬¡ï¼Œç•¶å‰é€²åº¦: ${processedChunks}/${totalChunks}`);
                        console.log(`æ¯é‚Šå€å¡Šæ•¸: ${chunksPerSide}, ç¸½å€å¡Šæ•¸: ${totalChunks}`);

                        for (let i = 0; i < chunksPerFrame && processedChunks < totalChunks; i++) {
                            const chunkX = Math.floor(processedChunks / chunksPerSide);
                            const chunkZ = processedChunks % chunksPerSide;

                            console.log(`ç”Ÿæˆå€å¡Š (${chunkX}, ${chunkZ}), ç´¢å¼•: ${processedChunks}`);

                            try {
                                generateChunk(chunkX, chunkZ);
                                processedChunks++;
                                console.log(`å€å¡Š (${chunkX}, ${chunkZ}) ç”ŸæˆæˆåŠŸ`);
                            } catch (error) {
                                console.error(`å€å¡Š (${chunkX}, ${chunkZ}) ç”Ÿæˆå¤±æ•—:`, error);
                                processedChunks++; // è·³ééŒ¯èª¤çš„å€å¡Š
                            }
                        }

                        progress = (processedChunks / totalChunks) * 100;
                        const progressBar = document.getElementById('loadingProgress');
                        const loadingText = document.querySelector('.loading');

                        if (progressBar) {
                            progressBar.style.width = progress + '%';
                        }
                        if (loadingText) {
                            loadingText.textContent = `ç”Ÿæˆä¸–ç•Œ ${Math.floor(progress)}%`;
                        }

                        console.log(`ç•¶å‰é€²åº¦: ${Math.floor(progress)}%`);

                        if (processedChunks >= totalChunks) {
                            this.worldGenerated = true;
                            console.log(`ä¸–ç•Œç”Ÿæˆå®Œæˆï¼Œè€—æ™‚: ${Date.now() - startTime}ms`);
                            console.log(`ç¸½å…±ç”Ÿæˆäº† ${this.world.size} å€‹æ–¹å¡Š`);
                            resolve();
                        } else {
                            requestAnimationFrame(processNextChunk);
                        }
                    };

                    processNextChunk();
                });
            }

            generateHeightMap() {
                const heightMap = [];
                for (let x = 0; x < this.worldSize; x++) {
                    heightMap[x] = [];
                    for (let z = 0; z < this.worldSize; z++) {
                        // æ”¹é€²çš„å™ªè²ç®—æ³•
                        const nx = (x - this.worldSize / 2) / this.worldSize;
                        const nz = (z - this.worldSize / 2) / this.worldSize;

                        // å¤šå±¤å™ªè²ç–ŠåŠ 
                        const noise1 = this.improvedNoise(nx * 4, nz * 4) * 6;
                        const noise2 = this.improvedNoise(nx * 8, nz * 8) * 3;
                        const noise3 = this.improvedNoise(nx * 16, nz * 16) * 1.5;

                        // åŸºç¤é«˜åº¦ + å™ªè²
                        const baseHeight = 2;
                        heightMap[x][z] = Math.floor(baseHeight + noise1 + noise2 + noise3);
                    }
                }
                return heightMap;
            }

            // æ·»åŠ æ”¹é€²çš„å™ªè²å‡½æ•¸
            improvedNoise(x, z) {
                // ä½¿ç”¨å¤šå€‹æ­£å¼¦æ³¢ç–ŠåŠ ç”¢ç”Ÿæ›´è‡ªç„¶çš„å™ªè²
                const n1 = Math.sin(x * 2.1 + z * 1.7) * 0.5;
                const n2 = Math.sin(x * 1.3 - z * 2.3) * 0.3;
                const n3 = Math.sin(x * 3.7 + z * 0.9) * 0.2;
                return (n1 + n2 + n3);
            }

            noise(x, z) {
                const n = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }

            generateTree(x, y, z) {
                // æ¨¹å¹¹
                for (let i = 0; i < 4; i++) {
                    this.setBlock(x, y + i, z, 'wood');
                }

                // æ¨¹è‘‰
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dy = 3; dy <= 5; dy++) {
                            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy - 4) <= 3 && Math.random() < 0.8) {
                                this.setBlock(x + dx, y + dy, z + dz, 'grass');
                            }
                        }
                    }
                }
            }

            generateSimpleTree(x, y, z) {
                // ç°¡å–®çš„æ¨¹å¹¹ï¼ˆ3æ ¼é«˜ï¼‰
                for (let i = 0; i < 3; i++) {
                    this.setBlock(x, y + i, z, 'wood');
                }

                // ç°¡å–®çš„æ¨¹è‘‰ï¼ˆåå­—å½¢ï¼‰
                const leafY = y + 3;
                this.setBlock(x, leafY, z, 'grass'); // ä¸­å¿ƒ
                this.setBlock(x + 1, leafY, z, 'grass');
                this.setBlock(x - 1, leafY, z, 'grass');
                this.setBlock(x, leafY, z + 1, 'grass');
                this.setBlock(x, leafY, z - 1, 'grass');

                // é ‚éƒ¨
                this.setBlock(x, leafY + 1, z, 'grass');
            }

            generateChunkMesh(chunkX, chunkZ) {
                console.log(`é–‹å§‹ç”Ÿæˆå€å¡Šç¶²æ ¼ (${chunkX}, ${chunkZ})`);

                // æ·»åŠ é‚Šç•Œæª¢æŸ¥
                if (chunkX < 0 || chunkZ < 0 ||
                    chunkX >= Math.ceil(this.worldSize / 16) ||
                    chunkZ >= Math.ceil(this.worldSize / 16)) {
                    console.warn(`å€å¡Š (${chunkX}, ${chunkZ}) è¶…å‡ºé‚Šç•Œï¼Œè·³é`);
                    return;
                }

                const chunkSize = 16;
                const vertices = [];
                const colors = [];
                const normals = [];
                const indices = [];
                let indexOffset = 0;

                const startX = chunkX * chunkSize - this.worldSize / 2;
                const startZ = chunkZ * chunkSize - this.worldSize / 2;

                for (let x = 0; x < chunkSize; x++) {
                    for (let z = 0; z < chunkSize; z++) {
                        for (let y = -5; y < 20; y++) {
                            const worldX = startX + x;
                            const worldZ = startZ + z;
                            const blockType = this.getBlock(worldX, y, worldZ);

                            if (!blockType) continue;

                            // æª¢æŸ¥æ¯å€‹é¢æ˜¯å¦éœ€è¦æ¸²æŸ“
                            // æª¢æŸ¥æ¯å€‹é¢æ˜¯å¦éœ€è¦æ¸²æŸ“ï¼ˆæ”¹é€²ç‰ˆï¼‰
                            // æª¢æŸ¥æ¯å€‹é¢æ˜¯å¦éœ€è¦æ¸²æŸ“ï¼ˆæ”¹é€²ç‰ˆï¼‰
                            const faces = [
                                { dir: [0, 1, 0], visible: this.shouldRenderFace(worldX, y + 1, worldZ, blockType) }, // ä¸Š
                                { dir: [0, -1, 0], visible: this.shouldRenderFace(worldX, y - 1, worldZ, blockType) }, // ä¸‹
                                { dir: [1, 0, 0], visible: this.shouldRenderFace(worldX + 1, y, worldZ, blockType) }, // å³
                                { dir: [-1, 0, 0], visible: this.shouldRenderFace(worldX - 1, y, worldZ, blockType) }, // å·¦
                                { dir: [0, 0, 1], visible: this.shouldRenderFace(worldX, y, worldZ + 1, blockType) }, // å‰
                                { dir: [0, 0, -1], visible: this.shouldRenderFace(worldX, y, worldZ - 1, blockType) } // å¾Œ
                            ];

                            // åœ¨ generateChunkMesh å‡½æ•¸ä¸­ï¼Œä¿®æ”¹é¡è‰²åˆ†é…é‚è¼¯
                            faces.forEach((face, faceIndex) => {
                                if (!face.visible) return;

                                const faceVertices = this.getFaceVertices(worldX, y, worldZ, faceIndex);

                                // ç¢ºä¿æ–¹å¡Šé¡å‹å­˜åœ¨
                                const blockInfo = this.blockTypes[blockType];
                                if (!blockInfo) {
                                    console.warn(`æœªçŸ¥æ–¹å¡Šé¡å‹: ${blockType}`);
                                    return;
                                }

                                // æ ¹æ“šé¢çš„æ–¹å‘é¸æ“‡é¡è‰²
                                let blockColor;
                                if (blockInfo.colors) {
                                    switch (faceIndex) {
                                        case 0: // ä¸Šé¢
                                            blockColor = blockInfo.colors.top;
                                            break;
                                        case 1: // ä¸‹é¢
                                            blockColor = blockInfo.colors.bottom;
                                            break;
                                        default: // å´é¢ (2,3,4,5)
                                            blockColor = blockInfo.colors.side;
                                            break;
                                    }
                                } else {
                                    blockColor = blockInfo.color || [0.5, 0.5, 0.5];
                                }

                                // ç¢ºä¿é¡è‰²æ•¸çµ„æœ‰æ•ˆ
                                if (!blockColor || blockColor.length !== 3) {
                                    console.warn(`ç„¡æ•ˆçš„æ–¹å¡Šé¡è‰²: ${blockType}`, blockColor);
                                    blockColor = [0.5, 0.5, 0.5]; // é è¨­ç°è‰²
                                }

                                // æ·»åŠ é¢å‘å…‰ç…§çš„é™°å½±æ•ˆæœ
                                const shadeFactor = this.calculateFaceShading(faceIndex, face.dir);
                                const shadedColor = [
                                    Math.max(0, Math.min(1, blockColor[0] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[1] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[2] * shadeFactor))
                                ];

                                // æ·»åŠ é ‚é»
                                for (let i = 0; i < 4; i++) {
                                    vertices.push(...faceVertices[i]);
                                    colors.push(...shadedColor);
                                    normals.push(...face.dir);
                                }

                                indices.push(
                                    indexOffset, indexOffset + 1, indexOffset + 2,
                                    indexOffset, indexOffset + 2, indexOffset + 3
                                );
                                indexOffset += 4;
                            });
                        }
                    }
                }

                console.log(`å€å¡Š (${chunkX}, ${chunkZ}) ç¶²æ ¼çµ±è¨ˆ: é ‚é»=${vertices.length / 3}, ç´¢å¼•=${indices.length}`);

                // å­˜å„²å€å¡Šç¶²æ ¼
                this.chunkMeshes.set(`${chunkX},${chunkZ}`, {
                    vertices: new Float32Array(vertices),
                    colors: new Float32Array(colors),
                    normals: new Float32Array(normals),
                    indices: new Uint16Array(indices),
                    vertexCount: vertices.length / 3,
                    indexCount: indices.length
                });

                console.log(`å€å¡Šç¶²æ ¼ (${chunkX}, ${chunkZ}) å·²å­˜å„²`);
            }

            calculateFaceShading(faceIndex, normal) {
                // åŸºæ–¼é¢çš„æ–¹å‘è¨ˆç®—å…‰ç…§å¼·åº¦
                const lightDirection = [0.3, 0.8, 0.5]; // å…‰æºæ–¹å‘

                // è¨ˆç®—æ³•ç·šèˆ‡å…‰æºçš„é»ç©
                const dotProduct = normal[0] * lightDirection[0] +
                    normal[1] * lightDirection[1] +
                    normal[2] * lightDirection[2];

                // åŸºç¤äº®åº¦ + æ–¹å‘å…‰ç…§
                const baseBrightness = 0.6;
                const directionalLight = Math.max(0, dotProduct) * 0.4;

                return Math.max(0.3, Math.min(1.0, baseBrightness + directionalLight));
            }

            shouldRenderFace(x, y, z, currentBlockType) {
                const neighborBlock = this.getBlock(x, y, z);

                // å¦‚æœé„°å±…ä½ç½®æ²’æœ‰æ–¹å¡Šï¼Œå‰‡æ¸²æŸ“é€™å€‹é¢
                if (!neighborBlock) {
                    return true;
                }

                // å¦‚æœé„°å±…æ˜¯é€æ˜æ–¹å¡Šï¼ˆå¦‚æ°´ï¼‰ï¼Œå‰‡æ¸²æŸ“é€™å€‹é¢
                if (this.blockTypes[neighborBlock] && this.blockTypes[neighborBlock].transparent) {
                    return true;
                }

                // å¦‚æœç•¶å‰æ–¹å¡Šæ˜¯é€æ˜çš„ï¼Œä¸”é„°å±…ä¸æ˜¯åŒé¡å‹ï¼Œå‰‡æ¸²æŸ“
                if (this.blockTypes[currentBlockType] && this.blockTypes[currentBlockType].transparent) {
                    return neighborBlock !== currentBlockType;
                }

                // å¦å‰‡ä¸æ¸²æŸ“ï¼ˆè¢«é®æ“‹ï¼‰
                return false;
            }

            getFaceVertices(x, y, z, faceIndex) {
                const vertices = [
                    // ä¸Šé¢ (y+1) - é€†æ™‚é‡
                    [[x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x + 1, y + 1, z]],
                    // ä¸‹é¢ (y) - é †æ™‚é‡
                    [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]],
                    // å³é¢ (x+1) - é€†æ™‚é‡
                    [[x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1], [x + 1, y, z + 1]],
                    // å·¦é¢ (x) - é †æ™‚é‡
                    [[x, y, z + 1], [x, y + 1, z + 1], [x, y + 1, z], [x, y, z]],
                    // å‰é¢ (z+1) - é€†æ™‚é‡
                    [[x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1]],
                    // å¾Œé¢ (z) - é †æ™‚é‡
                    [[x + 1, y, z], [x, y, z], [x, y + 1, z], [x + 1, y + 1, z]]
                ];

                return vertices[faceIndex];
            }

            setBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                this.world.set(key, type);
            }

            getBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                return this.world.get(key);
            }

            isTransparent(x, y, z) {
                const blockType = this.getBlock(x, y, z);
                return blockType === 'water'; // æ°´æ˜¯é€æ˜çš„
            }

            removeBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                this.world.delete(key);

                // æ­£ç¢ºè¨ˆç®—å€å¡Šç´¢å¼•
                const chunkX = Math.floor((x + this.worldSize / 2) / 16);
                const chunkZ = Math.floor((z + this.worldSize / 2) / 16);

                console.log(`åˆªé™¤æ–¹å¡Š (${x},${y},${z}), é‡æ–°ç”Ÿæˆå€å¡Š (${chunkX},${chunkZ})`);

                // é‡æ–°ç”Ÿæˆå—å½±éŸ¿çš„å€å¡Šç¶²æ ¼
                this.generateChunkMesh(chunkX, chunkZ);

                // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°ç”Ÿæˆç›¸é„°å€å¡Š
                const localX = (x + this.worldSize / 2) % 16;
                const localZ = (z + this.worldSize / 2) % 16;

                const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                if (localX === 0 && chunkX > 0) {
                    this.generateChunkMesh(chunkX - 1, chunkZ);
                }
                if (localX === 15 && chunkX < maxChunkIndex) {
                    this.generateChunkMesh(chunkX + 1, chunkZ);
                }
                if (localZ === 0 && chunkZ > 0) {
                    this.generateChunkMesh(chunkX, chunkZ - 1);
                }
                if (localZ === 15 && chunkZ < maxChunkIndex) {
                    this.generateChunkMesh(chunkX, chunkZ + 1);
                }
            }
            setupEventListeners() {
                // é–‹å§‹æŒ‰éˆ•
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                // éµç›¤äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    // é¸æ“‡æ–¹å¡Šé¡å‹
                    if (e.code >= 'Digit1' && e.code <= 'Digit4') {
                        const index = parseInt(e.code.slice(-1)) - 1;
                        const types = Object.keys(this.blockTypes);
                        if (types[index]) {
                            this.selectedBlock = types[index];
                            this.updateInventoryUI();
                        }
                    }

                    // é£›è¡Œæ¨¡å¼åˆ‡æ›
                    if (e.code === 'KeyF') {
                        this.flying = !this.flying;
                        this.player.velocity.y = 0;
                    }

                    // é˜²æ­¢ç©ºç™½éµæ»¾å‹•é é¢
                    if (e.code === 'Space') {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // æ»‘é¼ äº‹ä»¶
                this.canvas.addEventListener('click', () => {
                    if (this.gameStarted) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.player.angle += e.movementX * 0.003;
                        this.player.pitch -= e.movementY * 0.003;
                        this.player.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.player.pitch));
                    }
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.gameStarted || !this.worldGenerated) return;

                    const target = this.getTargetBlock();
                    if (target) {
                        if (e.button === 0) { // å·¦éµ - ç ´å£
                            this.removeBlock(target.x, target.y, target.z);
                        } else if (e.button === 2) { // å³éµ - æ”¾ç½®
                            const place = this.getPlacePosition(target);
                            if (place && !this.isPlayerColliding(place.x, place.y, place.z)) {
                                this.setBlock(place.x, place.y, place.z, this.selectedBlock);

                                console.log(`æ”¾ç½®æ–¹å¡Š (${place.x},${place.y},${place.z})`);

                                // æ­£ç¢ºè¨ˆç®—ä¸¦é‡æ–°ç”Ÿæˆç¶²æ ¼
                                const chunkX = Math.floor((place.x + this.worldSize / 2) / 16);
                                const chunkZ = Math.floor((place.z + this.worldSize / 2) / 16);

                                this.generateChunkMesh(chunkX, chunkZ);

                                // æª¢æŸ¥ç›¸é„°å€å¡Š
                                const localX = (place.x + this.worldSize / 2) % 16;
                                const localZ = (place.z + this.worldSize / 2) % 16;
                                const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                                if (localX === 0 && chunkX > 0) {
                                    this.generateChunkMesh(chunkX - 1, chunkZ);
                                }
                                if (localX === 15 && chunkX < maxChunkIndex) {
                                    this.generateChunkMesh(chunkX + 1, chunkZ);
                                }
                                if (localZ === 0 && chunkZ > 0) {
                                    this.generateChunkMesh(chunkX, chunkZ - 1);
                                }
                                if (localZ === 15 && chunkZ < maxChunkIndex) {
                                    this.generateChunkMesh(chunkX, chunkZ + 1);
                                }
                            }
                        }
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // ç‰©å“æ¬„é»æ“Š
                document.querySelectorAll('.inventory-slot').forEach((slot) => {
                    slot.addEventListener('click', () => {
                        const blockType = slot.dataset.block;
                        this.selectedBlock = blockType;
                        this.updateInventoryUI();
                    });
                });

                // è¦–çª—å¤§å°èª¿æ•´
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                    // é‡æ–°è¨ˆç®—æŠ•å½±çŸ©é™£
                    const aspect = this.canvas.width / this.canvas.height;
                    this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);
                });
            }

            startGame() {
                if (!this.worldGenerated) {
                    alert('ä¸–ç•Œé‚„åœ¨ç”Ÿæˆä¸­ï¼Œè«‹ç¨å€™...');
                    return;
                }
                this.gameStarted = true;
                document.getElementById('instructions').style.display = 'none';

                // å°‡ç©å®¶æ”¾ç½®åœ¨æ›´å®‰å…¨çš„ä½ç½®
                this.player.x = 0;
                this.player.z = 0;
                this.player.y = Math.max(5, this.getHighestBlock(0, 0) + 3);

                console.log(`ç©å®¶ä½ç½®: (${this.player.x}, ${this.player.y}, ${this.player.z})`);
                console.log('éŠæˆ²å·²å•Ÿå‹•ï¼');
            }

            getHighestBlock(x, z) {
                for (let y = 20; y >= -10; y--) {
                    if (this.getBlock(Math.floor(x), y, Math.floor(z))) {
                        return y;
                    }
                }
                return 0;
            }

            updateInventoryUI() {
                document.querySelectorAll('.inventory-slot').forEach(slot => {
                    slot.classList.remove('active');
                    if (slot.dataset.block === this.selectedBlock) {
                        slot.classList.add('active');
                    }
                });
            }

            getTargetBlock() {
                const range = 8;
                const step = 0.05; // æ›´å°çš„æ­¥é•·ï¼Œæ›´ç²¾ç¢º

                const startX = this.player.x;
                const startY = this.player.y + 1.6; // çœ¼ç›é«˜åº¦
                const startZ = this.player.z;

                // è¨ˆç®—å°„ç·šæ–¹å‘
                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                for (let d = 0; d < range; d += step) {
                    const x = Math.floor(startX + dirX * d);
                    const y = Math.floor(startY + dirY * d);
                    const z = Math.floor(startZ + dirZ * d);

                    if (this.getBlock(x, y, z)) {
                        return {
                            x, y, z,
                            hitX: startX + dirX * d,
                            hitY: startY + dirY * d,
                            hitZ: startZ + dirZ * d
                        };
                    }
                }
                return null;
            }

            getPlacePosition(target) {
                if (!target) return null;

                // è¨ˆç®—å°„ç·šæ–¹å‘
                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                // æ ¹æ“šæ’æ“Šé»ç¢ºå®šæ”¾ç½®é¢
                const hitX = target.hitX - target.x;
                const hitY = target.hitY - target.y;
                const hitZ = target.hitZ - target.z;

                let placeX = target.x;
                let placeY = target.y;
                let placeZ = target.z;

                // ç¢ºå®šæœ€æ¥è¿‘çš„é¢
                const absX = Math.abs(hitX - 0.5);
                const absY = Math.abs(hitY - 0.5);
                const absZ = Math.abs(hitZ - 0.5);

                if (absX > absY && absX > absZ) {
                    // Xé¢
                    placeX += hitX > 0.5 ? 1 : -1;
                } else if (absY > absZ) {
                    // Yé¢
                    placeY += hitY > 0.5 ? 1 : -1;
                } else {
                    // Zé¢
                    placeZ += hitZ > 0.5 ? 1 : -1;
                }

                // æª¢æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                if (!this.getBlock(placeX, placeY, placeZ)) {
                    return { x: placeX, y: placeY, z: placeZ };
                }

                return null;
            }

            isPlayerColliding(x, y, z) {
                const px = Math.floor(this.player.x);
                const py = Math.floor(this.player.y);
                const pz = Math.floor(this.player.z);

                return (Math.abs(x - px) <= 1 && Math.abs(y - py) <= 2 && Math.abs(z - pz) <= 1);
            }

            checkCollision(x, y, z) {
                const blockX = Math.floor(x);
                const blockY = Math.floor(y);
                const blockZ = Math.floor(z);

                // æª¢æŸ¥ç©å®¶ä½”ç”¨çš„ç©ºé–“ï¼ˆ2æ ¼é«˜ï¼‰
                for (let dy = 0; dy < 2; dy++) {
                    if (this.getBlock(blockX, blockY + dy, blockZ)) {
                        return true;
                    }
                }
                return false;
            }

            updatePlayer() {
                if (!this.gameStarted || !this.worldGenerated) return;

                const speed = 0.15;
                const sprintMultiplier = this.keys['ShiftLeft'] && !this.flying ? 0.5 : (this.keys['ControlLeft'] ? 2 : 1);
                const moveSpeed = speed * sprintMultiplier;

                // ç§»å‹•è¨ˆç®—
                let moveX = 0, moveZ = 0;

                if (this.keys['KeyW']) {
                    moveX += Math.cos(this.player.angle) * moveSpeed;
                    moveZ += Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['KeyS']) {
                    moveX -= Math.cos(this.player.angle) * moveSpeed;
                    moveZ -= Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['KeyA']) {
                    moveX += Math.cos(this.player.angle - Math.PI / 2) * moveSpeed;
                    moveZ += Math.sin(this.player.angle - Math.PI / 2) * moveSpeed;
                }
                if (this.keys['KeyD']) {
                    moveX += Math.cos(this.player.angle + Math.PI / 2) * moveSpeed;
                    moveZ += Math.sin(this.player.angle + Math.PI / 2) * moveSpeed;
                }

                // ç¢°æ’æª¢æ¸¬
                const newX = this.player.x + moveX;
                const newZ = this.player.z + moveZ;

                if (!this.checkCollision(newX, this.player.y, this.player.z)) {
                    this.player.x = newX;
                }
                if (!this.checkCollision(this.player.x, this.player.y, newZ)) {
                    this.player.z = newZ;
                }

                // é£›è¡Œæ¨¡å¼
                if (this.flying) {
                    if (this.keys['Space']) this.player.y += moveSpeed;
                    if (this.keys['ShiftLeft']) this.player.y -= moveSpeed;
                    this.player.velocity.y = 0;
                    this.player.onGround = false;
                } else {
                    // é‡åŠ›å’Œè·³èº
                    this.player.velocity.y += this.gravity;

                    if (this.keys['Space'] && this.player.onGround) {
                        this.player.velocity.y = this.jumpPower;
                        this.player.onGround = false;
                    }

                    // å‚ç›´ç§»å‹•
                    const newY = this.player.y + this.player.velocity.y;
                    if (!this.checkCollision(this.player.x, newY, this.player.z)) {
                        this.player.y = newY;
                        this.player.onGround = false;
                    } else {
                        if (this.player.velocity.y < 0) {
                            this.player.onGround = true;
                        }
                        this.player.velocity.y = 0;
                    }
                }
            }

            updateUI() {
                document.getElementById('position').textContent =
                    `${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)}`;
                document.getElementById('direction').textContent =
                    `${(this.player.angle * 180 / Math.PI).toFixed(0)}Â°`;
                document.getElementById('blockCount').textContent = this.world.size;
                document.getElementById('renderInfo').textContent =
                    `WebGL ${this.flying ? '(é£›è¡Œ)' : '(ç”Ÿå­˜)'}`;

                // æ›´æ–°ç”Ÿç‰©ç¾¤è½
                const biome = this.getBiome(this.player.x, this.player.z);
                document.getElementById('biome').textContent = biome;

                // æ›´æ–°èª¿è©¦ä¿¡æ¯
                document.getElementById('triangleCount').textContent = this.triangleCount;
                document.getElementById('vertexCount').textContent = this.vertexCount;
                document.getElementById('drawCalls').textContent = this.drawCalls;
            }

            getBiome(x, z) {
                const height = this.getHighestBlock(x, z);
                if (height < -1) return 'æµ·æ´‹';
                if (height > 5) return 'å±±åœ°';
                return 'å¹³åŸ';
            }

            updateMinimap() {
                this.minimapCtx.fillStyle = '#000';
                this.minimapCtx.fillRect(0, 0, 180, 180);

                const mapRange = 20;
                const scale = 180 / (mapRange * 2);

                // ç¹ªè£½åœ°å½¢
                for (let x = -mapRange; x <= mapRange; x++) {
                    for (let z = -mapRange; z <= mapRange; z++) {
                        const worldX = Math.floor(this.player.x) + x;
                        const worldZ = Math.floor(this.player.z) + z;
                        const height = this.getHighestBlock(worldX, worldZ);

                        if (height > -10) {
                            const brightness = Math.max(0, Math.min(1, (height + 5) / 15));
                            this.minimapCtx.fillStyle = `rgb(${Math.floor(76 * brightness)}, ${Math.floor(175 * brightness)}, ${Math.floor(80 * brightness)})`;
                            this.minimapCtx.fillRect(
                                90 + x * scale - scale / 2,
                                90 + z * scale - scale / 2,
                                scale, scale
                            );
                        }
                    }
                }

                // ç¹ªè£½ç©å®¶ä½ç½®
                this.minimapCtx.fillStyle = '#00ff88';
                this.minimapCtx.fillRect(88, 88, 4, 4);

                // ç¹ªè£½æ–¹å‘æŒ‡ç¤ºå™¨
                this.minimapCtx.strokeStyle = '#00ff88';
                this.minimapCtx.lineWidth = 2;
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(90, 90);
                this.minimapCtx.lineTo(
                    90 + Math.cos(this.player.angle) * 15,
                    90 + Math.sin(this.player.angle) * 15
                );
                this.minimapCtx.stroke();
            }

            updateViewMatrix() {
                // è¨ˆç®—æ”åƒæ©Ÿä½ç½®å’Œç›®æ¨™
                const eye = [this.player.x, this.player.y + 1.6, this.player.z]; // ç©å®¶çœ¼ç›é«˜åº¦
                const target = [
                    this.player.x + Math.cos(this.player.angle) * Math.cos(this.player.pitch),
                    this.player.y + 1.6 + Math.sin(this.player.pitch),
                    this.player.z + Math.sin(this.player.angle) * Math.cos(this.player.pitch)
                ];
                const up = [0, 1, 0];

                this.lookAt(this.viewMatrix, eye, target, up);
            }

            // åœ¨ render å‡½æ•¸ä¸­ï¼Œä¿®æ”¹å…‰ç…§è¨­ç½®
            render() {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                if (!this.gameStarted || !this.worldGenerated) return;

                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                this.updateViewMatrix();

                this.identity(this.modelMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, this.projectionMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.viewMatrix, false, this.viewMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix);

                // æ”¹é€²çš„å…‰ç…§è¨­ç½®
                this.gl.uniform3f(this.uniforms.lightDirection, 0.3, 0.8, 0.5); // æ›´è‡ªç„¶çš„å…‰ç…§æ–¹å‘
                this.gl.uniform3f(this.uniforms.ambientLight, 0.6, 0.6, 0.6);   // æ›´äº®çš„ç’°å¢ƒå…‰

                this.renderVisibleChunks();
            }

            renderVisibleChunks() {
                const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                let renderedChunks = 0;
                let skippedChunks = 0;

                // å¾ç©å®¶ä½ç½®å‘å¤–æ¸²æŸ“ï¼Œç¢ºä¿è¿‘è™•å„ªå…ˆ
                for (let radius = 0; radius <= renderChunkDistance; radius++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dz = -radius; dz <= radius; dz++) {
                            if (Math.abs(dx) !== radius && Math.abs(dz) !== radius) continue;

                            const chunkX = playerChunkX + dx;
                            const chunkZ = playerChunkZ + dz;

                            // é‚Šç•Œæª¢æŸ¥
                            if (chunkX < 0 || chunkZ < 0 ||
                                chunkX >= Math.ceil(this.worldSize / 16) ||
                                chunkZ >= Math.ceil(this.worldSize / 16)) continue;

                            const chunkKey = `${chunkX},${chunkZ}`;
                            const mesh = this.chunkMeshes.get(chunkKey);

                            if (!mesh || mesh.indexCount === 0) {
                                skippedChunks++;
                                continue;
                            }

                            this.renderChunk(chunkX, chunkZ);
                            renderedChunks++;
                        }
                    }
                }

                // æ›´æ–°èª¿è©¦ä¿¡æ¯
                if (this.frameCount % 60 === 0) {
                    console.log(`æ¸²æŸ“çµ±è¨ˆ: ${renderedChunks} å€‹å€å¡Š, è·³é: ${skippedChunks} å€‹`);
                }
            }

            renderChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX},${chunkZ}`;
                const mesh = this.chunkMeshes.get(chunkKey);

                if (!mesh || mesh.indexCount === 0) {
                    return;
                }

                // ç¢ºä¿æ·±åº¦æ¸¬è©¦ç‹€æ…‹æ­£ç¢º
                if (!this.gl.getParameter(this.gl.DEPTH_TEST)) {
                    console.warn('æ·±åº¦æ¸¬è©¦æœªå•Ÿç”¨ï¼Œé‡æ–°å•Ÿç”¨');
                    this.gl.enable(this.gl.DEPTH_TEST);
                }

                // æª¢æŸ¥WebGLç‹€æ…‹
                if (this.gl.isContextLost()) {
                    console.error('WebGLä¸Šä¸‹æ–‡ä¸Ÿå¤±');
                    return;
                }

                try {
                    // ç¶å®šé ‚é»æ•¸æ“š
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.vertices, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.position);
                    this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                    // ç¶å®šé¡è‰²æ•¸æ“š
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.colors, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.color);
                    this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                    // ç¶å®šæ³•ç·šæ•¸æ“š
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.normals, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.normal);
                    this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                    // ç¶å®šç´¢å¼•æ•¸æ“š
                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices, this.gl.STATIC_DRAW);

                    // æª¢æŸ¥WebGLéŒ¯èª¤
                    const error = this.gl.getError();
                    if (error !== this.gl.NO_ERROR) {
                        console.error(`WebGLéŒ¯èª¤: ${error}`);
                        return;
                    }

                    // ç¹ªè£½
                    this.gl.drawElements(this.gl.TRIANGLES, mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);

                    // æ›´æ–°çµ±è¨ˆ
                    this.triangleCount += mesh.indexCount / 3;
                    this.vertexCount += mesh.vertexCount;
                    this.drawCalls++;

                } catch (error) {
                    console.error(`æ¸²æŸ“å€å¡Š ${chunkKey} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                }
            }

            update(currentTime) {
                // è¨ˆç®—FPS
                if (this.lastFrameTime) {
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.frameCount++;

                    if (this.frameCount % 60 === 0) {
                        this.fps = Math.round(1000 / deltaTime);
                        document.getElementById('fpsCounter').textContent = this.fps;
                    }
                }
                this.lastFrameTime = currentTime;

                // æ›´æ–°éŠæˆ²é‚è¼¯
                this.updatePlayer();
                this.updateUI();
                this.updateMinimap();
            }

            gameLoop() {
                const currentTime = performance.now();

                this.update(currentTime);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }
        } // é€™è£¡çµæŸ WebGLMinecraft é¡åˆ¥

        // å•Ÿå‹•éŠæˆ²
        window.addEventListener('load', () => {
            // ... å…¶é¤˜ä»£ç¢¼
        });


        // å•Ÿå‹•éŠæˆ²
        window.addEventListener('load', () => {
            // æª¢æŸ¥WebGLæ”¯æ´
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                document.body.innerHTML = `
            <div class="error-message">
                <h3>âŒ WebGL ä¸æ”¯æ´</h3>
                <p>æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´WebGLï¼Œç„¡æ³•é‹è¡Œæ­¤éŠæˆ²ã€‚</p>
                <p>è«‹å˜—è©¦ä½¿ç”¨ç¾ä»£ç€è¦½å™¨å¦‚Chromeã€Firefoxæˆ–Edgeã€‚</p>
                <button onclick="location.reload()">é‡æ–°æª¢æ¸¬</button>
            </div>
        `;
                return;
            }

            try {
                new WebGLMinecraft();
            } catch (error) {
                console.error('éŠæˆ²å•Ÿå‹•å¤±æ•—:', error);
                document.body.innerHTML = `
            <div class="error-message">
                <h3>âŒ å•Ÿå‹•å¤±æ•—</h3>
                <p>éŠæˆ²å•Ÿå‹•æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}</p>
                <button onclick="location.reload()">é‡æ–°å•Ÿå‹•</button>
            </div>
        `;
            }
        });

        // æ·»åŠ ä¸€äº›å¯¦ç”¨çš„å…¨åŸŸå‡½æ•¸
        window.toggleFullscreen = function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        };

        // æ€§èƒ½ç›£æ§
        window.addEventListener('beforeunload', () => {
            console.log('éŠæˆ²æœƒè©±çµæŸ');
        });

        // è™•ç†é é¢å¯è¦‹æ€§è®ŠåŒ–
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('éŠæˆ²æš«åœ');
            } else {
                console.log('éŠæˆ²æ¢å¾©');
            }
        });

    </script>
</body>

</html>