<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Minecraft 3D - Â§ö‰∫∫Áâà</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        /* ÊîπÈÄ≤ÁöÑÈÅäÊà≤UIÊ®£Âºè */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 20, 0.9));
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0, 255, 136, 0.3);
            font-size: 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 250px;
        }

        #ui div {
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #ui div:last-child {
            border-bottom: none;
        }

        #ui span {
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        /* ÊîπÈÄ≤ÁöÑÁâ©ÂìÅÊ¨ÑÊ®£Âºè */
        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.95));
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 3px solid rgba(0, 255, 136, 0.4);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .inventory-slot {
            width: 80px;
            height: 80px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.9), rgba(60, 60, 60, 0.8));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .inventory-slot:hover::before {
            transform: translateX(100%);
        }

        .inventory-slot:hover {
            transform: scale(1.1) translateY(-5px);
            border-color: rgba(0, 255, 136, 0.8);
            box-shadow: 0 15px 30px rgba(0, 255, 136, 0.3);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.3));
        }

        .inventory-slot.active {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 200, 100, 0.4));
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6), inset 0 0 20px rgba(0, 255, 136, 0.2);
            animation: activeSlot 2s infinite;
        }

        @keyframes activeSlot {

            0%,
            100% {
                box-shadow: 0 0 30px rgba(0, 255, 136, 0.6), inset 0 0 20px rgba(0, 255, 136, 0.2);
            }

            50% {
                box-shadow: 0 0 40px rgba(0, 255, 136, 0.8), inset 0 0 30px rgba(0, 255, 136, 0.4);
            }
        }

        .inventory-slot .block-icon {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 5px;
        }

        .inventory-slot .block-name {
            font-size: 0.8em;
            opacity: 0.8;
            text-align: center;
        }

        /* ÊîπÈÄ≤ÁöÑËÅäÂ§©Á≥ªÁµ±Ê®£Âºè */
        #chatContainer {
            position: absolute;
            bottom: 140px;
            left: 20px;
            width: 450px;
            height: 220px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 20, 0.9));
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            z-index: 200;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #chatMessages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-size: 14px;
            color: white;
        }

        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.5);
            border-radius: 4px;
        }

        .chat-message {
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid rgba(0, 255, 136, 0.5);
            animation: messageSlide 0.3s ease-out;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .chat-message.system {
            color: #ffff00;
            font-style: italic;
            border-left-color: #ffff00;
            background: rgba(255, 255, 0, 0.1);
        }

        .chat-message.player {
            color: #00ff88;
            border-left-color: #00ff88;
        }

        #chatInput {
            display: flex;
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 25px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        #messageInput:focus {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            background: rgba(0, 0, 0, 0.9);
        }

        #sendMessage {
            padding: 12px 20px;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: black;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        #sendMessage:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }

        /* ÊîπÈÄ≤ÁöÑFPSÂíåÂ∞èÂú∞ÂúñÊ®£Âºè */
        #fps {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 20, 0.9));
            padding: 15px 20px;
            border-radius: 15px;
            font-weight: bold;
            border: 2px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.95));
            border: 3px solid #00ff88;
            border-radius: 20px;
            z-index: 100;
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(15px);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair"></div>

        <div id="ui">
            <div>üåç Â∫ßÊ®ô: <span id="position">0, 0, 0</span></div>
            <div>üß≠ ÊñπÂêë: <span id="direction">0¬∞</span></div>
            <div>üì¶ ÊñπÂ°ä: <span id="blockCount">0</span></div>
            <div>üèîÔ∏è ÁîüÁâ©Áæ§ËêΩ: <span id="biome">Âπ≥Âéü</span></div>
            <div>‚ö° Ê∏≤Êüì: <span id="renderInfo">WebGL</span></div>
            <div>üë• Áé©ÂÆ∂: <span id="playerCount">1</span></div>
            <div>üåê ÈÄ£Á∑ö: <span id="connectionStatus">Èõ¢Á∑ö</span></div>
            <div>üì° P2P: <span id="p2pStatus">Êú™ÈÄ£Êé•</span></div>
            <div>üî• Firebase: <span id="firebaseStatus">ÈÄ£Êé•‰∏≠...</span></div>
        </div>

        <div id="fps">FPS: <span id="fpsCounter">60</span></div>

        <canvas id="minimap"></canvas>

        <div id="inventory">
            <div class="inventory-slot active" data-block="grass">
                <div class="block-icon">üü©</div>
                <div class="block-name">ËçâÂú∞</div>
            </div>
            <div class="inventory-slot" data-block="stone">
                <div class="block-icon">‚¨ú</div>
                <div class="block-name">Áü≥È†≠</div>
            </div>
            <div class="inventory-slot" data-block="wood">
                <div class="block-icon">üü´</div>
                <div class="block-name">Êú®È†≠</div>
            </div>
            <div class="inventory-slot" data-block="water">
                <div class="block-icon">üü¶</div>
                <div class="block-name">Ê∞¥</div>
            </div>
            <div class="inventory-slot" data-block="sand">
                <div class="block-icon">üü®</div>
                <div class="block-name">Ê≤ôÂ≠ê</div>
            </div>
            <div class="inventory-slot" data-block="snow">
                <div class="block-icon">‚ùÑÔ∏è</div>
                <div class="block-name">Èõ™</div>
            </div>
            <div class="inventory-slot" data-block="leaves">
                <div class="block-icon">üü¢</div>
                <div class="block-name">Ê®πËëâ</div>
            </div>
            <div class="inventory-slot" data-block="cobblestone">
                <div class="block-icon">üîò</div>
                <div class="block-name">ÈµùÂçµÁü≥</div>
            </div>
            <div class="inventory-slot" data-block="brick">
                <div class="block-icon">üß±</div>
                <div class="block-name">Á£öÂ°ä</div>
            </div>
            <div class="inventory-slot" data-block="glass">
                <div class="block-icon">üî∑</div>
                <div class="block-name">ÁéªÁíÉ</div>
            </div>
        </div>
        <!-- Êö´ÂÅúÈÅ∏ÂñÆ -->
        <div id="pauseMenu" style="display: none;">
            <div class="menu-container">
                <h2>‚è∏Ô∏è ÈÅäÊà≤Êö´ÂÅú</h2>
                <div class="menu-buttons">
                    <button id="resumeButton" class="menu-btn">‚ñ∂Ô∏è ÁπºÁ∫åÈÅäÊà≤</button>
                    <button id="multiplayerButton" class="menu-btn">üë• Â§ö‰∫∫ÈÅäÊà≤</button>
                    <button id="settingsButton" class="menu-btn">‚öôÔ∏è Ë®≠ÂÆö</button>
                    <button id="mainMenuButton" class="menu-btn">üè† ‰∏ªÈÅ∏ÂñÆ</button>
                </div>
            </div>
        </div>

        <!-- Â§ö‰∫∫ÈÅäÊà≤ÈÅ∏ÂñÆ -->
        <div id="connectionStatus" style="display: none; margin-top: 15px;">
            <div class="status-message">
                <span id="statusText">Ê∫ñÂÇôÈÄ£Êé•...</span>
            </div>
        </div>
        <div id="multiplayerMenu" style="display: none;">
            <div class="menu-container">
                <h2>üë• Â§ö‰∫∫ÈÅäÊà≤</h2>
                <div class="multiplayer-options">
                    <div class="input-group">
                        <label>Áé©ÂÆ∂ÂêçÁ®±:</label>
                        <input type="text" id="playerName" placeholder="Ëº∏ÂÖ•‰Ω†ÁöÑÂêçÁ®±" maxlength="16">
                    </div>
                    <div class="input-group">
                        <label>ÊàøÈñìID:</label>
                        <input type="text" id="roomId" placeholder="Ëº∏ÂÖ•ÊàøÈñìIDÊàñÁïôÁ©∫ÂâµÂª∫Êñ∞ÊàøÈñì" maxlength="10">
                    </div>
                    <div class="menu-buttons">
                        <button id="joinRoomButton" class="menu-btn">üö™ Âä†ÂÖ•ÊàøÈñì</button>
                        <button id="createRoomButton" class="menu-btn">‚ûï ÂâµÂª∫ÊàøÈñì</button>
                        <button id="backToGameButton" class="menu-btn">‚¨ÖÔ∏è ËøîÂõû</button>
                    </div>
                    <div id="roomInfo" style="display: none;">
                        <h3>ÊàøÈñìË≥áË®ä</h3>
                        <p>ÊàøÈñìID: <span id="currentRoomId"></span></p>
                        <p>Áé©ÂÆ∂Êï∏Èáè: <span id="roomPlayerCount">1</span></p>
                        <div id="playerList"></div>
                        <div class="menu-buttons" style="margin-top: 20px;">
                            <button id="startGameButton" class="menu-btn">üéÆ ÈñãÂßãÈÅäÊà≤</button>
                            <button id="leaveRoomButton" class="menu-btn">üö™ Èõ¢ÈñãÊàøÈñì</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ‰∏ªÈÅ∏ÂñÆÊõ¥Êñ∞ -->
        <!-- ÈáçÊñ∞Ë®≠Ë®àÁöÑ‰∏ªÈÅ∏ÂñÆ -->
        <!-- ÈáçÊñ∞Ë®≠Ë®àÁöÑ‰∏ªÈÅ∏ÂñÆ -->
        <div id="instructions">
            <!-- ËÉåÊôØÂ±§ -->
            <div class="main-menu-background">
                <!-- ÂãïÊÖãËÉåÊôØÊïàÊûú -->
                <div class="bg-layer bg-layer-1"></div>
                <div class="bg-layer bg-layer-2"></div>
                <div class="bg-layer bg-layer-3"></div>
                <!-- ÈÅÆÁΩ©Â±§ -->
                <div class="bg-overlay"></div>
            </div>

            <!-- ÂÖßÂÆπÂ±§ -->
            <div class="main-menu-content">
                <div class="game-logo">
                    <h1>Mini Minecraft</h1>
                    <p class="subtitle">credits to NotLing</p>
                </div>

                <div class="menu-section">
                    <h2>üöÄ ÈñãÂßãÈÅäÊà≤</h2>
                    <div class="game-modes">
                        <button id="singlePlayerButton" class="mode-btn primary">
                            <div class="btn-icon">üéØ</div>
                            <div class="btn-content">
                                <div class="btn-title">ÂñÆ‰∫∫ÈÅäÊà≤</div>
                                <div class="btn-desc">Êé¢Á¥¢‰∏ñÁïå</div>
                            </div>
                        </button>
                        <button id="multiPlayerStartButton" class="mode-btn secondary">
                            <div class="btn-icon">üë•</div>
                            <div class="btn-content">
                                <div class="btn-title">Â§ö‰∫∫ÈÅäÊà≤</div>
                                <div class="btn-desc">ËàáÊúãÂèã‰∏ÄËµ∑Âª∫ÈÄ†</div>
                            </div>
                        </button>
                    </div>
                </div>

                <div class="menu-section">
                    <h2>üéÆ ÈÅäÊà≤Êìç‰Ωú</h2>
                    <div class="controls-grid">
                        <div class="control-group">
                            <div class="control-category">ÁßªÂãïÊéßÂà∂</div>
                            <div class="control-item"><kbd>WASD</kbd> ÁßªÂãïËßíËâ≤</div>
                            <div class="control-item"><kbd>ÊªëÈº†</kbd> ËΩâÂãïË¶ñËßí</div>
                            <div class="control-item"><kbd>Á©∫ÁôΩÈçµ</kbd> Ë∑≥Ë∫ç</div>
                            <div class="control-item"><kbd>Shift</kbd> ÊΩõË°å/‰∏ãÈôç</div>
                        </div>
                        <div class="control-group">
                            <div class="control-category">Âª∫ÈÄ†ÊéßÂà∂</div>
                            <div class="control-item"><kbd>Â∑¶Èçµ</kbd> Á†¥Â£ûÊñπÂ°ä</div>
                            <div class="control-item"><kbd>Âè≥Èçµ</kbd> ÊîæÁΩÆÊñπÂ°ä</div>
                            <div class="control-item"><kbd>ÊªæËº™</kbd> ÂàáÊèõÊñπÂ°ä</div>
                            <div class="control-item"><kbd>F</kbd> È£õË°åÊ®°Âºè</div>
                        </div>
                        <div class="control-group">
                            <div class="control-category">Á≥ªÁµ±ÊéßÂà∂</div>
                            <div class="control-item"><kbd>ESC</kbd> Êö´ÂÅúÈÅ∏ÂñÆ</div>
                            <div class="control-item"><kbd>T</kbd> ËÅäÂ§© (Â§ö‰∫∫)</div>
                            <div class="control-item"><kbd>F11</kbd> ÂÖ®Ëû¢Âπï</div>
                        </div>
                    </div>
                </div>

                <div class="menu-footer">
                    <div class="version-info">
                        <span>üî• WebGLÂºïÊìé</span>
                        <span>üåç ÁÑ°Èôê‰∏ñÁïå</span>
                        <span>‚ö° ÂØ¶ÊôÇÂ§ö‰∫∫</span>
                        <span>üéÆ 10Á®ÆÊñπÂ°ä</span>
                        <span>üèóÔ∏è 5Á®ÆÁîüÁâ©Áæ§ËêΩ</span>
                    </div>
                    <div class="copyright">
                        <p style="color: rgba(255,255,255,0.5); font-size: 0.8em; margin-top: 15px;">
                            ¬© 2024 WebGL Minecraft - ‰ΩøÁî®Áèæ‰ª£Á∂≤È†ÅÊäÄË°ìÊâìÈÄ†
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div id="loading" class="loading" style="display: none;">
            Ê≠£Âú®ÂàùÂßãÂåñ WebGL ÂºïÊìé
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>

        <div id="debug">
            <div>‰∏âËßíÂΩ¢: <span id="triangleCount">0</span></div>
            <div>È†ÇÈªû: <span id="vertexCount">0</span></div>
            <div>Áπ™Ë£ΩË™øÁî®: <span id="drawCalls">0</span></div>
        </div>

        <!-- ËÅäÂ§©Á≥ªÁµ± -->
        <div id="chatContainer" style="display: none;">
            <div id="chatMessages"></div>
            <div id="chatInput">
                <input type="text" id="messageInput" placeholder="ÊåâTÈñãÂßãËÅäÂ§©..." maxlength="100">
                <button id="sendMessage">ÁôºÈÄÅ</button>
            </div>
        </div>

        <!-- ÂÖ∂‰ªñÁé©ÂÆ∂ÂêçÁâå -->
        <div id="playerNameTags"></div>
    </div>
    <style>
        /* ÈÅ∏ÂñÆÊ®£Âºè */
        #pauseMenu,
        #multiplayerMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
        }

        .menu-container {
            background: rgba(20, 20, 20, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid #00ff88;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
            max-width: 500px;
            width: 90%;
        }

        .menu-container h2 {
            color: #00ff88;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menu-btn,
        .mode-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-btn:hover,
        .mode-btn:hover {
            background: linear-gradient(45deg, #00cc6a, #00ff88);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.6);
        }

        .game-modes {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .controls-info {
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .controls-info p {
            margin: 8px 0;
            color: #ccc;
        }

        /* ÈáçÊñ∞Ë®≠Ë®àÁöÑ‰∏ªÈÅ∏ÂñÆÊ®£Âºè */
        /* ‰∏ªÈÅ∏ÂñÆÂÆπÂô® */
        #instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .main-menu-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://github.com/LingTravel/mini-minecraft/blob/main/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202025-09-07%20044634.png') center/cover no-repeat;
            background-attachment: fixed;
            z-index: -2;
        }

        /* ÂãïÊÖãËÉåÊôØÂ±§ */
        .bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .bg-layer-1 {
            background: linear-gradient(45deg,
                    rgba(34, 139, 34, 0.4) 0%,
                    rgba(0, 100, 0, 0.3) 25%,
                    rgba(50, 205, 50, 0.4) 50%,
                    rgba(0, 128, 0, 0.3) 75%,
                    rgba(34, 139, 34, 0.4) 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease-in-out infinite;
        }

        .bg-layer-2 {
            background: radial-gradient(circle at 20% 80%,
                    rgba(135, 206, 235, 0.3) 0%,
                    transparent 50%),
                radial-gradient(circle at 80% 20%,
                    rgba(70, 130, 180, 0.3) 0%,
                    transparent 50%);
            animation: floatBubbles 20s ease-in-out infinite;
        }

        .bg-layer-3 {
            background:
                repeating-linear-gradient(45deg,
                    transparent,
                    transparent 50px,
                    rgba(255, 255, 255, 0.02) 50px,
                    rgba(255, 255, 255, 0.02) 100px);
            animation: slidePattern 25s linear infinite;
        }

        /* ËÉåÊôØÈÅÆÁΩ© */
        .bg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.7) 0%,
                    rgba(0, 20, 40, 0.8) 50%,
                    rgba(0, 0, 0, 0.9) 100%);
            z-index: 2;
        }

        /* ËÉåÊôØÂãïÁï´ */
        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes floatBubbles {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }

            33% {
                transform: translateY(-20px) rotate(120deg);
            }

            66% {
                transform: translateY(10px) rotate(240deg);
            }
        }

        @keyframes slidePattern {
            0% {
                transform: translateX(0px);
            }

            100% {
                transform: translateX(100px);
            }
        }

        /* ÂÖßÂÆπÂ±§ */
        .main-menu-content {
            position: relative;
            z-index: 3;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.85) 0%,
                    rgba(20, 20, 40, 0.9) 50%,
                    rgba(0, 0, 0, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 3px solid rgba(0, 255, 136, 0.4);
            border-radius: 25px;
            padding: 40px;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: menuSlideIn 1s ease-out, menuFloat 6s ease-in-out infinite 1s;
        }

        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes menuFloat {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* ÈÅäÊà≤Ê®ôÈ°å */
        .game-logo {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.3);
        }

        .game-logo h1 {
            font-size: 3.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff, #88ff00);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            animation: logoGlow 3s ease-in-out infinite alternate;
        }

        @keyframes logoGlow {
            from {
                background-position: 0% 50%;
                filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.8));
            }

            to {
                background-position: 100% 50%;
                filter: drop-shadow(0 0 40px rgba(0, 255, 136, 1));
            }
        }

        .subtitle {
            font-size: 1.3em;
            color: rgba(0, 255, 136, 0.8);
            margin: 10px 0 0 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        /* ÈÅ∏ÂñÆÂçÄÂ°ä */
        .menu-section {
            margin: 30px 0;
            padding: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .menu-section h2 {
            color: #00ff88;
            font-size: 1.8em;
            margin: 0 0 20px 0;
            text-align: center;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        /* ÈÅäÊà≤Ê®°ÂºèÊåâÈàï */
        .game-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .mode-btn {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.9));
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            gap: 20px;
            text-align: left;
            color: white;
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: #00ff88;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.2));
        }

        .mode-btn:active {
            transform: translateY(-2px) scale(0.98);
            transition: transform 0.1s ease;
        }

        .btn-icon {
            font-size: 3em;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
        }

        .btn-content {
            flex: 1;
        }

        .btn-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #00ff88;
        }

        .btn-desc {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 300;
        }

        /* ÊéßÂà∂Ë™™Êòé */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .control-category {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95em;
        }

        .control-item kbd {
            background: linear-gradient(135deg, #333, #555);
            color: #00ff88;
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            text-align: center;
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .control-item kbd:hover {
            background: linear-gradient(135deg, #444, #666);
            color: #00ffaa;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        /* ÈÅ∏ÂñÆÂ∫ïÈÉ® */
        .menu-footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 255, 136, 0.3);
        }

        .version-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .version-info span {
            color: rgba(0, 255, 136, 0.8);
            font-size: 0.9em;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            transition: all 0.3s ease;
        }

        .version-info span:hover {
            background: rgba(0, 255, 136, 0.1);
            transform: translateY(-2px);
        }

        /* ÈüøÊáâÂºèË®≠Ë®à */
        @media (max-width: 768px) {
            .main-menu-content {
                padding: 20px;
                margin: 10px;
            }

            .game-logo h1 {
                font-size: 2.5em;
            }

            .game-modes {
                grid-template-columns: 1fr;
            }

            .mode-btn {
                padding: 20px;
                gap: 15px;
            }

            .btn-icon {
                font-size: 2.5em;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .version-info {
                gap: 15px;
            }

            .version-info span {
                font-size: 0.8em;
                padding: 4px 12px;
            }
        }

        @media (max-width: 480px) {
            .game-logo h1 {
                font-size: 2em;
            }

            .mode-btn {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }

            .btn-icon {
                font-size: 2em;
            }
        }

        .main-menu-content {
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.85) 0%,
                    rgba(20, 20, 40, 0.9) 50%,
                    rgba(0, 0, 0, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 3px solid rgba(0, 255, 136, 0.4);
            border-radius: 25px;
            padding: 40px;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: menuSlideIn 1s ease-out;
        }

        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .game-logo {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.3);
        }

        .game-logo h1 {
            font-size: 3.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff, #88ff00);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            animation: logoGlow 3s ease-in-out infinite alternate;
        }

        @keyframes logoGlow {
            from {
                background-position: 0% 50%;
                filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.8));
            }

            to {
                background-position: 100% 50%;
                filter: drop-shadow(0 0 40px rgba(0, 255, 136, 1));
            }
        }

        .subtitle {
            font-size: 1.3em;
            color: rgba(0, 255, 136, 0.8);
            margin: 10px 0 0 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .menu-section {
            margin: 30px 0;
            padding: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .menu-section h2 {
            color: #00ff88;
            font-size: 1.8em;
            margin: 0 0 20px 0;
            text-align: center;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        .game-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .mode-btn {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.9));
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            gap: 20px;
            text-align: left;
            color: white;
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: #00ff88;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.2));
        }

        .mode-btn.primary:hover {
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(0, 255, 136, 0.6);
        }

        .mode-btn.secondary:hover {
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(0, 200, 255, 0.6);
        }

        .btn-icon {
            font-size: 3em;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
        }

        .btn-content {
            flex: 1;
        }

        .btn-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #00ff88;
        }

        .btn-desc {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 300;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .control-category {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95em;
        }

        .control-item kbd {
            background: linear-gradient(135deg, #333, #555);
            color: #00ff88;
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            text-align: center;
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .menu-footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 255, 136, 0.3);
        }

        .version-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .version-info span {
            color: rgba(0, 255, 136, 0.8);
            font-size: 0.9em;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        /* ÈüøÊáâÂºèË®≠Ë®à */
        @media (max-width: 768px) {
            .main-menu-content {
                padding: 20px;
                margin: 10px;
            }

            .game-logo h1 {
                font-size: 2.5em;
            }

            .game-modes {
                grid-template-columns: 1fr;
            }

            .mode-btn {
                padding: 20px;
                gap: 15px;
            }

            .btn-icon {
                font-size: 2.5em;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .version-info {
                gap: 15px;
            }

            .version-info span {
                font-size: 0.8em;
                padding: 4px 12px;
            }
        }

        @media (max-width: 480px) {
            .game-logo h1 {
                font-size: 2em;
            }

            .mode-btn {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }

            .btn-icon {
                font-size: 2em;
            }
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            }

            to {
                text-shadow: 0 0 30px rgba(0, 255, 136, 1), 0 0 40px rgba(0, 255, 136, 0.8);
            }
        }

        .game-modes {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .controls-info {
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .controls-info p {
            margin: 8px 0;
            color: #ccc;
            font-size: 14px;
        }

        /* Â§ö‰∫∫ÈÅäÊà≤‰ªãÈù¢ */
        .multiplayer-options {
            text-align: left;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            color: #00ff88;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 16px;
        }

        .input-group input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        #roomInfo {
            background: rgba(0, 255, 136, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid #00ff88;
        }

        #roomInfo h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        #playerList {
            margin-top: 15px;
        }

        .player-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #00ff88;
            color: white;
        }

        /* ËÅäÂ§©Á≥ªÁµ±Ê®£Âºè */
        #chatContainer {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 400px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        #chatMessages {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-size: 14px;
            color: white;
        }

        .chat-message {
            margin: 3px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .chat-message.system {
            color: #ffff00;
            font-style: italic;
        }

        .chat-message.player {
            color: #00ff88;
        }

        #chatInput {
            display: flex;
            padding: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }

        #messageInput {
            flex: 1;
            padding: 8px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            margin-right: 10px;
        }

        #sendMessage {
            padding: 8px 15px;
            background: #00ff88;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        /* Áé©ÂÆ∂ÂêçÁâåÊ®£Âºè */
        .player-nametag {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border: 1px solid #00ff88;
            pointer-events: none;
            z-index: 150;
            transform: translateX(-50%);
        }

        /* ÂÖ∂‰ªñÁé©ÂÆ∂ÊåáÁ§∫Âô® */
        .other-player {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 140;
        }

        /* FPSÂíåÂÖ∂‰ªñUIÂÖÉÁ¥†Ê®£ÂºèÊõ¥Êñ∞ */
        #fps {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 15px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 2em;
            z-index: 300;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            margin: 20px auto;
            overflow: hidden;
            border: 1px solid #00ff88;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '';
            }

            40% {
                content: '.';
            }

            60% {
                content: '..';
            }

            80%,
            100% {
                content: '...';
            }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 300;
            border: 2px solid #ff4444;
        }

        /* ÈüøÊáâÂºèË®≠Ë®à */
        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 10px;
                min-width: 200px;
            }

            .inventory-slot {
                width: 60px;
                height: 60px;
            }

            .inventory-slot .block-icon {
                font-size: 1.8em;
                margin-bottom: 2px;
            }

            .inventory-slot .block-name {
                font-size: 0.7em;
            }

            #inventory {
                bottom: 20px;
                padding: 15px;
                gap: 8px;
                flex-wrap: wrap;
                max-width: 90%;
            }

            .menu-container {
                padding: 20px;
                max-width: 90%;
            }

            .menu-container h2 {
                font-size: 2em;
            }

            #minimap {
                width: 120px;
                height: 120px;
            }

            #chatContainer {
                width: 300px;
                height: 150px;
                bottom: 100px;
            }

            #chatMessages {
                font-size: 12px;
                padding: 10px;
            }

            #messageInput {
                font-size: 12px;
                padding: 8px 12px;
            }
        }

        @media (max-width: 480px) {
            #inventory {
                flex-wrap: wrap;
                justify-content: center;
                max-height: 200px;
                overflow-y: auto;
            }

            .inventory-slot {
                width: 50px;
                height: 50px;
                margin: 2px;
            }

            .inventory-slot .block-icon {
                font-size: 1.5em;
            }

            .inventory-slot .block-name {
                font-size: 0.6em;
            }
        }

        /* ÈüøÊáâÂºèË®≠Ë®à */
        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 10px;
            }

            .inventory-slot {
                width: 60px;
                height: 60px;
            }

            .menu-container {
                padding: 20px;
                max-width: 90%;
            }

            .menu-container h2 {
                font-size: 2em;
            }

            #minimap {
                width: 120px;
                height: 120px;
            }

            #chatContainer {
                width: 300px;
                height: 150px;
            }

            .status-message {
                background: rgba(0, 255, 136, 0.1);
                border: 1px solid #00ff88;
                padding: 10px;
                border-radius: 5px;
                color: #00ff88;
                text-align: center;
                font-size: 14px;
            }

            .status-message.error {
                background: rgba(255, 0, 0, 0.1);
                border-color: #ff4444;
                color: #ff4444;
            }
        }
    </style>
    </head>

    <body>
        <script>
            // Firebase ÈÖçÁΩÆ (‰ΩøÁî®ÊºîÁ§∫ÈÖçÁΩÆÔºåÂØ¶Èöõ‰ΩøÁî®ÊôÇË´ãÂâµÂª∫Ëá™Â∑±ÁöÑFirebaseÈ†ÖÁõÆ)
            const firebaseConfig = {
                apiKey: "AIzaSyDFr6n0l_yc4UcyROw9pFbRRYeYOvAb2vc", // Ë´ãÊõøÊèõÁÇ∫‰Ω†ÁöÑÂØ¶ÈöõAPIÂØÜÈë∞
                authDomain: "mini-minecraft-c2d8e.firebaseapp.com",
                databaseURL: "https://mini-minecraft-c2d8e-default-rtdb.asia-southeast1.firebasedatabase.app/",
                projectId: "mini-minecraft-c2d8e",
                storageBucket: "mini-minecraft-c2d8e.appspot.com",
                messagingSenderId: "965733295205", // Ë´ãÊõøÊèõÁÇ∫‰Ω†ÁöÑÂØ¶ÈöõÁôºÈÄÅËÄÖID
                appId: "1:965733295205:web:cdaa7cb8b80cd1824e928c" // Ë´ãÊõøÊèõÁÇ∫‰Ω†ÁöÑÂØ¶ÈöõÊáâÁî®Á®ãÂºèID
            };

            let database = null;
            let firebaseAvailable = false;

            // ÂàùÂßãÂåñFirebase
            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                database = firebase.database();

                // Ê∏¨Ë©¶ÈÄ£Êé•
                database.ref('.info/connected').on('value', (snapshot) => {
                    firebaseAvailable = snapshot.val() === true;
                    console.log('FirebaseÈÄ£Êé•ÁãÄÊÖã:', firebaseAvailable ? 'Â∑≤ÈÄ£Êé•' : 'Â∑≤Êñ∑Èñã');

                    // Êõ¥Êñ∞UIÁãÄÊÖã
                    const statusElement = document.getElementById('firebaseStatus');
                    if (statusElement) {
                        statusElement.textContent = firebaseAvailable ? 'Â∑≤ÈÄ£Êé• (‰∫ûÊ¥≤)' : 'ÈÄ£Êé•‰∏≠...';
                        statusElement.style.color = firebaseAvailable ? '#00ff88' : '#ffaa00';
                    }
                });

                console.log('FirebaseÂàùÂßãÂåñÊàêÂäü (‰∫ûÊ¥≤Êù±ÂçóÂçÄÂüü)');
            } catch (error) {
                console.error('FirebaseÂàùÂßãÂåñÂ§±Êïó:', error);
                firebaseAvailable = false;

                // Êõ¥Êñ∞UIÈ°ØÁ§∫ÈåØË™§
                const statusElement = document.getElementById('firebaseStatus');
                if (statusElement) {
                    statusElement.textContent = 'ÈÄ£Êé•Â§±Êïó';
                    statusElement.style.color = '#ff4444';
                }
            }

            // Â§ö‰∫∫ÈÅäÊà≤Á∂≤Ë∑ØÁÆ°ÁêÜÈ°ûÂà•
            class FirebaseMultiplayerManager {
                constructor() {
                    this.isHost = false;
                    this.isConnected = false;
                    this.roomId = null;
                    this.playerId = null;
                    this.playerName = '';
                    this.otherPlayers = new Map();
                    this.callbacks = {
                        onPlayerJoin: null,
                        onPlayerLeave: null,
                        onPlayerMove: null,
                        onBlockUpdate: null,
                        onChatMessage: null,
                        onRoomUpdate: null
                    };

                    this.roomRef = null;
                    this.playersRef = null;
                    this.messagesRef = null;
                    this.blocksRef = null;
                    this.listeners = [];
                }

                setCallback(event, callback) {
                    this.callbacks[event] = callback;
                }

                async connectToRoom(roomId, playerName) {
                    return new Promise((resolve, reject) => {
                        try {
                            this.roomId = roomId || this.generateRoomId();
                            this.playerName = playerName || 'Player';
                            this.playerId = this.generatePlayerId();
                            this.isHost = !roomId;

                            // Ë®≠ÁΩÆFirebaseÂºïÁî®
                            this.roomRef = database.ref(`rooms/${this.roomId}`);
                            this.playersRef = this.roomRef.child('players');
                            this.messagesRef = this.roomRef.child('messages');
                            this.blocksRef = this.roomRef.child('blocks');

                            // Ê™¢Êü•ÊàøÈñìÊòØÂê¶Â≠òÂú®
                            this.roomRef.once('value')
                                .then((snapshot) => {
                                    const roomData = snapshot.val();

                                    if (!roomData && !this.isHost) {
                                        reject(new Error('ÊàøÈñì‰∏çÂ≠òÂú®'));
                                        return;
                                    }

                                    // ÂâµÂª∫ÊàñÂä†ÂÖ•ÊàøÈñì
                                    return this.joinRoom();
                                })
                                .then(() => {
                                    this.isConnected = true;
                                    this.setupListeners();

                                    console.log(`Â∑≤ÈÄ£Êé•Âà∞ÊàøÈñì: ${this.roomId}, Áé©ÂÆ∂ID: ${this.playerId}`);

                                    resolve({
                                        roomId: this.roomId,
                                        playerId: this.playerId,
                                        isHost: this.isHost,
                                        success: true
                                    });
                                })
                                .catch(reject);

                        } catch (error) {
                            reject(error);
                        }
                    });
                }

                async joinRoom() {
                    // Ê∑ªÂä†Áé©ÂÆ∂Âà∞ÊàøÈñì
                    const playerData = {
                        id: this.playerId,
                        name: this.playerName,
                        x: Math.random() * 20 - 10,
                        y: 10,
                        z: Math.random() * 20 - 10,
                        angle: 0,
                        pitch: 0,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP,
                        isHost: this.isHost,
                        online: true
                    };

                    await this.playersRef.child(this.playerId).set(playerData);

                    // Ë®≠ÁΩÆÈõ¢Á∑öÊôÇËá™ÂãïÁßªÈô§
                    this.playersRef.child(this.playerId).onDisconnect().remove();

                    // Â¶ÇÊûúÊòØ‰∏ªÊ©üÔºåÂàùÂßãÂåñÊàøÈñìÊï∏Êìö
                    if (this.isHost) {
                        await this.roomRef.update({
                            created: firebase.database.ServerValue.TIMESTAMP,
                            host: this.playerId
                        });
                    }
                }

                setupListeners() {
                    // Áõ£ËÅΩÁé©ÂÆ∂Âä†ÂÖ•/Èõ¢Èñã
                    const playersListener = this.playersRef.on('child_added', (snapshot) => {
                        const player = snapshot.val();
                        if (player.id !== this.playerId) {
                            this.otherPlayers.set(player.id, player);
                            if (this.callbacks.onPlayerJoin) {
                                this.callbacks.onPlayerJoin(player);
                            }
                            this.updateRoomInfo();
                        }
                    });

                    const playersRemovedListener = this.playersRef.on('child_removed', (snapshot) => {
                        const player = snapshot.val();
                        if (player.id !== this.playerId) {
                            this.otherPlayers.delete(player.id);
                            if (this.callbacks.onPlayerLeave) {
                                this.callbacks.onPlayerLeave(player);
                            }
                            this.updateRoomInfo();
                        }
                    });

                    // Áõ£ËÅΩÁé©ÂÆ∂‰ΩçÁΩÆÊõ¥Êñ∞
                    const playersChangedListener = this.playersRef.on('child_changed', (snapshot) => {
                        const player = snapshot.val();
                        if (player.id !== this.playerId) {
                            this.otherPlayers.set(player.id, player);
                            if (this.callbacks.onPlayerMove) {
                                this.callbacks.onPlayerMove({
                                    type: 'playerUpdate',
                                    playerId: player.id,
                                    playerName: player.name,
                                    x: player.x,
                                    y: player.y,
                                    z: player.z,
                                    angle: player.angle,
                                    pitch: player.pitch
                                });
                            }
                        }
                    });

                    // Áõ£ËÅΩËÅäÂ§©Ë®äÊÅØ
                    const messagesListener = this.messagesRef.limitToLast(1).on('child_added', (snapshot) => {
                        const message = snapshot.val();
                        if (message.playerId !== this.playerId) {
                            if (this.callbacks.onChatMessage) {
                                this.callbacks.onChatMessage(message);
                            }
                        }
                    });

                    // Áõ£ËÅΩÊñπÂ°äÊõ¥Êñ∞
                    const blocksListener = this.blocksRef.limitToLast(1).on('child_added', (snapshot) => {
                        const blockUpdate = snapshot.val();
                        if (blockUpdate.playerId !== this.playerId) {
                            if (this.callbacks.onBlockUpdate) {
                                this.callbacks.onBlockUpdate(blockUpdate);
                            }
                        }
                    });

                    // ‰øùÂ≠òÁõ£ËÅΩÂô®ÂºïÁî®‰ª•‰æøÊ∏ÖÁêÜ
                    this.listeners = [
                        { ref: this.playersRef, event: 'child_added', listener: playersListener },
                        { ref: this.playersRef, event: 'child_removed', listener: playersRemovedListener },
                        { ref: this.playersRef, event: 'child_changed', listener: playersChangedListener },
                        { ref: this.messagesRef, event: 'child_added', listener: messagesListener },
                        { ref: this.blocksRef, event: 'child_added', listener: blocksListener }
                    ];
                }

                sendPlayerUpdate(playerData) {
                    if (!this.isConnected) return;

                    this.playersRef.child(this.playerId).update({
                        x: playerData.x,
                        y: playerData.y,
                        z: playerData.z,
                        angle: playerData.angle,
                        pitch: playerData.pitch,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    }).catch(error => {
                        console.error('ÁôºÈÄÅÁé©ÂÆ∂Êõ¥Êñ∞Â§±Êïó:', error);
                    });
                }

                sendBlockUpdate(x, y, z, blockType, action) {
                    if (!this.isConnected) return;

                    const blockData = {
                        type: 'blockUpdate',
                        playerId: this.playerId,
                        x: x, y: y, z: z,
                        blockType: blockType,
                        action: action,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    };

                    this.blocksRef.push(blockData).catch(error => {
                        console.error('ÁôºÈÄÅÊñπÂ°äÊõ¥Êñ∞Â§±Êïó:', error);
                    });
                }

                sendChatMessage(message) {
                    if (!this.isConnected || !message.trim()) return;

                    const chatData = {
                        type: 'chatMessage',
                        playerId: this.playerId,
                        playerName: this.playerName,
                        message: message.trim(),
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    };

                    this.messagesRef.push(chatData).catch(error => {
                        console.error('ÁôºÈÄÅËÅäÂ§©Ë®äÊÅØÂ§±Êïó:', error);
                    });
                }

                updateRoomInfo() {
                    if (this.callbacks.onRoomUpdate) {
                        const allPlayers = [
                            {
                                id: this.playerId,
                                name: this.playerName,
                                isHost: this.isHost
                            },
                            ...Array.from(this.otherPlayers.values())
                        ];

                        this.callbacks.onRoomUpdate({
                            roomId: this.roomId,
                            players: allPlayers
                        });
                    }
                }

                disconnect() {
                    // Ê∏ÖÁêÜÊâÄÊúâÁõ£ËÅΩÂô®
                    this.listeners.forEach(({ ref, event, listener }) => {
                        ref.off(event, listener);
                    });
                    this.listeners = [];

                    // ÁßªÈô§Áé©ÂÆ∂Êï∏Êìö
                    if (this.playersRef && this.playerId) {
                        this.playersRef.child(this.playerId).remove();
                    }

                    this.otherPlayers.clear();
                    this.isConnected = false;
                    console.log('Â∑≤Êñ∑ÈñãFirebaseÈÄ£Êé•');
                }

                getOtherPlayers() {
                    return Array.from(this.otherPlayers.values());
                }

                getConnectionStatus() {
                    return {
                        isConnected: this.isConnected,
                        roomId: this.roomId,
                        playerId: this.playerId,
                        playerName: this.playerName,
                        playerCount: this.otherPlayers.size + 1,
                        isHost: this.isHost
                    };
                }

                generateRoomId() {
                    return Math.random().toString(36).substr(2, 6).toUpperCase();
                }

                generatePlayerId() {
                    return 'player_' + Math.random().toString(36).substr(2, 9);
                }
            }

            // ËÅäÂ§©Á≥ªÁµ±È°ûÂà•
            class ChatSystem {
                constructor() {
                    this.messages = [];
                    this.maxMessages = 50;
                    this.isVisible = false;
                    this.isInputActive = false;
                }

                // È°ØÁ§∫ËÅäÂ§©‰ªãÈù¢
                show() {
                    this.isVisible = true;
                    document.getElementById('chatContainer').style.display = 'flex';
                }

                // Èö±ËóèËÅäÂ§©‰ªãÈù¢
                hide() {
                    this.isVisible = false;
                    this.isInputActive = false;
                    document.getElementById('chatContainer').style.display = 'none';
                    document.getElementById('messageInput').blur();
                }

                // ÂàáÊèõËÅäÂ§©‰ªãÈù¢
                toggle() {
                    if (this.isVisible) {
                        this.hide();
                    } else {
                        this.show();
                    }
                }

                // ÊøÄÊ¥ªËº∏ÂÖ•Ê°Ü
                activateInput() {
                    this.show();
                    this.isInputActive = true;
                    const input = document.getElementById('messageInput');
                    input.focus();
                    input.placeholder = 'Ëº∏ÂÖ•Ë®äÊÅØ...';
                }

                // Ê∑ªÂä†Ë®äÊÅØ
                addMessage(playerName, message, type = 'player') {
                    const messageObj = {
                        playerName: playerName,
                        message: message,
                        type: type,
                        timestamp: Date.now()
                    };

                    this.messages.push(messageObj);

                    // ÈôêÂà∂Ë®äÊÅØÊï∏Èáè
                    if (this.messages.length > this.maxMessages) {
                        this.messages.shift();
                    }

                    this.updateDisplay();
                }

                // Ê∑ªÂä†Á≥ªÁµ±Ë®äÊÅØ
                addSystemMessage(message) {
                    this.addMessage('Á≥ªÁµ±', message, 'system');
                }

                // Êõ¥Êñ∞È°ØÁ§∫
                updateDisplay() {
                    const container = document.getElementById('chatMessages');
                    container.innerHTML = '';

                    this.messages.forEach(msg => {
                        const messageDiv = document.createElement('div');
                        messageDiv.className = `chat-message ${msg.type}`;

                        if (msg.type === 'system') {
                            messageDiv.textContent = `[Á≥ªÁµ±] ${msg.message}`;
                        } else {
                            messageDiv.innerHTML = `<strong>${msg.playerName}:</strong> ${msg.message}`;
                        }

                        container.appendChild(messageDiv);
                    });

                    // ÊªæÂãïÂà∞Â∫ïÈÉ®
                    container.scrollTop = container.scrollHeight;
                }

                // ÁôºÈÄÅË®äÊÅØ
                sendMessage(message, multiplayerManager) {
                    if (!message.trim()) return false;

                    if (multiplayerManager && multiplayerManager.isConnected) {
                        multiplayerManager.sendChatMessage(message);
                    } else {
                        // ÂñÆ‰∫∫Ê®°Âºè‰∏ãÁõ¥Êé•Ê∑ªÂä†Ë®äÊÅØ
                        this.addMessage('‰Ω†', message);
                    }

                    return true;
                }
            }

            // WebGL Minecraft ‰∏ªÈÅäÊà≤È°ûÂà•
            class WebGLMinecraft {
                constructor() {
                    this.canvas = document.getElementById('gameCanvas');
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;

                    // ÂàùÂßãÂåñWebGL
                    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                    if (!this.gl) {
                        this.showError('ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥WebGLÔºÅ');
                        return;
                    }

                    // Â∞èÂú∞ÂúñCanvas
                    this.minimapCanvas = document.getElementById('minimap');
                    this.minimapCtx = this.minimapCanvas.getContext('2d');
                    this.minimapCanvas.width = 180;
                    this.minimapCanvas.height = 180;

                    // Â§ö‰∫∫ÈÅäÊà≤ÂíåËÅäÂ§©Á≥ªÁµ±
                    this.multiplayerManager = new FirebaseMultiplayerManager();
                    this.chatSystem = new ChatSystem();
                    this.isMultiplayer = false;

                    // ÊÄßËÉΩË®àÊï∏Âô®
                    this.frameCount = 0;
                    this.lastFrameTime = 0;
                    this.fps = 60;
                    this.triangleCount = 0;
                    this.vertexCount = 0;
                    this.drawCalls = 0;

                    // ÈÅäÊà≤ÁãÄÊÖã
                    this.gameStarted = false;
                    this.worldGenerated = false;
                    this.flying = false;
                    this.isPaused = false;

                    // Áé©ÂÆ∂
                    this.player = {
                        x: 0, y: 10, z: 0,
                        angle: 0, pitch: 0,
                        velocity: { x: 0, y: 0, z: 0 },
                        onGround: false
                    };

                    // ÂÖ∂‰ªñÁé©ÂÆ∂Ê∏≤ÊüìÊï∏Êìö
                    this.otherPlayers = new Map();

                    // ‰∏ñÁïåË®≠ÂÆö
                    this.world = new Map();
                    this.worldSize = 64;
                    this.renderDistance = 24;
                    this.gravity = -0.02;
                    this.jumpPower = 0.4;

                    // ÊñπÂ°äÈ°ûÂûã
                    // Êì¥Â±ïÁöÑÊñπÂ°äÈ°ûÂûãÁ≥ªÁµ±
                    this.blockTypes = {
                        grass: {
                            colors: {
                                top: [0.3, 0.8, 0.2],
                                side: [0.4, 0.5, 0.2],
                                bottom: [0.3, 0.2, 0.1]
                            },
                            id: 1,
                            name: 'ËçâÂú∞',
                            icon: 'üü©'
                        },
                        stone: {
                            colors: {
                                top: [0.8, 0.8, 0.8],
                                side: [0.6, 0.6, 0.6],
                                bottom: [0.4, 0.4, 0.4]
                            },
                            id: 2,
                            name: 'Áü≥È†≠',
                            icon: '‚¨ú'
                        },
                        wood: {
                            colors: {
                                top: [0.7, 0.5, 0.2],
                                side: [0.4, 0.2, 0.1],
                                bottom: [0.7, 0.5, 0.2]
                            },
                            id: 3,
                            name: 'Êú®È†≠',
                            icon: 'üü´'
                        },
                        water: {
                            colors: {
                                top: [0.3, 0.6, 1.0],
                                side: [0.2, 0.5, 0.9],
                                bottom: [0.1, 0.4, 0.8]
                            },
                            id: 4,
                            transparent: true,
                            alpha: 0.6,  // 60%‰∏çÈÄèÊòé = 40%ÈÄèÊòé
                            name: 'Ê∞¥',
                            icon: 'üü¶'
                        },
                        sand: {
                            colors: {
                                top: [0.9, 0.8, 0.4],
                                side: [0.8, 0.7, 0.3],
                                bottom: [0.7, 0.6, 0.2]
                            },
                            id: 5,
                            name: 'Ê≤ôÂ≠ê',
                            icon: 'üü®'
                        },
                        snow: {
                            colors: {
                                top: [0.95, 0.95, 1.0],
                                side: [0.9, 0.9, 0.95],
                                bottom: [0.85, 0.85, 0.9]
                            },
                            id: 6,
                            name: 'Èõ™',
                            icon: '‚ùÑÔ∏è'
                        },
                        leaves: {
                            colors: {
                                top: [0.2, 0.7, 0.2],
                                side: [0.1, 0.6, 0.1],
                                bottom: [0.15, 0.5, 0.15]
                            },
                            id: 7,
                            name: 'Ê®πËëâ',
                            icon: 'üü¢'
                        },
                        cobblestone: {
                            colors: {
                                top: [0.5, 0.5, 0.5],
                                side: [0.4, 0.4, 0.4],
                                bottom: [0.3, 0.3, 0.3]
                            },
                            id: 8,
                            name: 'ÈµùÂçµÁü≥',
                            icon: 'üîò'
                        },
                        brick: {
                            colors: {
                                top: [0.8, 0.3, 0.2],
                                side: [0.7, 0.2, 0.1],
                                bottom: [0.6, 0.1, 0.0]
                            },
                            id: 9,
                            name: 'Á£öÂ°ä',
                            icon: 'üß±'
                        },
                        glass: {
                            colors: {
                                top: [0.8, 0.9, 1.0],
                                side: [0.7, 0.8, 0.9],
                                bottom: [0.6, 0.7, 0.8]
                            },
                            id: 10,
                            transparent: true,
                            alpha: 0.8,  // 80%‰∏çÈÄèÊòé = 20%ÈÄèÊòé
                            name: 'ÁéªÁíÉ',
                            icon: 'üî∑'
                        }
                    };

                    this.selectedBlock = 'grass';
                    this.keys = {};
                    this.mouse = { locked: false };

                    // WebGLË≥áÊ∫ê
                    this.shaderProgram = null;
                    this.buffers = {};
                    this.uniforms = {};
                    this.attributes = {};

                    // Ê∏≤ÊüìÊï∏Êìö
                    this.vertices = [];
                    this.indices = [];
                    this.colors = [];
                    this.normals = [];
                    this.chunkMeshes = new Map();

                    // Áü©Èô£
                    this.projectionMatrix = this.createMat4();
                    this.viewMatrix = this.createMat4();
                    this.modelMatrix = this.createMat4();

                    // Ë®≠ÂÆöÂ§ö‰∫∫ÈÅäÊà≤ÂõûË™ø
                    this.setupMultiplayerCallbacks();
                    this.showMainMenu();
                    this.initializeWebGL();
                }

                showMainMenu() {
                    // È°ØÁ§∫‰∏ªÈÅ∏ÂñÆÂíåËÉåÊôØ
                    const instructionsElement = document.getElementById('instructions');
                    instructionsElement.style.display = 'flex';
                    instructionsElement.style.opacity = '0';

                    // Ê∑°ÂÖ•ÂãïÁï´
                    setTimeout(() => {
                        instructionsElement.style.transition = 'opacity 0.5s ease';
                        instructionsElement.style.opacity = '1';
                    }, 50);

                    // Èö±ËóèÂÖ∂‰ªñ‰ªãÈù¢
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('chatContainer').style.display = 'none';

                    console.log('‰∏ªÈÅ∏ÂñÆÂ∑≤È°ØÁ§∫');
                }

                // ÂïüÂãïÂ§ö‰∫∫ÈÅäÊà≤
                startMultiplayerGame() {
                    if (!this.worldGenerated) {
                        alert('‰∏ñÁïåÈÇÑÂú®ÁîüÊàê‰∏≠ÔºåË´ãÁ®çÂÄô...');
                        return;
                    }

                    if (!this.multiplayerManager.isConnected) {
                        alert('Â∞öÊú™ÈÄ£Êé•Âà∞ÊàøÈñìÔºåË´ãÂÖàÂâµÂª∫ÊàñÂä†ÂÖ•ÊàøÈñì');
                        return;
                    }

                    this.isMultiplayer = true;
                    this.gameStarted = true;
                    this.isPaused = false;

                    // Èö±ËóèÊâÄÊúâÈÅ∏ÂñÆ
                    document.getElementById('instructions').style.display = 'none';
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';

                    // Â∞áÁé©ÂÆ∂ÊîæÁΩÆÂú®ÂÆâÂÖ®‰ΩçÁΩÆ
                    this.player.x = Math.random() * 10 - 5; // Èö®Ê©ü‰ΩçÁΩÆÈÅøÂÖçÈáçÁñä
                    this.player.z = Math.random() * 10 - 5;
                    this.player.y = Math.max(5, this.getHighestBlock(this.player.x, this.player.z) + 3);

                    // È°ØÁ§∫ËÅäÂ§©Á≥ªÁµ±
                    this.chatSystem.show();
                    this.chatSystem.addSystemMessage('Â§ö‰∫∫ÈÅäÊà≤ÈñãÂßãÔºÅÊåâTÈçµËÅäÂ§©');
                    this.chatSystem.addSystemMessage(`‰Ω†ÁöÑ‰ΩçÁΩÆ: (${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)})`);

                    console.log(`Â§ö‰∫∫ÈÅäÊà≤Â∑≤ÂïüÂãïÔºÅÁé©ÂÆ∂‰ΩçÁΩÆ: (${this.player.x}, ${this.player.y}, ${this.player.z})`);
                    console.log(`ÊàøÈñìID: ${this.multiplayerManager.roomId}`);
                }

                // Ë®≠ÂÆöÂ§ö‰∫∫ÈÅäÊà≤ÂõûË™øÂáΩÊï∏
                setupMultiplayerCallbacks() {
                    this.multiplayerManager.setCallback('onPlayerJoin', (player) => {
                        this.chatSystem.addSystemMessage(`${player.name} Âä†ÂÖ•‰∫ÜÈÅäÊà≤`);
                        this.otherPlayers.set(player.id, player);
                        this.updateConnectionUI();
                    });

                    this.multiplayerManager.setCallback('onPlayerLeave', (player) => {
                        this.chatSystem.addSystemMessage(`${player.name} Èõ¢Èñã‰∫ÜÈÅäÊà≤`);
                        this.otherPlayers.delete(player.id);
                        this.updateConnectionUI();
                    });

                    this.multiplayerManager.setCallback('onPlayerMove', (data) => {
                        if (data.playerId !== this.multiplayerManager.playerId) {
                            this.otherPlayers.set(data.playerId, {
                                id: data.playerId,
                                name: data.playerName,
                                x: data.x,
                                y: data.y,
                                z: data.z,
                                angle: data.angle,
                                pitch: data.pitch
                            });
                        }
                    });

                    this.multiplayerManager.setCallback('onBlockUpdate', (data) => {
                        if (data.action === 'place') {
                            this.setBlock(data.x, data.y, data.z, data.blockType);
                            this.chatSystem.addSystemMessage(`${this.getPlayerName(data.playerId)} ÊîæÁΩÆ‰∫ÜÊñπÂ°ä`);
                        } else if (data.action === 'break') {
                            this.removeBlock(data.x, data.y, data.z);
                            this.chatSystem.addSystemMessage(`${this.getPlayerName(data.playerId)} Á†¥Â£û‰∫ÜÊñπÂ°ä`);
                        }
                        this.regenerateNearbyChunks(data.x, data.y, data.z);
                    });

                    this.multiplayerManager.setCallback('onChatMessage', (data) => {
                        this.chatSystem.addMessage(data.playerName, data.message);
                    });

                    this.multiplayerManager.setCallback('onRoomUpdate', (data) => {
                        this.updateRoomInfo(data);
                    });
                }

                // Áç≤ÂèñÁé©ÂÆ∂ÂêçÁ®±
                getPlayerName(playerId) {
                    if (playerId === this.multiplayerManager.playerId) {
                        return '‰Ω†';
                    }
                    const player = this.otherPlayers.get(playerId);
                    return player ? player.name : 'Êú™Áü•Áé©ÂÆ∂';
                }

                // Êõ¥Êñ∞ÈÄ£Á∑öUI
                updateConnectionUI() {
                    const status = this.multiplayerManager.getConnectionStatus();
                    document.getElementById('connectionStatus').textContent =
                        status.isConnected ? `ÊàøÈñì ${status.roomId}` : 'Èõ¢Á∑ö';
                    document.getElementById('playerCount').textContent = status.playerCount;
                    document.getElementById('firebaseStatus').textContent =
                        status.isConnected ? 'Â∑≤ÈÄ£Êé•' : 'Èõ¢Á∑ö';
                }

                // Êõ¥Êñ∞ÊàøÈñìË≥áË®ä
                updateRoomInfo(data) {
                    document.getElementById('currentRoomId').textContent = data.roomId;
                    document.getElementById('roomPlayerCount').textContent = data.players.length;

                    const playerList = document.getElementById('playerList');
                    playerList.innerHTML = '';

                    data.players.forEach(player => {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'player-item';
                        playerDiv.textContent = `${player.name} ${player.isHost ? '(‰∏ªÊ©ü)' : ''}`;
                        playerList.appendChild(playerDiv);
                    });

                    // Êõ¥Êñ∞ÈñãÂßãÈÅäÊà≤ÊåâÈàïÁãÄÊÖã
                    const startButton = document.getElementById('startGameButton');
                    if (startButton) {
                        startButton.textContent = this.gameStarted ? 'üéÆ ËøîÂõûÈÅäÊà≤' : 'üéÆ ÈñãÂßãÈÅäÊà≤';
                    }
                }

                // Á∞°ÂåñÁöÑ4x4Áü©Èô£ÂâµÂª∫
                createMat4() {
                    return new Float32Array(16);
                }

                // ÈÄèË¶ñÊäïÂΩ±Áü©Èô£
                perspective(out, fovy, aspect, near, far) {
                    const f = 1.0 / Math.tan(fovy / 2);
                    out[0] = f / aspect;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = f;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[10] = (far + near) / (near - far);
                    out[11] = -1;
                    out[12] = 0;
                    out[13] = 0;
                    out[14] = (2 * far * near) / (near - far);
                    out[15] = 0;
                }

                // Ë¶ñÂúñÁü©Èô£
                lookAt(out, eye, center, up) {
                    const eyex = eye[0], eyey = eye[1], eyez = eye[2];
                    const centerx = center[0], centery = center[1], centerz = center[2];
                    const upx = up[0], upy = up[1], upz = up[2];

                    const z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz;
                    let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                    const nz0 = z0 * len, nz1 = z1 * len, nz2 = z2 * len;

                    const x0 = upy * nz2 - upz * nz1;
                    const x1 = upz * nz0 - upx * nz2;
                    const x2 = upx * nz1 - upy * nz0;
                    len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                    const nx0 = x0 * len, nx1 = x1 * len, nx2 = x2 * len;

                    const y0 = nz1 * nx2 - nz2 * nx1;
                    const y1 = nz2 * nx0 - nz0 * nx2;
                    const y2 = nz0 * nx1 - nz1 * nx0;

                    out[0] = nx0; out[1] = y0; out[2] = nz0; out[3] = 0;
                    out[4] = nx1; out[5] = y1; out[6] = nz1; out[7] = 0;
                    out[8] = nx2; out[9] = y2; out[10] = nz2; out[11] = 0;
                    out[12] = -(nx0 * eyex + nx1 * eyey + nx2 * eyez);
                    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                    out[14] = -(nz0 * eyex + nz1 * eyey + nz2 * eyez);
                    out[15] = 1;
                }

                // ÂñÆ‰ΩçÁü©Èô£
                identity(out) {
                    out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                    out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                    out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                    out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                }

                async initializeWebGL() {
                    try {
                        this.showLoading();
                        await this.setupShaders();
                        this.setupBuffers();
                        this.setupMatrices();
                        this.setupEventListeners();
                        await this.generateWorld();
                        this.hideLoading();
                        this.gameLoop();
                    } catch (error) {
                        this.showError('WebGLÂàùÂßãÂåñÂ§±Êïó: ' + error.message);
                    }
                }

                async setupShaders() {
                    // È†ÇÈªûËëóËâ≤Âô®
                    const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        attribute vec3 aNormal;
        attribute float aAlpha;
        
        uniform mat4 uProjectionMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uModelMatrix;
        uniform vec3 uLightDirection;
        uniform vec3 uAmbientLight;
        
        varying vec3 vColor;
        varying float vLighting;
        varying float vAlpha;
        
        void main() {
            vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
            gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
            
            // Ë®àÁÆóÂÖâÁÖß
            vec3 normal = normalize((uModelMatrix * vec4(aNormal, 0.0)).xyz);
            float directional = max(dot(normal, normalize(uLightDirection)), 0.0);
            vLighting = uAmbientLight.x + directional * 0.7;
            
            vColor = aColor;
            vAlpha = aAlpha;
        }
    `;

                    // ÁâáÊÆµËëóËâ≤Âô®
                    const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vColor;
        varying float vLighting;
        varying float vAlpha;
        
        void main() {
            // Ê∑ªÂä†Áí∞Â¢ÉÂÖâÂíåÊº´ÂèçÂ∞ÑÂÖâÁÖß
            vec3 ambient = vColor * 0.3;
            vec3 diffuse = vColor * vLighting * 0.7;
            vec3 finalColor = ambient + diffuse;
            
            // Ê∑ªÂä†ËºïÂæÆÁöÑÈúßÊïàÊûú
            float fogFactor = clamp(gl_FragCoord.z * 2.0, 0.0, 1.0);
            vec3 fogColor = vec3(0.7, 0.8, 0.9);
            finalColor = mix(finalColor, fogColor, fogFactor * 0.3);
            
            gl_FragColor = vec4(finalColor, vAlpha);
        }
    `;

                    // Á∑®Ë≠ØËëóËâ≤Âô®
                    const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                    const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

                    // ÂâµÂª∫Á®ãÂ∫è
                    this.shaderProgram = this.gl.createProgram();
                    this.gl.attachShader(this.shaderProgram, vertexShader);
                    this.gl.attachShader(this.shaderProgram, fragmentShader);
                    this.gl.linkProgram(this.shaderProgram);

                    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
                        throw new Error('ËëóËâ≤Âô®Á®ãÂ∫èÈèàÊé•Â§±Êïó: ' + this.gl.getProgramInfoLog(this.shaderProgram));
                    }

                    this.gl.useProgram(this.shaderProgram);

                    // Áç≤ÂèñÂ±¨ÊÄßÂíåÁµ±‰∏ÄËÆäÈáè‰ΩçÁΩÆ
                    this.attributes = {
                        position: this.gl.getAttribLocation(this.shaderProgram, 'aPosition'),
                        color: this.gl.getAttribLocation(this.shaderProgram, 'aColor'),
                        normal: this.gl.getAttribLocation(this.shaderProgram, 'aNormal'),
                        alpha: this.gl.getAttribLocation(this.shaderProgram, 'aAlpha')
                    };

                    this.uniforms = {
                        projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                        viewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uViewMatrix'),
                        modelMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelMatrix'),
                        lightDirection: this.gl.getUniformLocation(this.shaderProgram, 'uLightDirection'),
                        ambientLight: this.gl.getUniformLocation(this.shaderProgram, 'uAmbientLight')
                    };
                }

                compileShader(source, type) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);

                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        const error = this.gl.getShaderInfoLog(shader);
                        this.gl.deleteShader(shader);
                        throw new Error('ËëóËâ≤Âô®Á∑®Ë≠ØÂ§±Êïó: ' + error);
                    }

                    return shader;
                }

                setupBuffers() {
                    // È†ÇÈªûÁ∑©Ë°ùÂçÄ
                    this.buffers.position = this.gl.createBuffer();
                    this.buffers.color = this.gl.createBuffer();
                    this.buffers.normal = this.gl.createBuffer();
                    this.buffers.alpha = this.gl.createBuffer();  // Ê∑ªÂä†alphaÁ∑©Ë°ùÂçÄ
                    this.buffers.index = this.gl.createBuffer();
                }

                setupMatrices() {
                    // ÊäïÂΩ±Áü©Èô£
                    const aspect = this.canvas.width / this.canvas.height;
                    this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);

                    // Ë®≠ÁΩÆWebGLÁãÄÊÖã
                    this.gl.enable(this.gl.DEPTH_TEST);
                    this.gl.depthFunc(this.gl.LESS);
                    this.gl.depthMask(true);

                    // Èù¢ÂâîÈô§Ë®≠ÁΩÆ
                    this.gl.enable(this.gl.CULL_FACE);
                    this.gl.cullFace(this.gl.BACK);
                    this.gl.frontFace(this.gl.CCW);

                    // Ê∑∑ÂêàÊ®°ÂºèË®≠ÁΩÆÔºàÈ†êË®≠Á¶ÅÁî®ÔºåÊ∏≤ÊüìÊôÇÂïüÁî®Ôºâ
                    this.gl.disable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                    // Ë®≠ÁΩÆÊ∏ÖÁ©∫ÂÄº
                    this.gl.clearColor(0.5, 0.7, 1.0, 1.0);
                    this.gl.clearDepth(1.0);

                    // Ë®≠ÁΩÆË¶ñÂè£
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }

                // Èõ¢ÈñãÊàøÈñì
                leaveRoom() {
                    if (this.multiplayerManager.isConnected) {
                        this.multiplayerManager.disconnect();
                        this.chatSystem.addSystemMessage('Â∑≤Èõ¢ÈñãÊàøÈñì');
                    }

                    this.isMultiplayer = false;
                    document.getElementById('roomInfo').style.display = 'none';
                    document.getElementById('roomId').value = '';
                    this.updateConnectionUI();

                    // Ê∏ÖÈô§ÂÖ∂‰ªñÁé©ÂÆ∂
                    this.otherPlayers.clear();

                    // Ê∏ÖÈô§Áé©ÂÆ∂ÂêçÁâå
                    document.getElementById('playerNameTags').innerHTML = '';
                }

                showLoading() {
                    document.getElementById('loading').style.display = 'block';
                }

                hideLoading() {
                    document.getElementById('loading').style.display = 'none';
                }

                showError(message) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.innerHTML = `
            <h3>‚ùå ÈåØË™§</h3>
            <p>${message}</p>
            <button onclick="location.reload()">ÈáçÊñ∞ËºâÂÖ•</button>
        `;
                    document.body.appendChild(errorDiv);
                }

                // Êö´ÂÅú/ÊÅ¢Âæ©ÈÅäÊà≤
                pauseGame() {
                    this.isPaused = true;
                    document.getElementById('pauseMenu').style.display = 'flex';
                    if (this.mouse.locked) {
                        document.exitPointerLock();
                    }
                }

                resumeGame() {
                    this.isPaused = false;
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    if (this.gameStarted) {
                        this.canvas.requestPointerLock();
                    }
                }

                // È°ØÁ§∫Â§ö‰∫∫ÈÅäÊà≤ÈÅ∏ÂñÆ
                showMultiplayerMenu() {
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'flex';

                    // Ë®≠ÂÆöÈ†êË®≠Áé©ÂÆ∂ÂêçÁ®±
                    const playerNameInput = document.getElementById('playerName');
                    if (!playerNameInput.value) {
                        playerNameInput.value = 'Player' + Math.floor(Math.random() * 1000);
                    }
                }

                // ËøîÂõû‰∏ªÈÅ∏ÂñÆ
                returnToMainMenu() {
                    this.gameStarted = false;
                    this.isPaused = false;
                    this.isMultiplayer = false;

                    // Êñ∑ÈñãÂ§ö‰∫∫ÈÄ£Êé•
                    if (this.multiplayerManager.isConnected) {
                        this.multiplayerManager.disconnect();
                    }

                    // Èö±ËóèÊâÄÊúâÈÅäÊà≤ÈÅ∏ÂñÆ
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';

                    // È°ØÁ§∫‰∏ªÈÅ∏ÂñÆÔºàÂ∏∂ËÉåÊôØÔºâ
                    this.showMainMenu();

                    // Èö±ËóèËÅäÂ§©
                    this.chatSystem.hide();

                    // ÈáãÊîæÊªëÈº†ÈéñÂÆö
                    if (this.mouse.locked) {
                        document.exitPointerLock();
                    }

                    // ÈáçÁΩÆÁé©ÂÆ∂‰ΩçÁΩÆ
                    this.player = {
                        x: 0, y: 10, z: 0,
                        angle: 0, pitch: 0,
                        velocity: { x: 0, y: 0, z: 0 },
                        onGround: false
                    };

                    this.otherPlayers.clear();
                    this.updateConnectionUI();

                    console.log('Â∑≤ËøîÂõû‰∏ªÈÅ∏ÂñÆ');
                }

                // Âä†ÂÖ•ÊàøÈñì
                // Âä†ÂÖ•ÊàøÈñì
                async joinRoom() {
                    const playerName = document.getElementById('playerName').value.trim();
                    const roomId = document.getElementById('roomId').value.trim();

                    if (!playerName) {
                        alert('Ë´ãËº∏ÂÖ•Áé©ÂÆ∂ÂêçÁ®±');
                        return;
                    }

                    if (!roomId) {
                        alert('Ë´ãËº∏ÂÖ•ÊàøÈñìID');
                        return;
                    }

                    try {
                        // È°ØÁ§∫ËºâÂÖ•ÁãÄÊÖã
                        const joinButton = document.getElementById('joinRoomButton');
                        const originalText = joinButton.textContent;
                        joinButton.textContent = 'Âä†ÂÖ•‰∏≠...';
                        joinButton.disabled = true;

                        const connectionResult = await this.multiplayerManager.connectToRoom(roomId, playerName);
                        this.isMultiplayer = true;

                        document.getElementById('roomInfo').style.display = 'block';
                        this.updateConnectionUI();

                        this.chatSystem.addSystemMessage(`Â∑≤Âä†ÂÖ•ÊàøÈñì ${connectionResult.roomId}`);
                        this.chatSystem.addSystemMessage(`Ê≠£Âú®Âª∫Á´ãP2PÈÄ£Êé•...`);

                        // ÊÅ¢Âæ©ÊåâÈàïÁãÄÊÖã
                        joinButton.textContent = originalText;
                        joinButton.disabled = false;

                        // Âú® joinRoom() ÁöÑ try Â°äÊúÄÂæåÊ∑ªÂä†Ôºö
                        this.chatSystem.addSystemMessage(`Â∑≤Âä†ÂÖ•ÊàøÈñì ${connectionResult.roomId}`);
                        this.chatSystem.addSystemMessage(`Ê≠£Âú®Âª∫Á´ãP2PÈÄ£Êé•...`);
                        this.chatSystem.addSystemMessage(`ÈªûÊìä"ÈñãÂßãÈÅäÊà≤"‰æÜÈÄ≤ÂÖ•‰∏ñÁïå`);

                    } catch (error) {
                        console.error('Âä†ÂÖ•ÊàøÈñìÂ§±Êïó:', error);
                        alert('Âä†ÂÖ•ÊàøÈñìÂ§±Êïó: ' + error.message);

                        // ÊÅ¢Âæ©ÊåâÈàïÁãÄÊÖã
                        const joinButton = document.getElementById('joinRoomButton');
                        joinButton.textContent = 'üö™ Âä†ÂÖ•ÊàøÈñì';
                        joinButton.disabled = false;
                    }
                }

                // ÂâµÂª∫ÊàøÈñì
                // ÂâµÂª∫ÊàøÈñì
                async createRoom() {
                    const playerName = document.getElementById('playerName').value.trim();

                    if (!playerName) {
                        alert('Ë´ãËº∏ÂÖ•Áé©ÂÆ∂ÂêçÁ®±');
                        return;
                    }

                    try {
                        // È°ØÁ§∫ËºâÂÖ•ÁãÄÊÖã
                        const createButton = document.getElementById('createRoomButton');
                        const originalText = createButton.textContent;
                        createButton.textContent = 'ÂâµÂª∫‰∏≠...';
                        createButton.disabled = true;

                        const connectionResult = await this.multiplayerManager.connectToRoom(null, playerName);
                        this.isMultiplayer = true;

                        document.getElementById('roomId').value = connectionResult.roomId;
                        document.getElementById('roomInfo').style.display = 'block';
                        this.updateConnectionUI();

                        this.chatSystem.addSystemMessage(`ÊàøÈñìÂ∑≤ÂâµÂª∫ÔºÅ`);
                        this.chatSystem.addSystemMessage(`ÊàøÈñìID: ${connectionResult.roomId}`);
                        this.chatSystem.addSystemMessage(`ÂàÜ‰∫´Ê≠§IDÁµ¶ÊúãÂèã‰æÜÂä†ÂÖ•ÈÅäÊà≤ÔºÅ`);

                        // ÊÅ¢Âæ©ÊåâÈàïÁãÄÊÖã
                        createButton.textContent = originalText;
                        createButton.disabled = false;

                        // Âú® createRoom() ÁöÑ try Â°äÊúÄÂæåÊ∑ªÂä†Ôºö
                        this.chatSystem.addSystemMessage(`ÊàøÈñìÂ∑≤ÂâµÂª∫ÔºÅ`);
                        this.chatSystem.addSystemMessage(`ÊàøÈñìID: ${connectionResult.roomId}`);
                        this.chatSystem.addSystemMessage(`ÂàÜ‰∫´Ê≠§IDÁµ¶ÊúãÂèã‰æÜÂä†ÂÖ•ÈÅäÊà≤ÔºÅ`);
                        this.chatSystem.addSystemMessage(`ÈªûÊìä"ÈñãÂßãÈÅäÊà≤"‰æÜÈÄ≤ÂÖ•‰∏ñÁïå`);

                    } catch (error) {
                        console.error('ÂâµÂª∫ÊàøÈñìÂ§±Êïó:', error);
                        alert('ÂâµÂª∫ÊàøÈñìÂ§±Êïó: ' + error.message);

                        // ÊÅ¢Âæ©ÊåâÈàïÁãÄÊÖã
                        const createButton = document.getElementById('createRoomButton');
                        createButton.textContent = '‚ûï ÂâµÂª∫ÊàøÈñì';
                        createButton.disabled = false;
                    }
                }

                // Ë®≠ÁΩÆÊåâÈàïËºâÂÖ•ÁãÄÊÖã
                setButtonLoading(buttonId, loading, loadingText = 'ËôïÁêÜ‰∏≠...') {
                    const button = document.getElementById(buttonId);
                    if (!button) return;

                    if (loading) {
                        button.dataset.originalText = button.textContent;
                        button.textContent = loadingText;
                        button.disabled = true;
                    } else {
                        button.textContent = button.dataset.originalText || button.textContent;
                        button.disabled = false;
                    }
                }

                // È°ØÁ§∫ÁãÄÊÖãË®äÊÅØ
                showStatusMessage(message, isError = false) {
                    const statusDiv = document.getElementById('connectionStatus');
                    const statusText = document.getElementById('statusText');
                    const messageDiv = statusDiv.querySelector('.status-message');

                    if (statusDiv && statusText) {
                        statusText.textContent = message;
                        messageDiv.className = isError ? 'status-message error' : 'status-message';
                        statusDiv.style.display = 'block';

                        // 3ÁßíÂæåËá™ÂãïÈö±Ëóè
                        setTimeout(() => {
                            statusDiv.style.display = 'none';
                        }, 3000);
                    }
                }

                setupEventListeners() {
                    // ‰∏ªÈÅ∏ÂñÆÊåâÈàï
                    document.getElementById('singlePlayerButton').addEventListener('click', () => {
                        this.isMultiplayer = false;
                        this.startGame();
                    });

                    // ÈñãÂßãÈÅäÊà≤ÊåâÈàï
                    document.getElementById('startGameButton').addEventListener('click', () => {
                        this.startMultiplayerGame();
                    });

                    // Èõ¢ÈñãÊàøÈñìÊåâÈàï
                    document.getElementById('leaveRoomButton').addEventListener('click', () => {
                        this.leaveRoom();
                    });

                    document.getElementById('multiPlayerStartButton').addEventListener('click', () => {
                        this.showMultiplayerMenu();
                    });

                    // Êö´ÂÅúÈÅ∏ÂñÆÊåâÈàï
                    document.getElementById('resumeButton').addEventListener('click', () => {
                        this.resumeGame();
                    });

                    document.getElementById('multiplayerButton').addEventListener('click', () => {
                        this.showMultiplayerMenu();
                    });

                    document.getElementById('settingsButton').addEventListener('click', () => {
                        alert('Ë®≠ÂÆöÂäüËÉΩÈñãÁôº‰∏≠...');
                    });

                    document.getElementById('mainMenuButton').addEventListener('click', () => {
                        this.returnToMainMenu();
                    });

                    // Â§ö‰∫∫ÈÅäÊà≤ÈÅ∏ÂñÆÊåâÈàï
                    document.getElementById('joinRoomButton').addEventListener('click', () => {
                        this.joinRoom();
                    });

                    document.getElementById('createRoomButton').addEventListener('click', () => {
                        this.createRoom();
                    });

                    document.getElementById('backToGameButton').addEventListener('click', () => {
                        // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÈÄ£Êé•Âà∞ÊàøÈñì
                        if (this.multiplayerManager.isConnected) {
                            // Â¶ÇÊûúÂ∑≤ÈÄ£Êé•ÔºåÁõ¥Êé•ÈñãÂßãÈÅäÊà≤
                            this.startMultiplayerGame();
                        } else {
                            // Â¶ÇÊûúÊú™ÈÄ£Êé•ÔºåËøîÂõûÊö´ÂÅúÈÅ∏ÂñÆ
                            document.getElementById('multiplayerMenu').style.display = 'none';
                            if (this.gameStarted) {
                                this.resumeGame();
                            } else {
                                document.getElementById('pauseMenu').style.display = 'flex';
                            }
                        }
                    });

                    // ÈçµÁõ§‰∫ã‰ª∂
                    document.addEventListener('keydown', (e) => {
                        // ESCÈçµÊö´ÂÅú/ÊÅ¢Âæ©
                        if (e.code === 'Escape') {
                            e.preventDefault();
                            if (this.gameStarted) {
                                if (this.chatSystem.isInputActive) {
                                    // Â¶ÇÊûúËÅäÂ§©Ëº∏ÂÖ•Ê°ÜÊøÄÊ¥ªÔºåÂÖàÈóúÈñâËÅäÂ§©
                                    this.chatSystem.hide();
                                    return;
                                }

                                if (this.isPaused) {
                                    this.resumeGame();
                                } else {
                                    this.pauseGame();
                                }
                            }
                            return;
                        }

                        // TÈçµÈñãÂïüËÅäÂ§© - ‰øÆÊîπÁâà
                        if (e.code === 'KeyT' && this.gameStarted && !this.isPaused && this.isMultiplayer) {
                            e.preventDefault();
                            this.activateChat();  // ‚Üê ÊîπÁÇ∫Ë™øÁî®Êñ∞ÁöÑÊñπÊ≥ï
                            return;
                        }

                        // Â¶ÇÊûúËÅäÂ§©Ëº∏ÂÖ•Ê°ÜÊøÄÊ¥ªÔºåËôïÁêÜËÅäÂ§©Áõ∏ÈóúÊåâÈçµ
                        if (this.chatSystem.isInputActive) {
                            if (e.code === 'Enter') {
                                e.preventDefault();
                                const input = document.getElementById('messageInput');
                                const message = input.value.trim();
                                if (message) {
                                    this.chatSystem.sendMessage(message, this.multiplayerManager);
                                    input.value = '';
                                }
                                this.deactivateChat();  // ‚Üê ÊîπÁÇ∫Ë™øÁî®Êñ∞ÁöÑÊñπÊ≥ï
                            } else if (e.code === 'Escape') {
                                e.preventDefault();
                                this.deactivateChat();  // ‚Üê Ê∑ªÂä†ESCÈçµËôïÁêÜ
                            }
                            return;
                        }

                        // ÈÅäÊà≤Êö´ÂÅúÊôÇ‰∏çËôïÁêÜÁßªÂãïÊåâÈçµ
                        if (this.isPaused) return;

                        this.keys[e.code] = true;

                        // ÈÅ∏ÊìáÊñπÂ°äÈ°ûÂûã
                        if (e.code >= 'Digit1' && e.code <= 'Digit4') {
                            const index = parseInt(e.code.slice(-1)) - 1;
                            const types = Object.keys(this.blockTypes);
                            if (types[index]) {
                                this.selectedBlock = types[index];
                                this.updateInventoryUI();
                            }
                        }

                        // È£õË°åÊ®°ÂºèÂàáÊèõ
                        if (e.code === 'KeyF') {
                            this.flying = !this.flying;
                            this.player.velocity.y = 0;
                            this.chatSystem.addSystemMessage(this.flying ? 'È£õË°åÊ®°ÂºèÔºöÈñãÂïü' : 'È£õË°åÊ®°ÂºèÔºöÈóúÈñâ');
                        }

                        // Èò≤Ê≠¢Á©∫ÁôΩÈçµÊªæÂãïÈ†ÅÈù¢
                        if (e.code === 'Space') {
                            e.preventDefault();
                        }
                    });

                    document.addEventListener('keyup', (e) => {
                        if (this.isPaused || this.chatSystem.isInputActive) return;
                        this.keys[e.code] = false;
                    });

                    // ÊªëÈº†‰∫ã‰ª∂
                    this.canvas.addEventListener('click', () => {
                        if (this.gameStarted && !this.isPaused) {
                            this.canvas.requestPointerLock();
                        }
                    });

                    // ÊªëÈº†ÊªæËº™ÂàáÊèõÁâ©ÂìÅ
                    // ÊªëÈº†ÊªæËº™ÂàáÊèõÁâ©ÂìÅ
                    this.canvas.addEventListener('wheel', (e) => {
                        if (!this.gameStarted || this.isPaused || this.chatSystem.isInputActive) return;

                        e.preventDefault();

                        const blockTypes = Object.keys(this.blockTypes);
                        const currentIndex = blockTypes.indexOf(this.selectedBlock);
                        let newIndex;

                        if (e.deltaY > 0) {
                            // Âêë‰∏ãÊªæÂãï - ‰∏ã‰∏ÄÂÄãÁâ©ÂìÅ
                            newIndex = (currentIndex + 1) % blockTypes.length;
                        } else {
                            // Âêë‰∏äÊªæÂãï - ‰∏ä‰∏ÄÂÄãÁâ©ÂìÅ
                            newIndex = (currentIndex - 1 + blockTypes.length) % blockTypes.length;
                        }

                        this.selectedBlock = blockTypes[newIndex];
                        this.updateInventoryUI();

                        // È°ØÁ§∫ÂàáÊèõÊèêÁ§∫
                        this.showBlockSwitchNotification();

                        if (e.code === 'F11') {
                            e.preventDefault();
                            this.toggleFullscreen();
                            return;
                        }
                    });

                    document.addEventListener('pointerlockchange', () => {
                        this.mouse.locked = document.pointerLockElement === this.canvas;
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (this.mouse.locked && !this.isPaused) {
                            this.player.angle += e.movementX * 0.003;
                            this.player.pitch -= e.movementY * 0.003;
                            this.player.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.player.pitch));
                        }
                    });

                    this.canvas.addEventListener('mousedown', (e) => {
                        if (!this.gameStarted || !this.worldGenerated || this.isPaused) return;

                        const target = this.getTargetBlock();
                        if (target) {
                            if (e.button === 0) { // Â∑¶Èçµ - Á†¥Â£û
                                this.removeBlock(target.x, target.y, target.z);

                                // Â§ö‰∫∫ÈÅäÊà≤ÂêåÊ≠•
                                if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                                    this.multiplayerManager.sendBlockUpdate(target.x, target.y, target.z, null, 'break');
                                }
                            } else if (e.button === 2) { // Âè≥Èçµ - ÊîæÁΩÆ
                                const place = this.getPlacePosition(target);
                                if (place && !this.isPlayerColliding(place.x, place.y, place.z)) {
                                    this.setBlock(place.x, place.y, place.z, this.selectedBlock);
                                    this.regenerateNearbyChunks(place.x, place.y, place.z);

                                    // Â§ö‰∫∫ÈÅäÊà≤ÂêåÊ≠•
                                    if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                                        this.multiplayerManager.sendBlockUpdate(place.x, place.y, place.z, this.selectedBlock, 'place');
                                    }
                                }
                            }
                        }
                    });

                    this.canvas.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                    });

                    // Áâ©ÂìÅÊ¨ÑÈªûÊìä
                    document.querySelectorAll('.inventory-slot').forEach((slot) => {
                        slot.addEventListener('click', () => {
                            const blockType = slot.dataset.block;
                            this.selectedBlock = blockType;
                            this.updateInventoryUI();
                        });
                    });

                    // ËÅäÂ§©Á≥ªÁµ±‰∫ã‰ª∂
                    document.getElementById('sendMessage').addEventListener('click', () => {
                        const input = document.getElementById('messageInput');
                        const message = input.value.trim();
                        if (message) {
                            this.chatSystem.sendMessage(message, this.multiplayerManager);
                            input.value = '';
                        }
                    });

                    document.getElementById('messageInput').addEventListener('keydown', (e) => {
                        if (e.code === 'Enter') {
                            e.preventDefault();
                            const message = e.target.value.trim();
                            if (message) {
                                this.chatSystem.sendMessage(message, this.multiplayerManager);
                                e.target.value = '';
                            }
                            this.chatSystem.hide();
                        } else if (e.code === 'Escape') {
                            e.preventDefault();
                            this.chatSystem.hide();
                        }
                    });

                    // Ë¶ñÁ™óÂ§ßÂ∞èË™øÊï¥
                    window.addEventListener('resize', () => {
                        this.canvas.width = window.innerWidth;
                        this.canvas.height = window.innerHeight;
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                        // ÈáçÊñ∞Ë®àÁÆóÊäïÂΩ±Áü©Èô£
                        const aspect = this.canvas.width / this.canvas.height;
                        this.perspective(this.projectionMatrix, Math.PI / 4, aspect, 0.1, 1000.0);
                    });

                    // Èò≤Ê≠¢È†ÅÈù¢ÊªæÂãï
                    window.addEventListener('keydown', (e) => {
                        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                            if (this.gameStarted && this.mouse.locked) {
                                e.preventDefault();
                            }
                        }
                    });
                }

                // ÊøÄÊ¥ªËÅäÂ§©Ê®°Âºè
                activateChat() {
                    this.chatSystem.show();
                    this.chatSystem.isInputActive = true;

                    // ÈáãÊîæÊªëÈº†ÈéñÂÆöÔºåÂÖÅË®±ÊªëÈº†ÁßªÂãï
                    if (this.mouse.locked) {
                        document.exitPointerLock();
                        this.mouse.wasLocked = true; // Ë®ò‰Ωè‰πãÂâçÊòØÂê¶ÈéñÂÆö
                    }

                    const input = document.getElementById('messageInput');
                    input.focus();
                    input.placeholder = 'Ëº∏ÂÖ•Ë®äÊÅØ...';

                    // Ê∑ªÂä†ËÅäÂ§©Ê®°ÂºèÊåáÁ§∫
                    document.getElementById('chatContainer').style.borderColor = '#00ff88';
                }

                // ÂÅúÁî®ËÅäÂ§©Ê®°Âºè
                deactivateChat() {
                    this.chatSystem.isInputActive = false;

                    // ÊÅ¢Âæ©ÊªëÈº†ÈéñÂÆö
                    if (this.mouse.wasLocked && this.gameStarted && !this.isPaused) {
                        this.canvas.requestPointerLock();
                        this.mouse.wasLocked = false;
                    }

                    const input = document.getElementById('messageInput');
                    input.blur();
                    input.placeholder = 'ÊåâTÈñãÂßãËÅäÂ§©...';

                    // ÁßªÈô§ËÅäÂ§©Ê®°ÂºèÊåáÁ§∫
                    document.getElementById('chatContainer').style.borderColor = 'rgba(0, 255, 136, 0.3)';
                }

                // È°ØÁ§∫ÊñπÂ°äÂàáÊèõÈÄöÁü•
                // È°ØÁ§∫ÊñπÂ°äÂàáÊèõÈÄöÁü•
                showBlockSwitchNotification() {
                    const blockInfo = this.blockTypes[this.selectedBlock];
                    if (!blockInfo) return;

                    // ÂâµÂª∫ÊàñÊõ¥Êñ∞ÈÄöÁü•ÂÖÉÁ¥†
                    let notification = document.getElementById('blockSwitchNotification');
                    if (!notification) {
                        notification = document.createElement('div');
                        notification.id = 'blockSwitchNotification';
                        notification.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.95));
                        color: #00ff88;
                        padding: 15px 25px;
                        border-radius: 15px;
                        border: 2px solid rgba(0, 255, 136, 0.5);
                        font-size: 18px;
                        font-weight: bold;
                        z-index: 300;
                        pointer-events: none;
                        backdrop-filter: blur(10px);
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                        opacity: 0;
                        transition: opacity 0.3s ease;
                    `;
                        document.body.appendChild(notification);
                    }

                    // Êõ¥Êñ∞ÂÖßÂÆπÔºåÁÇ∫ÈÄèÊòéÊñπÂ°äÊ∑ªÂä†ÁâπÊÆäÊ®ôË®ò
                    const transparentText = blockInfo.transparent ? ' (ÈÄèÊòé)' : '';
                    notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">${blockInfo.icon}</span>
                        <span>${blockInfo.name}${transparentText}</span>
                    </div>
                `;

                    // È°ØÁ§∫ÂãïÁï´
                    notification.style.opacity = '1';

                    // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊôÇÂô®
                    if (this.notificationTimeout) {
                        clearTimeout(this.notificationTimeout);
                    }

                    // 1.5ÁßíÂæåÈö±Ëóè
                    this.notificationTimeout = setTimeout(() => {
                        notification.style.opacity = '0';
                    }, 1500);
                }

                startGame() {
                    if (!this.worldGenerated) {
                        alert('‰∏ñÁïåÈÇÑÂú®ÁîüÊàê‰∏≠ÔºåË´ãÁ®çÂÄô...');
                        return;
                    }

                    this.gameStarted = true;
                    this.isPaused = false;

                    // Ê∑°Âá∫‰∏¶Èö±Ëóè‰∏ªÈÅ∏ÂñÆ
                    const instructionsElement = document.getElementById('instructions');
                    instructionsElement.style.transition = 'opacity 0.5s ease';
                    instructionsElement.style.opacity = '0';

                    setTimeout(() => {
                        instructionsElement.style.display = 'none';
                    }, 500);

                    // Èö±ËóèÂÖ∂‰ªñÈÅ∏ÂñÆ
                    document.getElementById('pauseMenu').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';

                    // Â∞áÁé©ÂÆ∂ÊîæÁΩÆÂú®ÂÆâÂÖ®‰ΩçÁΩÆ
                    this.player.x = Math.random() * 10 - 5;
                    this.player.z = Math.random() * 10 - 5;
                    this.player.y = Math.max(5, this.getHighestBlock(this.player.x, this.player.z) + 3);

                    // È°ØÁ§∫ËÅäÂ§©Á≥ªÁµ±ÔºàÂ§ö‰∫∫Ê®°ÂºèÔºâ
                    if (this.isMultiplayer) {
                        this.chatSystem.show();
                        this.chatSystem.addSystemMessage('ÈÅäÊà≤ÈñãÂßãÔºÅÊåâTÈçµËÅäÂ§©');
                    }

                    console.log(`ÈÅäÊà≤Â∑≤ÂïüÂãïÔºÅÁé©ÂÆ∂‰ΩçÁΩÆ: (${this.player.x}, ${this.player.y}, ${this.player.z})`);
                    console.log(`Ê®°Âºè: ${this.isMultiplayer ? 'Â§ö‰∫∫' : 'ÂñÆ‰∫∫'}`);
                }

                // ÈáçÊñ∞ÁîüÊàêÈôÑËøëÂçÄÂ°ä
                regenerateNearbyChunks(x, y, z) {
                    const chunkX = Math.floor((x + this.worldSize / 2) / 16);
                    const chunkZ = Math.floor((z + this.worldSize / 2) / 16);

                    this.generateChunkMesh(chunkX, chunkZ);

                    // Ê™¢Êü•Áõ∏ÈÑ∞ÂçÄÂ°ä
                    const localX = (x + this.worldSize / 2) % 16;
                    const localZ = (z + this.worldSize / 2) % 16;
                    const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                    if (localX === 0 && chunkX > 0) {
                        this.generateChunkMesh(chunkX - 1, chunkZ);
                    }
                    if (localX === 15 && chunkX < maxChunkIndex) {
                        this.generateChunkMesh(chunkX + 1, chunkZ);
                    }
                    if (localZ === 0 && chunkZ > 0) {
                        this.generateChunkMesh(chunkX, chunkZ - 1);
                    }
                    if (localZ === 15 && chunkZ < maxChunkIndex) {
                        this.generateChunkMesh(chunkX, chunkZ + 1);
                    }
                }

                async generateWorld() {
                    return new Promise((resolve) => {
                        const startTime = Date.now();
                        let progress = 0;

                        // ÁîüÊàêÈ´òÂ∫¶ÂúñÂíåÁîüÁâ©Áæ§ËêΩÂúñ
                        const heightMap = this.generateHeightMap();
                        const biomeMap = this.generateBiomeMap();  // ‚Üê Á¢∫‰øùÈÄôË°åÂ≠òÂú®

                        const generateChunk = (chunkX, chunkZ) => {
                            console.log(`ÈñãÂßãÁîüÊàêÂçÄÂ°ä (${chunkX}, ${chunkZ})`);

                            const chunkSize = 16;
                            const startX = chunkX * chunkSize - this.worldSize / 2;
                            const startZ = chunkZ * chunkSize - this.worldSize / 2;

                            let blocksGenerated = 0;

                            for (let x = 0; x < chunkSize; x++) {
                                for (let z = 0; z < chunkSize; z++) {
                                    const worldX = startX + x;
                                    const worldZ = startZ + z;

                                    if (Math.abs(worldX) >= this.worldSize / 2 || Math.abs(worldZ) >= this.worldSize / 2) continue;

                                    const height = heightMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];
                                    const biome = biomeMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];

                                    // Âü∫Â≤©Â±§ÔºàÊúÄÂ∫ïÂ±§Ôºâ
                                    for (let y = -3; y <= -1; y++) {
                                        this.setBlock(worldX, y, worldZ, 'stone');
                                        blocksGenerated++;
                                    }

                                    // Âú∞‰∏ãÂ±§
                                    for (let y = 0; y < height - 2; y++) {
                                        this.setBlock(worldX, y, worldZ, 'stone');
                                        blocksGenerated++;
                                    }

                                    // Ê¨°Ë°®Èù¢Â±§ÔºàÊ†πÊìöÁîüÁâ©Áæ§ËêΩÔºâ
                                    if (height >= 1) {
                                        let subSurfaceBlock = 'stone';
                                        switch (biome) {
                                            case 'desert':
                                                subSurfaceBlock = 'sand';
                                                break;
                                            case 'snow':
                                                subSurfaceBlock = 'stone';
                                                break;
                                            default:
                                                subSurfaceBlock = 'stone';
                                        }
                                        this.setBlock(worldX, height - 1, worldZ, subSurfaceBlock);
                                        blocksGenerated++;
                                    }

                                    // Ë°®Èù¢ÊñπÂ°äÔºàÊ†πÊìöÁîüÁâ©Áæ§ËêΩÔºâ
                                    if (height >= 0) {
                                        let surfaceBlock = 'grass';
                                        switch (biome) {
                                            case 'desert':
                                                surfaceBlock = 'sand';
                                                break;
                                            case 'snow':
                                                surfaceBlock = 'snow';
                                                break;
                                            case 'forest':
                                                surfaceBlock = 'grass';
                                                break;
                                            case 'jungle':
                                                surfaceBlock = 'grass';
                                                break;
                                            default:
                                                surfaceBlock = 'grass';
                                        }
                                        this.setBlock(worldX, height, worldZ, surfaceBlock);
                                        blocksGenerated++;
                                    }

                                    // ÁîüÊàêÊ§çË¢´ÔºàÊ†πÊìöÁîüÁâ©Áæ§ËêΩÔºâ
                                    if (height > 2 && Math.random() < this.getVegetationChance(biome)) {
                                        this.generateVegetation(worldX, height + 1, worldZ, biome);
                                    }

                                    // Ê∞¥È´îÔºàÊµ∑Âπ≥Èù¢ÁÇ∫0Ôºâ
                                    if (height < 0) {
                                        for (let y = height + 1; y <= 0; y++) {
                                            this.setBlock(worldX, y, worldZ, 'water');
                                            blocksGenerated++;
                                        }
                                    }
                                }
                            }

                            console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) ÁîüÊàê‰∫Ü ${blocksGenerated} ÂÄãÊñπÂ°ä`);

                            try {
                                this.generateChunkMesh(chunkX, chunkZ);
                                console.log(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Á∂≤Ê†ºÁîüÊàêÊàêÂäü`);
                            } catch (error) {
                                console.error(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Á∂≤Ê†ºÁîüÊàêÂ§±Êïó:`, error);
                            }
                        };

                        const totalChunks = Math.pow(Math.ceil(this.worldSize / 16), 2);
                        let processedChunks = 0;

                        const processNextChunk = () => {
                            const chunksPerFrame = 2;
                            const chunksPerSide = Math.ceil(this.worldSize / 16);

                            for (let i = 0; i < chunksPerFrame && processedChunks < totalChunks; i++) {
                                const chunkX = Math.floor(processedChunks / chunksPerSide);
                                const chunkZ = processedChunks % chunksPerSide;

                                try {
                                    generateChunk(chunkX, chunkZ);
                                    processedChunks++;
                                } catch (error) {
                                    console.error(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) ÁîüÊàêÂ§±Êïó:`, error);
                                    processedChunks++;
                                }
                            }

                            progress = (processedChunks / totalChunks) * 100;
                            const progressBar = document.getElementById('loadingProgress');
                            const loadingText = document.querySelector('.loading');

                            if (progressBar) {
                                progressBar.style.width = progress + '%';
                            }
                            if (loadingText) {
                                loadingText.textContent = `ÁîüÊàê‰∏ñÁïå ${Math.floor(progress)}%`;
                            }

                            if (processedChunks >= totalChunks) {
                                this.worldGenerated = true;

                                // Âº∑Âà∂ÈáçÊñ∞ÁîüÊàêÊâÄÊúâÂçÄÂ°ä‰ª•ÊáâÁî®ÈÄèÊòéÂ∫¶
                                console.log('ÈáçÊñ∞ÁîüÊàêÂçÄÂ°ä‰ª•ÊáâÁî®ÈÄèÊòéÂ∫¶...');
                                setTimeout(() => {
                                    this.regenerateAllChunks();
                                }, 1000);

                                console.log(`‰∏ñÁïåÁîüÊàêÂÆåÊàêÔºåËÄóÊôÇ: ${Date.now() - startTime}ms`);
                                console.log(`Á∏ΩÂÖ±ÁîüÊàê‰∫Ü ${this.world.size} ÂÄãÊñπÂ°ä`);
                                resolve();
                            } else {
                                requestAnimationFrame(processNextChunk);
                            }
                        };

                        processNextChunk();
                    });
                }

                // Áç≤ÂèñÊ§çË¢´ÁîüÊàêÊ©üÁéá
                getVegetationChance(biome) {
                    switch (biome) {
                        case 'forest': return 0.08;
                        case 'jungle': return 0.12;
                        case 'plains': return 0.03;
                        case 'desert': return 0.005;
                        case 'snow': return 0.01;
                        default: return 0.02;
                    }
                }

                // ÁîüÊàêÊ§çË¢´
                generateVegetation(x, y, z, biome) {
                    switch (biome) {
                        case 'forest':
                            if (Math.random() < 0.7) {
                                this.generateTree(x, y, z, 'wood', 'leaves');
                            }
                            break;
                        case 'jungle':
                            if (Math.random() < 0.8) {
                                this.generateTree(x, y, z, 'wood', 'leaves', true); // È´òÊ®π
                            }
                            break;
                        case 'desert':
                            // ‰ªô‰∫∫Êéå
                            if (Math.random() < 0.3) {
                                this.generateCactus(x, y, z);
                            }
                            break;
                        case 'snow':
                            // Èõ™Êùæ
                            if (Math.random() < 0.5) {
                                this.generateTree(x, y, z, 'wood', 'leaves');
                            }
                            break;
                        default:
                            if (Math.random() < 0.5) {
                                this.generateTree(x, y, z, 'wood', 'leaves');
                            }
                    }
                }

                // ÁîüÊàêÊ®πÊú®
                generateTree(x, y, z, trunkType = 'wood', leafType = 'leaves', tall = false) {
                    const height = tall ? 5 + Math.floor(Math.random() * 3) : 3 + Math.floor(Math.random() * 2);

                    // Ê®πÂππ
                    for (let i = 0; i < height; i++) {
                        this.setBlock(x, y + i, z, trunkType);
                    }

                    // Ê®πËëâÔºàÊõ¥Ëá™ÁÑ∂ÁöÑÂΩ¢ÁãÄÔºâ
                    const leafY = y + height;
                    const leafRadius = tall ? 3 : 2;

                    for (let dx = -leafRadius; dx <= leafRadius; dx++) {
                        for (let dz = -leafRadius; dz <= leafRadius; dz++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const distance = Math.sqrt(dx * dx + dz * dz + dy * dy);
                                if (distance <= leafRadius && Math.random() < 0.8) {
                                    this.setBlock(x + dx, leafY + dy, z + dz, leafType);
                                }
                            }
                        }
                    }

                    // Ê®πÈ†Ç
                    this.setBlock(x, leafY + 1, z, leafType);
                }

                // ÁîüÊàê‰ªô‰∫∫Êéå
                generateCactus(x, y, z) {
                    const height = 2 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < height; i++) {
                        this.setBlock(x, y + i, z, 'leaves'); // Áî®Á∂†Ëâ≤ÊñπÂ°ä‰ª£Ë°®‰ªô‰∫∫Êéå
                    }
                }

                // ÈáçÊñ∞ÁîüÊàêÊâÄÊúâÂçÄÂ°ä
                regenerateAllChunks() {
                    const chunksPerSide = Math.ceil(this.worldSize / 16);
                    for (let chunkX = 0; chunkX < chunksPerSide; chunkX++) {
                        for (let chunkZ = 0; chunkZ < chunksPerSide; chunkZ++) {
                            try {
                                this.generateChunkMesh(chunkX, chunkZ);
                            } catch (error) {
                                console.error(`ÈáçÊñ∞ÁîüÊàêÂçÄÂ°ä (${chunkX}, ${chunkZ}) Â§±Êïó:`, error);
                            }
                        }
                    }
                    console.log('ÊâÄÊúâÂçÄÂ°äÈáçÊñ∞ÁîüÊàêÂÆåÊàê');
                }

                generateHeightMap() {
                    const heightMap = [];
                    for (let x = 0; x < this.worldSize; x++) {
                        heightMap[x] = [];
                        for (let z = 0; z < this.worldSize; z++) {
                            const nx = (x - this.worldSize / 2) / this.worldSize;
                            const nz = (z - this.worldSize / 2) / this.worldSize;

                            // Â§öÂ±§Âô™ËÅ≤ÁñäÂä† - Êõ¥Ë§áÈõúÁöÑÂú∞ÂΩ¢
                            const continentalNoise = this.improvedNoise(nx * 0.5, nz * 0.5) * 15; // Â§ßÈô∏Êû∂
                            const mountainNoise = this.improvedNoise(nx * 2, nz * 2) * 8; // Â±±ËÑà
                            const hillNoise = this.improvedNoise(nx * 4, nz * 4) * 4; // ‰∏òÈôµ
                            const detailNoise = this.improvedNoise(nx * 8, nz * 8) * 2; // Á¥∞ÁØÄ
                            const microNoise = this.improvedNoise(nx * 16, nz * 16) * 1; // ÂæÆÁ¥∞ÁØÄ

                            // Ê≤≥ÊµÅÁ≥ªÁµ±
                            const riverNoise = Math.abs(this.improvedNoise(nx * 3, nz * 1.5));
                            const isRiver = riverNoise < 0.1;

                            // Âü∫Á§éÈ´òÂ∫¶Ë®àÁÆó
                            let height = 3 + continentalNoise + mountainNoise + hillNoise + detailNoise + microNoise;

                            // Ê≤≥ÊµÅÊúÉÈôç‰ΩéÂú∞ÂΩ¢
                            if (isRiver) {
                                height -= 5;
                            }

                            // ÂâµÂª∫Êµ∑Â≤∏Á∑öÊïàÊûú
                            const distanceFromCenter = Math.sqrt(nx * nx + nz * nz);
                            if (distanceFromCenter > 0.7) {
                                height -= (distanceFromCenter - 0.7) * 20;
                            }

                            heightMap[x][z] = Math.floor(Math.max(-5, height));
                        }
                    }
                    return heightMap;
                }

                // ÊîπÈÄ≤ÁöÑÂô™ËÅ≤ÂáΩÊï∏
                improvedNoise(x, z) {
                    // ‰ΩøÁî®Â§öÂÄãÊ≠£Âº¶Ê≥¢ÁñäÂä†Áî¢ÁîüÊõ¥Ëá™ÁÑ∂ÁöÑÂô™ËÅ≤
                    const n1 = Math.sin(x * 2.1 + z * 1.7) * 0.5;
                    const n2 = Math.sin(x * 1.3 - z * 2.3) * 0.3;
                    const n3 = Math.sin(x * 3.7 + z * 0.9) * 0.2;
                    const n4 = Math.sin(x * 5.1 + z * 4.7) * 0.1;
                    const n5 = Math.sin(x * 7.3 - z * 6.1) * 0.05;
                    return (n1 + n2 + n3 + n4 + n5);
                }

                // ÁîüÊàêÁîüÁâ©Áæ§ËêΩÂúñ
                generateBiomeMap() {
                    const biomeMap = [];
                    for (let x = 0; x < this.worldSize; x++) {
                        biomeMap[x] = [];
                        for (let z = 0; z < this.worldSize; z++) {
                            const nx = (x - this.worldSize / 2) / this.worldSize;
                            const nz = (z - this.worldSize / 2) / this.worldSize;

                            // Ê∫´Â∫¶ÂíåÊøïÂ∫¶Âô™ËÅ≤
                            const temperature = this.improvedNoise(nx * 2.5, nz * 2.5);
                            const humidity = this.improvedNoise(nx * 3.1 + 100, nz * 3.1 + 100);

                            // Ê†πÊìöÊ∫´Â∫¶ÂíåÊøïÂ∫¶Ê±∫ÂÆöÁîüÁâ©Áæ§ËêΩ
                            if (temperature > 0.3 && humidity < -0.2) {
                                biomeMap[x][z] = 'desert';
                            } else if (temperature < -0.3) {
                                biomeMap[x][z] = 'snow';
                            } else if (humidity > 0.4) {
                                biomeMap[x][z] = 'forest';
                            } else if (temperature > 0.1 && humidity > 0.1) {
                                biomeMap[x][z] = 'jungle';
                            } else {
                                biomeMap[x][z] = 'plains';
                            }
                        }
                    }
                    return biomeMap;
                }

                // ÊîπÈÄ≤ÁöÑÂô™ËÅ≤ÂáΩÊï∏
                improvedNoise(x, z) {
                    // ‰ΩøÁî®Â§öÂÄãÊ≠£Âº¶Ê≥¢ÁñäÂä†Áî¢ÁîüÊõ¥Ëá™ÁÑ∂ÁöÑÂô™ËÅ≤
                    const n1 = Math.sin(x * 2.1 + z * 1.7) * 0.5;
                    const n2 = Math.sin(x * 1.3 - z * 2.3) * 0.3;
                    const n3 = Math.sin(x * 3.7 + z * 0.9) * 0.2;
                    return (n1 + n2 + n3);
                }

                generateSimpleTree(x, y, z) {
                    // Á∞°ÂñÆÁöÑÊ®πÂππÔºà3Ê†ºÈ´òÔºâ
                    for (let i = 0; i < 3; i++) {
                        this.setBlock(x, y + i, z, 'wood');
                    }

                    // Á∞°ÂñÆÁöÑÊ®πËëâÔºàÂçÅÂ≠óÂΩ¢Ôºâ
                    const leafY = y + 3;
                    this.setBlock(x, leafY, z, 'grass'); // ‰∏≠ÂøÉ
                    this.setBlock(x + 1, leafY, z, 'grass');
                    this.setBlock(x - 1, leafY, z, 'grass');
                    this.setBlock(x, leafY, z + 1, 'grass');
                    this.setBlock(x, leafY, z - 1, 'grass');

                    // È†ÇÈÉ®
                    this.setBlock(x, leafY + 1, z, 'grass');
                }

                setBlock(x, y, z, type) {
                    const key = `${x},${y},${z}`;
                    this.world.set(key, type);
                }

                getBlock(x, y, z) {
                    const key = `${x},${y},${z}`;
                    return this.world.get(key);
                }

                removeBlock(x, y, z) {
                    const key = `${x},${y},${z}`;
                    this.world.delete(key);

                    // ÈáçÊñ∞ÁîüÊàêÂèóÂΩ±ÈüøÁöÑÂçÄÂ°äÁ∂≤Ê†º
                    this.regenerateNearbyChunks(x, y, z);
                }

                getHighestBlock(x, z) {
                    for (let y = 20; y >= -10; y--) {
                        if (this.getBlock(Math.floor(x), y, Math.floor(z))) {
                            return y;
                        }
                    }
                    return 0;
                }

                updateInventoryUI() {
                    document.querySelectorAll('.inventory-slot').forEach(slot => {
                        slot.classList.remove('active');
                        if (slot.dataset.block === this.selectedBlock) {
                            slot.classList.add('active');
                        }
                    });
                }

                getTargetBlock() {
                    const range = 8;
                    const step = 0.05;

                    const startX = this.player.x;
                    const startY = this.player.y + 1.6; // ÁúºÁùõÈ´òÂ∫¶
                    const startZ = this.player.z;

                    // Ë®àÁÆóÂ∞ÑÁ∑öÊñπÂêë
                    const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                    const dirY = Math.sin(this.player.pitch);
                    const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                    for (let d = 0; d < range; d += step) {
                        const x = Math.floor(startX + dirX * d);
                        const y = Math.floor(startY + dirY * d);
                        const z = Math.floor(startZ + dirZ * d);

                        if (this.getBlock(x, y, z)) {
                            return {
                                x, y, z,
                                hitX: startX + dirX * d,
                                hitY: startY + dirY * d,
                                hitZ: startZ + dirZ * d
                            };
                        }
                    }
                    return null;
                }

                getPlacePosition(target) {
                    if (!target) return null;

                    // Ë®àÁÆóÂ∞ÑÁ∑öÊñπÂêë
                    const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                    const dirY = Math.sin(this.player.pitch);
                    const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                    // Ê†πÊìöÊíûÊìäÈªûÁ¢∫ÂÆöÊîæÁΩÆÈù¢
                    const hitX = target.hitX - target.x;
                    const hitY = target.hitY - target.y;
                    const hitZ = target.hitZ - target.z;

                    let placeX = target.x;
                    let placeY = target.y;
                    let placeZ = target.z;

                    // Á¢∫ÂÆöÊúÄÊé•ËøëÁöÑÈù¢
                    const absX = Math.abs(hitX - 0.5);
                    const absY = Math.abs(hitY - 0.5);
                    const absZ = Math.abs(hitZ - 0.5);

                    if (absX > absY && absX > absZ) {
                        // XÈù¢
                        placeX += hitX > 0.5 ? 1 : -1;
                    } else if (absY > absZ) {
                        // YÈù¢
                        placeY += hitY > 0.5 ? 1 : -1;
                    } else {
                        // ZÈù¢
                        placeZ += hitZ > 0.5 ? 1 : -1;
                    }

                    // Ê™¢Êü•‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà
                    if (!this.getBlock(placeX, placeY, placeZ)) {
                        return { x: placeX, y: placeY, z: placeZ };
                    }

                    return null;
                }

                isPlayerColliding(x, y, z) {
                    const px = Math.floor(this.player.x);
                    const py = Math.floor(this.player.y);
                    const pz = Math.floor(this.player.z);

                    return (Math.abs(x - px) <= 1 && Math.abs(y - py) <= 2 && Math.abs(z - pz) <= 1);
                }

                checkCollision(x, y, z) {
                    const blockX = Math.floor(x);
                    const blockY = Math.floor(y);
                    const blockZ = Math.floor(z);

                    // Ê™¢Êü•Áé©ÂÆ∂‰ΩîÁî®ÁöÑÁ©∫ÈñìÔºà2Ê†ºÈ´òÔºâ
                    for (let dy = 0; dy < 2; dy++) {
                        if (this.getBlock(blockX, blockY + dy, blockZ)) {
                            return true;
                        }
                    }
                    return false;
                }

                generateChunkMesh(chunkX, chunkZ) {
                    console.log(`ÈñãÂßãÁîüÊàêÂçÄÂ°äÁ∂≤Ê†º (${chunkX}, ${chunkZ})`);

                    if (chunkX < 0 || chunkZ < 0 ||
                        chunkX >= Math.ceil(this.worldSize / 16) ||
                        chunkZ >= Math.ceil(this.worldSize / 16)) {
                        console.warn(`ÂçÄÂ°ä (${chunkX}, ${chunkZ}) Ë∂ÖÂá∫ÈÇäÁïåÔºåË∑≥ÈÅé`);
                        return;
                    }

                    const chunkSize = 16;
                    const vertices = [];
                    const colors = [];
                    const normals = [];
                    const alphas = [];  // Ê∑ªÂä†ÈÄèÊòéÂ∫¶Êï∏ÁµÑ
                    const indices = [];
                    let indexOffset = 0;

                    const startX = chunkX * chunkSize - this.worldSize / 2;
                    const startZ = chunkZ * chunkSize - this.worldSize / 2;

                    for (let x = 0; x < chunkSize; x++) {
                        for (let z = 0; z < chunkSize; z++) {
                            for (let y = -10; y < 50; y++) {
                                const worldX = startX + x;
                                const worldZ = startZ + z;
                                const blockType = this.getBlock(worldX, y, worldZ);

                                if (!blockType) continue;

                                const faces = [
                                    { dir: [0, 1, 0], visible: this.shouldRenderFace(worldX, y + 1, worldZ, blockType) },
                                    { dir: [0, -1, 0], visible: this.shouldRenderFace(worldX, y - 1, worldZ, blockType) },
                                    { dir: [1, 0, 0], visible: this.shouldRenderFace(worldX + 1, y, worldZ, blockType) },
                                    { dir: [-1, 0, 0], visible: this.shouldRenderFace(worldX - 1, y, worldZ, blockType) },
                                    { dir: [0, 0, 1], visible: this.shouldRenderFace(worldX, y, worldZ + 1, blockType) },
                                    { dir: [0, 0, -1], visible: this.shouldRenderFace(worldX, y, worldZ - 1, blockType) }
                                ];

                                faces.forEach((face, faceIndex) => {
                                    if (!face.visible) return;

                                    const faceVertices = this.getFaceVertices(worldX, y, worldZ, faceIndex);
                                    const blockInfo = this.blockTypes[blockType];

                                    if (!blockInfo) {
                                        console.warn(`Êú™Áü•ÊñπÂ°äÈ°ûÂûã: ${blockType}`);
                                        return;
                                    }

                                    // Áç≤ÂèñÊñπÂ°äÈÄèÊòéÂ∫¶
                                    const blockAlpha = blockInfo.alpha || 1.0;

                                    // Ê†πÊìöÈù¢ÁöÑÊñπÂêëÈÅ∏ÊìáÈ°èËâ≤
                                    let blockColor;
                                    if (blockInfo.colors) {
                                        switch (faceIndex) {
                                            case 0: blockColor = blockInfo.colors.top; break;
                                            case 1: blockColor = blockInfo.colors.bottom; break;
                                            default: blockColor = blockInfo.colors.side; break;
                                        }
                                    } else {
                                        blockColor = blockInfo.color || [0.5, 0.5, 0.5];
                                    }

                                    if (!blockColor || blockColor.length !== 3) {
                                        blockColor = [0.5, 0.5, 0.5];
                                    }

                                    // Ë®àÁÆóÂÖâÁÖß
                                    const shadeFactor = this.calculateFaceShading(faceIndex, face.dir);
                                    let shadedColor = [
                                        Math.max(0, Math.min(1, blockColor[0] * shadeFactor)),
                                        Math.max(0, Math.min(1, blockColor[1] * shadeFactor)),
                                        Math.max(0, Math.min(1, blockColor[2] * shadeFactor))
                                    ];

                                    // ÈÄèÊòéÊñπÂ°äÂ¢ûÂä†‰∫ÆÂ∫¶
                                    if (blockInfo.transparent) {
                                        shadedColor = [
                                            Math.min(1, shadedColor[0] * 1.2),
                                            Math.min(1, shadedColor[1] * 1.2),
                                            Math.min(1, shadedColor[2] * 1.2)
                                        ];
                                    }

                                    // Ê∑ªÂä†È†ÇÈªûÊï∏Êìö
                                    for (let i = 0; i < 4; i++) {
                                        vertices.push(...faceVertices[i]);
                                        colors.push(...shadedColor);
                                        normals.push(...face.dir);
                                        alphas.push(blockAlpha);  // Ê∑ªÂä†ÈÄèÊòéÂ∫¶Êï∏Êìö
                                    }

                                    indices.push(
                                        indexOffset, indexOffset + 1, indexOffset + 2,
                                        indexOffset, indexOffset + 2, indexOffset + 3
                                    );
                                    indexOffset += 4;
                                });
                            }
                        }
                    }

                    // Â≠òÂÑ≤ÂçÄÂ°äÁ∂≤Ê†ºÔºàÂåÖÂê´ÈÄèÊòéÂ∫¶Êï∏ÊìöÔºâ
                    this.chunkMeshes.set(`${chunkX},${chunkZ}`, {
                        vertices: new Float32Array(vertices),
                        colors: new Float32Array(colors),
                        normals: new Float32Array(normals),
                        alphas: new Float32Array(alphas),  // Ê∑ªÂä†ÈÄèÊòéÂ∫¶Êï∏Êìö
                        indices: new Uint16Array(indices),
                        vertexCount: vertices.length / 3,
                        indexCount: indices.length
                    });

                    console.log(`ÂçÄÂ°äÁ∂≤Ê†º (${chunkX}, ${chunkZ}) Â∑≤Â≠òÂÑ≤`);
                }

                calculateFaceShading(faceIndex, normal) {
                    // Âü∫ÊñºÈù¢ÁöÑÊñπÂêëË®àÁÆóÂÖâÁÖßÂº∑Â∫¶
                    const lightDirection = [0.3, 0.8, 0.5]; // ÂÖâÊ∫êÊñπÂêë

                    // Ë®àÁÆóÊ≥ïÁ∑öËàáÂÖâÊ∫êÁöÑÈªûÁ©ç
                    const dotProduct = normal[0] * lightDirection[0] +
                        normal[1] * lightDirection[1] +
                        normal[2] * lightDirection[2];

                    // Âü∫Á§é‰∫ÆÂ∫¶ + ÊñπÂêëÂÖâÁÖß
                    const baseBrightness = 0.6;
                    const directionalLight = Math.max(0, dotProduct) * 0.4;

                    return Math.max(0.3, Math.min(1.0, baseBrightness + directionalLight));
                }

                shouldRenderFace(x, y, z, currentBlockType) {
                    // Ê∑ªÂä†‰∏ñÁïåÈÇäÁïåÊ™¢Êü•
                    if (Math.abs(x) > this.worldSize || Math.abs(z) > this.worldSize || y < -10 || y > 50) {
                        return true; // ‰∏ñÁïåÈÇäÁïåÂ§ñË¶ñÁÇ∫Á©∫Ê∞£ÔºåÈúÄË¶ÅÊ∏≤ÊüìÈù¢
                    }

                    const neighborBlock = this.getBlock(x, y, z);

                    // Â¶ÇÊûúÈÑ∞Â±Ö‰ΩçÁΩÆÊ≤íÊúâÊñπÂ°äÔºåÂâáÊ∏≤ÊüìÈÄôÂÄãÈù¢
                    if (!neighborBlock) {
                        return true;
                    }

                    // Â¶ÇÊûúÈÑ∞Â±ÖÊòØÈÄèÊòéÊñπÂ°äÔºàÂ¶ÇÊ∞¥„ÄÅÁéªÁíÉÔºâÔºåÂâáÊ∏≤ÊüìÈÄôÂÄãÈù¢
                    if (this.blockTypes[neighborBlock] && this.blockTypes[neighborBlock].transparent) {
                        return true;
                    }

                    // Â¶ÇÊûúÁï∂ÂâçÊñπÂ°äÊòØÈÄèÊòéÁöÑÔºå‰∏îÈÑ∞Â±Ö‰∏çÊòØÂêåÈ°ûÂûãÔºåÂâáÊ∏≤Êüì
                    if (this.blockTypes[currentBlockType] && this.blockTypes[currentBlockType].transparent) {
                        return neighborBlock !== currentBlockType;
                    }

                    // Âê¶Ââá‰∏çÊ∏≤ÊüìÔºàË¢´ÈÅÆÊìãÔºâ
                    return false;
                }

                getFaceVertices(x, y, z, faceIndex) {
                    const vertices = [
                        // ‰∏äÈù¢ (y+1) - ÈÄÜÊôÇÈáù
                        [[x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x + 1, y + 1, z]],
                        // ‰∏ãÈù¢ (y) - È†ÜÊôÇÈáù
                        [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]],
                        // Âè≥Èù¢ (x+1) - ÈÄÜÊôÇÈáù
                        [[x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1], [x + 1, y, z + 1]],
                        // Â∑¶Èù¢ (x) - È†ÜÊôÇÈáù
                        [[x, y, z + 1], [x, y + 1, z + 1], [x, y + 1, z], [x, y, z]],
                        // ÂâçÈù¢ (z+1) - ÈÄÜÊôÇÈáù
                        [[x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1]],
                        // ÂæåÈù¢ (z) - È†ÜÊôÇÈáù
                        [[x + 1, y, z], [x, y, z], [x, y + 1, z], [x + 1, y + 1, z]]
                    ];

                    return vertices[faceIndex];
                }

                updateViewMatrix() {
                    // Ë®àÁÆóÊîùÂÉèÊ©ü‰ΩçÁΩÆÂíåÁõÆÊ®ô
                    const eye = [this.player.x, this.player.y + 1.6, this.player.z]; // Áé©ÂÆ∂ÁúºÁùõÈ´òÂ∫¶
                    const target = [
                        this.player.x + Math.cos(this.player.angle) * Math.cos(this.player.pitch),
                        this.player.y + 1.6 + Math.sin(this.player.pitch),
                        this.player.z + Math.sin(this.player.angle) * Math.cos(this.player.pitch)
                    ];
                    const up = [0, 1, 0];

                    this.lookAt(this.viewMatrix, eye, target, up);
                }

                render() {
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                    if (!this.gameStarted || !this.worldGenerated) return;

                    this.triangleCount = 0;
                    this.vertexCount = 0;
                    this.drawCalls = 0;

                    this.updateViewMatrix();

                    this.identity(this.modelMatrix);
                    this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, this.projectionMatrix);
                    this.gl.uniformMatrix4fv(this.uniforms.viewMatrix, false, this.viewMatrix);
                    this.gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix);

                    // Ë®≠ÁΩÆÂÖâÁÖß
                    this.gl.uniform3f(this.uniforms.lightDirection, 0.3, 0.8, 0.5);
                    this.gl.uniform3f(this.uniforms.ambientLight, 0.6, 0.6, 0.6);

                    try {
                        // Á¨¨‰∏ÄÈöéÊÆµÔºöÊ∏≤ÊüìÊâÄÊúâÊñπÂ°äÔºàÂåÖÊã¨ÈÄèÊòéÁöÑÔºâ
                        // ÂïüÁî®Ê∑∑ÂêàÊ®°Âºè
                        this.gl.enable(this.gl.BLEND);
                        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                        // Â∞çÊñºÈÄèÊòéÊñπÂ°äÔºåÁ¶ÅÁî®Ê∑±Â∫¶ÂØ´ÂÖ•‰ΩÜ‰øùÊåÅÊ∑±Â∫¶Ê∏¨Ë©¶
                        this.gl.depthMask(true); // ÂÖàÊ∏≤Êüì‰∏çÈÄèÊòéÈÉ®ÂàÜ

                        this.renderVisibleChunks();

                        // Ê∏≤ÊüìÂÖ∂‰ªñÁé©ÂÆ∂
                        this.renderOtherPlayers();

                    } catch (error) {
                        console.error('Ê∏≤ÊüìÈÅéÁ®ã‰∏≠ÁôºÁîüÈåØË™§:', error);
                    }
                }

                renderVisibleChunks() {
                    const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                    const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                    const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                    let renderedChunks = 0;
                    let skippedChunks = 0;

                    // ÂæûÁé©ÂÆ∂‰ΩçÁΩÆÂêëÂ§ñÊ∏≤ÊüìÔºåÁ¢∫‰øùËøëËôïÂÑ™ÂÖà
                    for (let radius = 0; radius <= renderChunkDistance; radius++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dz = -radius; dz <= radius; dz++) {
                                if (Math.abs(dx) !== radius && Math.abs(dz) !== radius) continue;

                                const chunkX = playerChunkX + dx;
                                const chunkZ = playerChunkZ + dz;

                                // ÈÇäÁïåÊ™¢Êü•
                                if (chunkX < 0 || chunkZ < 0 ||
                                    chunkX >= Math.ceil(this.worldSize / 16) ||
                                    chunkZ >= Math.ceil(this.worldSize / 16)) continue;

                                const chunkKey = `${chunkX},${chunkZ}`;
                                const mesh = this.chunkMeshes.get(chunkKey);

                                if (!mesh || mesh.indexCount === 0) {
                                    skippedChunks++;
                                    continue;
                                }

                                this.renderChunk(chunkX, chunkZ);
                                renderedChunks++;
                            }
                        }
                    }

                    // Êõ¥Êñ∞Ë™øË©¶‰ø°ÊÅØ
                    if (this.frameCount % 60 === 0) {
                        console.log(`Ê∏≤ÊüìÁµ±Ë®à: ${renderedChunks} ÂÄãÂçÄÂ°ä, Ë∑≥ÈÅé: ${skippedChunks} ÂÄã`);
                    }
                }

                renderChunk(chunkX, chunkZ) {
                    const chunkKey = `${chunkX},${chunkZ}`;
                    const mesh = this.chunkMeshes.get(chunkKey);

                    if (!mesh || mesh.indexCount === 0) {
                        return;
                    }

                    if (!this.gl.getParameter(this.gl.DEPTH_TEST)) {
                        this.gl.enable(this.gl.DEPTH_TEST);
                    }

                    if (this.gl.isContextLost()) {
                        console.error('WebGL‰∏ä‰∏ãÊñá‰∏üÂ§±');
                        return;
                    }

                    try {
                        // Á∂ÅÂÆöÈ†ÇÈªûÊï∏Êìö
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.vertices, this.gl.STATIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.position);
                        this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                        // Á∂ÅÂÆöÈ°èËâ≤Êï∏Êìö
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.colors, this.gl.STATIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.color);
                        this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                        // Á∂ÅÂÆöÊ≥ïÁ∑öÊï∏Êìö
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.normals, this.gl.STATIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.normal);
                        this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                        // Á∂ÅÂÆöÈÄèÊòéÂ∫¶Êï∏Êìö
                        if (mesh.alphas && this.attributes.alpha !== -1) {
                            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.alpha);
                            this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.alphas, this.gl.STATIC_DRAW);
                            this.gl.enableVertexAttribArray(this.attributes.alpha);
                            this.gl.vertexAttribPointer(this.attributes.alpha, 1, this.gl.FLOAT, false, 0, 0);
                        }

                        // Á∂ÅÂÆöÁ¥¢ÂºïÊï∏Êìö
                        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices, this.gl.STATIC_DRAW);

                        const error = this.gl.getError();
                        if (error !== this.gl.NO_ERROR) {
                            console.error(`WebGLÈåØË™§: ${error}`);
                            return;
                        }

                        // Áπ™Ë£Ω
                        this.gl.drawElements(this.gl.TRIANGLES, mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);

                        this.triangleCount += mesh.indexCount / 3;
                        this.vertexCount += mesh.vertexCount;
                        this.drawCalls++;

                    } catch (error) {
                        console.error(`Ê∏≤ÊüìÂçÄÂ°ä ${chunkKey} ÊôÇÁôºÁîüÈåØË™§:`, error);
                    }
                }

                // Ê∏≤ÊüìÂÖ∂‰ªñÁé©ÂÆ∂
                // Ê∏≤ÊüìÂÖ∂‰ªñÁé©ÂÆ∂
                renderOtherPlayers() {
                    if (!this.isMultiplayer) return;

                    // Ê∏ÖÁêÜÂ∑≤Èõ¢ÈñãÁé©ÂÆ∂ÁöÑÂêçÁâå
                    this.cleanupPlayerNameTags();

                    this.otherPlayers.forEach((player, playerId) => {
                        try {
                            this.renderPlayer(player);
                            this.renderPlayerNameTag(player);
                        } catch (error) {
                            console.error(`Ê∏≤ÊüìÁé©ÂÆ∂ ${playerId} ÊôÇÁôºÁîüÈåØË™§:`, error);
                        }
                    });
                }

                // Ê∏≤ÊüìÂñÆÂÄãÁé©ÂÆ∂ÔºàÁ∞°ÂñÆÁöÑÊñπÂ°äË°®Á§∫Ôºâ
                renderPlayer(player) {
                    // ÂâµÂª∫Á∞°ÂñÆÁöÑÁé©ÂÆ∂Ê®°ÂûãÔºà2x1x1ÁöÑÊñπÂ°äÔºâ
                    const vertices = new Float32Array([
                        // ‰∏ãÂçäË∫´ÊñπÂ°ä
                        player.x - 0.3, player.y, player.z - 0.3,
                        player.x + 0.3, player.y, player.z - 0.3,
                        player.x + 0.3, player.y + 1, player.z - 0.3,
                        player.x - 0.3, player.y + 1, player.z - 0.3,

                        player.x - 0.3, player.y, player.z + 0.3,
                        player.x + 0.3, player.y, player.z + 0.3,
                        player.x + 0.3, player.y + 1, player.z + 0.3,
                        player.x - 0.3, player.y + 1, player.z + 0.3,

                        // ‰∏äÂçäË∫´ÊñπÂ°äÔºàÈ†≠ÈÉ®Ôºâ
                        player.x - 0.25, player.y + 1, player.z - 0.25,
                        player.x + 0.25, player.y + 1, player.z - 0.25,
                        player.x + 0.25, player.y + 1.8, player.z - 0.25,
                        player.x - 0.25, player.y + 1.8, player.z - 0.25,

                        player.x - 0.25, player.y + 1, player.z + 0.25,
                        player.x + 0.25, player.y + 1, player.z + 0.25,
                        player.x + 0.25, player.y + 1.8, player.z + 0.25,
                        player.x - 0.25, player.y + 1.8, player.z + 0.25
                    ]);

                    const colors = new Float32Array([
                        // ‰∏ãÂçäË∫´È°èËâ≤ÔºàËóçËâ≤Ôºâ
                        0.2, 0.2, 0.8, 0.2, 0.2, 0.8, 0.2, 0.2, 0.8, 0.2, 0.2, 0.8,
                        0.2, 0.2, 0.8, 0.2, 0.2, 0.8, 0.2, 0.2, 0.8, 0.2, 0.2, 0.8,
                        // ‰∏äÂçäË∫´È°èËâ≤ÔºàËÜöËâ≤Ôºâ
                        0.9, 0.7, 0.6, 0.9, 0.7, 0.6, 0.9, 0.7, 0.6, 0.9, 0.7, 0.6,
                        0.9, 0.7, 0.6, 0.9, 0.7, 0.6, 0.9, 0.7, 0.6, 0.9, 0.7, 0.6
                    ]);

                    const indices = new Uint16Array([
                        // ‰∏ãÂçäË∫´Á´ãÊñπÈ´îÁöÑÈù¢
                        0, 1, 2, 0, 2, 3, // ÂâçÈù¢
                        4, 7, 6, 4, 6, 5, // ÂæåÈù¢
                        0, 4, 5, 0, 5, 1, // Â∫ïÈù¢
                        2, 6, 7, 2, 7, 3, // È†ÇÈù¢
                        0, 3, 7, 0, 7, 4, // Â∑¶Èù¢
                        1, 5, 6, 1, 6, 2, // Âè≥Èù¢

                        // ‰∏äÂçäË∫´Á´ãÊñπÈ´îÁöÑÈù¢
                        8, 9, 10, 8, 10, 11, // ÂâçÈù¢
                        12, 15, 14, 12, 14, 13, // ÂæåÈù¢
                        8, 12, 13, 8, 13, 9, // Â∫ïÈù¢
                        10, 14, 15, 10, 15, 11, // È†ÇÈù¢
                        8, 11, 15, 8, 15, 12, // Â∑¶Èù¢
                        9, 13, 14, 9, 14, 10 // Âè≥Èù¢
                    ]);

                    try {
                        // Á∂ÅÂÆö‰∏¶Ê∏≤ÊüìÁé©ÂÆ∂Ê®°Âûã
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.position);
                        this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.DYNAMIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.color);
                        this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.DYNAMIC_DRAW);

                        this.gl.drawElements(this.gl.TRIANGLES, indices.length, this.gl.UNSIGNED_SHORT, 0);

                        this.drawCalls++;
                    } catch (error) {
                        console.error('Ê∏≤ÊüìÁé©ÂÆ∂ÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }

                // Ê∏ÖÁêÜÂ∑≤Èõ¢ÈñãÁé©ÂÆ∂ÁöÑÂêçÁâå
                cleanupPlayerNameTags() {
                    const nameTagContainer = document.getElementById('playerNameTags');
                    if (!nameTagContainer) return;

                    const existingTags = nameTagContainer.querySelectorAll('.player-nametag');
                    existingTags.forEach(tag => {
                        const playerId = tag.id.replace('nametag-', '');
                        if (!this.otherPlayers.has(playerId)) {
                            tag.remove();
                        }
                    });
                }

                // Ê∏≤ÊüìÁé©ÂÆ∂ÂêçÁâå
                renderPlayerNameTag(player) {
                    // Â∞á3DÂ∫ßÊ®ôËΩâÊèõÁÇ∫Ëû¢ÂπïÂ∫ßÊ®ô
                    const screenPos = this.worldToScreen(player.x, player.y + 2.2, player.z);

                    if (screenPos && screenPos.z > 0 && screenPos.z < 1) {
                        // Ê™¢Êü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂêçÁâå
                        let nameTag = document.getElementById(`nametag-${player.id}`);

                        if (!nameTag) {
                            nameTag = document.createElement('div');
                            nameTag.id = `nametag-${player.id}`;
                            nameTag.className = 'player-nametag';
                            nameTag.textContent = player.name;
                            document.getElementById('playerNameTags').appendChild(nameTag);
                        }

                        // Êõ¥Êñ∞‰ΩçÁΩÆ
                        nameTag.style.left = screenPos.x + 'px';
                        nameTag.style.top = screenPos.y + 'px';
                        nameTag.style.display = 'block';

                        // Ê†πÊìöË∑ùÈõ¢Ë™øÊï¥ÈÄèÊòéÂ∫¶
                        const distance = Math.sqrt(
                            Math.pow(player.x - this.player.x, 2) +
                            Math.pow(player.z - this.player.z, 2)
                        );
                        const opacity = Math.max(0.3, Math.min(1.0, 1.0 - distance / 50));
                        nameTag.style.opacity = opacity;

                    } else {
                        // Èö±Ëóè‰∏çÂèØË¶ãÁöÑÂêçÁâå
                        const nameTag = document.getElementById(`nametag-${player.id}`);
                        if (nameTag) {
                            nameTag.style.display = 'none';
                        }
                    }
                }

                // ‰∏ñÁïåÂ∫ßÊ®ôËΩâËû¢ÂπïÂ∫ßÊ®ô
                worldToScreen(worldX, worldY, worldZ) {
                    try {
                        // ÂâµÂª∫‰∏ñÁïåÂ∫ßÊ®ôÂêëÈáè
                        const worldPos = [worldX, worldY, worldZ, 1];

                        // ÊáâÁî®Ë¶ñÂúñÂíåÊäïÂΩ±ËÆäÊèõ
                        const viewPos = this.multiplyMatrixVector(this.viewMatrix, worldPos);
                        const clipPos = this.multiplyMatrixVector(this.projectionMatrix, viewPos);

                        // ÈÄèË¶ñÈô§Ê≥ï
                        if (Math.abs(clipPos[3]) < 0.0001) return null;

                        const ndcX = clipPos[0] / clipPos[3];
                        const ndcY = clipPos[1] / clipPos[3];
                        const ndcZ = clipPos[2] / clipPos[3];

                        // Ê™¢Êü•ÊòØÂê¶Âú®Ë¶ñÈåêÂÖß
                        if (ndcZ < -1 || ndcZ > 1 || Math.abs(ndcX) > 1 || Math.abs(ndcY) > 1) {
                            return null;
                        }

                        // ËΩâÊèõÁÇ∫Ëû¢ÂπïÂ∫ßÊ®ô
                        const screenX = (ndcX + 1) * 0.5 * this.canvas.width;
                        const screenY = (1 - ndcY) * 0.5 * this.canvas.height;

                        return {
                            x: screenX,
                            y: screenY,
                            z: ndcZ
                        };
                    } catch (error) {
                        console.error('Â∫ßÊ®ôËΩâÊèõÈåØË™§:', error);
                        return null;
                    }
                }

                // Áü©Èô£ÂêëÈáè‰πòÊ≥ï
                multiplyMatrixVector(matrix, vector) {
                    const result = [0, 0, 0, 0];
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            result[i] += matrix[i * 4 + j] * vector[j];
                        }
                    }
                    return result;
                }

                // Ê∏≤ÊüìÁé©ÂÆ∂ÂêçÁâå
                // Ê∏≤ÊüìÂñÆÂÄãÁé©ÂÆ∂ÔºàMinecraft SteveÈ¢®Ê†ºÔºâ
                renderPlayer(player) {
                    // SteveÊ®°ÂûãÁöÑÂü∫Êú¨Â∞∫ÂØ∏
                    const headSize = 0.5;
                    const bodyWidth = 0.5;
                    const bodyHeight = 0.75;
                    const limbSize = 0.25;

                    // ÂâµÂª∫SteveÊ®°ÂûãÁöÑÂêÑÈÉ®ÂàÜ
                    const parts = [
                        // È†≠ÈÉ®
                        { pos: [player.x, player.y + 1.75, player.z], size: [headSize, headSize, headSize], color: [0.9, 0.7, 0.6] },
                        // Ë∫´È´î
                        { pos: [player.x, player.y + 1.125, player.z], size: [bodyWidth, bodyHeight, 0.25], color: [0.2, 0.2, 0.8] },
                        // Â∑¶ËáÇ
                        { pos: [player.x - 0.375, player.y + 1.125, player.z], size: [limbSize, bodyHeight, 0.25], color: [0.9, 0.7, 0.6] },
                        // Âè≥ËáÇ
                        { pos: [player.x + 0.375, player.y + 1.125, player.z], size: [limbSize, bodyHeight, 0.25], color: [0.9, 0.7, 0.6] },
                        // Â∑¶ËÖø
                        { pos: [player.x - 0.125, player.y + 0.375, player.z], size: [limbSize, bodyHeight, 0.25], color: [0.1, 0.1, 0.6] },
                        // Âè≥ËÖø
                        { pos: [player.x + 0.125, player.y + 0.375, player.z], size: [limbSize, bodyHeight, 0.25], color: [0.1, 0.1, 0.6] }
                    ];

                    const vertices = [];
                    const colors = [];
                    const indices = [];
                    let indexOffset = 0;

                    // ÁÇ∫ÊØèÂÄãÈÉ®ÂàÜÂâµÂª∫Á´ãÊñπÈ´î
                    parts.forEach(part => {
                        const cubeVertices = this.createCube(
                            part.pos[0] - part.size[0] / 2,
                            part.pos[1] - part.size[1] / 2,
                            part.pos[2] - part.size[2] / 2,
                            part.size[0], part.size[1], part.size[2]
                        );

                        vertices.push(...cubeVertices);

                        // ÁÇ∫ÊØèÂÄãÈ†ÇÈªûÊ∑ªÂä†È°èËâ≤ÔºàÊØèÂÄãÁ´ãÊñπÈ´î24ÂÄãÈ†ÇÈªûÔºâ
                        for (let i = 0; i < 24; i++) {
                            colors.push(...part.color);
                        }

                        // Ê∑ªÂä†Á¥¢ÂºïÔºàÊØèÂÄãÁ´ãÊñπÈ´î6ÂÄãÈù¢ÔºåÊØèÈù¢2ÂÄã‰∏âËßíÂΩ¢Ôºâ
                        for (let i = 0; i < 6; i++) {
                            const faceStart = indexOffset + i * 4;
                            indices.push(
                                faceStart, faceStart + 1, faceStart + 2,
                                faceStart, faceStart + 2, faceStart + 3
                            );
                        }
                        indexOffset += 24;
                    });

                    try {
                        // Ê∏≤ÊüìSteveÊ®°Âûã
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.position);
                        this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.color);
                        this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                        // ÂâµÂª∫Ê≥ïÁ∑öÊï∏ÊìöÔºàÁ∞°ÂñÆÂêë‰∏äÔºâ
                        const normals = [];
                        for (let i = 0; i < vertices.length / 3; i++) {
                            normals.push(0, 1, 0);
                        }

                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.normal);
                        this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.DYNAMIC_DRAW);

                        this.gl.drawElements(this.gl.TRIANGLES, indices.length, this.gl.UNSIGNED_SHORT, 0);

                        this.drawCalls++;
                    } catch (error) {
                        console.error('Ê∏≤ÊüìÁé©ÂÆ∂ÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }

                // ÂâµÂª∫Á´ãÊñπÈ´îÈ†ÇÈªûÁöÑËºîÂä©ÊñπÊ≥ï
                createCube(x, y, z, width, height, depth) {
                    return [
                        // ÂâçÈù¢
                        x, y, z + depth,
                        x + width, y, z + depth,
                        x + width, y + height, z + depth,
                        x, y + height, z + depth,

                        // ÂæåÈù¢
                        x + width, y, z,
                        x, y, z,
                        x, y + height, z,
                        x + width, y + height, z,

                        // Â∑¶Èù¢
                        x, y, z,
                        x, y, z + depth,
                        x, y + height, z + depth,
                        x, y + height, z,

                        // Âè≥Èù¢
                        x + width, y, z + depth,
                        x + width, y, z,
                        x + width, y + height, z,
                        x + width, y + height, z + depth,

                        // ‰∏äÈù¢
                        x, y + height, z + depth,
                        x + width, y + height, z + depth,
                        x + width, y + height, z,
                        x, y + height, z,

                        // ‰∏ãÈù¢
                        x, y, z,
                        x + width, y, z,
                        x + width, y, z + depth,
                        x, y, z + depth
                    ];
                }

                // ‰∏ñÁïåÂ∫ßÊ®ôËΩâËû¢ÂπïÂ∫ßÊ®ô
                worldToScreen(worldX, worldY, worldZ) {
                    // ÂâµÂª∫‰∏ñÁïåÂ∫ßÊ®ôÂêëÈáè
                    const worldPos = [worldX, worldY, worldZ, 1];

                    // ÊáâÁî®Ë¶ñÂúñÂíåÊäïÂΩ±ËÆäÊèõ
                    const viewPos = this.multiplyMatrixVector(this.viewMatrix, worldPos);
                    const clipPos = this.multiplyMatrixVector(this.projectionMatrix, viewPos);

                    // ÈÄèË¶ñÈô§Ê≥ï
                    if (clipPos[3] === 0) return null;

                    const ndcX = clipPos[0] / clipPos[3];
                    const ndcY = clipPos[1] / clipPos[3];
                    const ndcZ = clipPos[2] / clipPos[3];

                    // ËΩâÊèõÁÇ∫Ëû¢ÂπïÂ∫ßÊ®ô
                    const screenX = (ndcX + 1) * 0.5 * this.canvas.width;
                    const screenY = (1 - ndcY) * 0.5 * this.canvas.height;

                    return {
                        x: screenX,
                        y: screenY,
                        z: ndcZ
                    };
                }

                // Áü©Èô£ÂêëÈáè‰πòÊ≥ï
                multiplyMatrixVector(matrix, vector) {
                    const result = [0, 0, 0, 0];
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            result[i] += matrix[i * 4 + j] * vector[j];
                        }
                    }
                    return result;
                }

                updatePlayer() {
                    if (!this.gameStarted || !this.worldGenerated || this.isPaused) return;

                    const speed = 0.15;
                    const sprintMultiplier = this.keys['ShiftLeft'] && !this.flying ? 0.5 : (this.keys['ControlLeft'] ? 2 : 1);
                    const moveSpeed = speed * sprintMultiplier;

                    // ÁßªÂãïË®àÁÆó
                    let moveX = 0, moveZ = 0;

                    if (this.keys['KeyW']) {
                        moveX += Math.cos(this.player.angle) * moveSpeed;
                        moveZ += Math.sin(this.player.angle) * moveSpeed;
                    }
                    if (this.keys['KeyS']) {
                        moveX -= Math.cos(this.player.angle) * moveSpeed;
                        moveZ -= Math.sin(this.player.angle) * moveSpeed;
                    }
                    if (this.keys['KeyA']) {
                        moveX += Math.cos(this.player.angle - Math.PI / 2) * moveSpeed;
                        moveZ += Math.sin(this.player.angle - Math.PI / 2) * moveSpeed;
                    }
                    if (this.keys['KeyD']) {
                        moveX += Math.cos(this.player.angle + Math.PI / 2) * moveSpeed;
                        moveZ += Math.sin(this.player.angle + Math.PI / 2) * moveSpeed;
                    }

                    // Á¢∞ÊíûÊ™¢Ê∏¨
                    const newX = this.player.x + moveX;
                    const newZ = this.player.z + moveZ;

                    if (!this.checkCollision(newX, this.player.y, this.player.z)) {
                        this.player.x = newX;
                    }
                    if (!this.checkCollision(this.player.x, this.player.y, newZ)) {
                        this.player.z = newZ;
                    }

                    // È£õË°åÊ®°Âºè
                    if (this.flying) {
                        if (this.keys['Space']) this.player.y += moveSpeed;
                        if (this.keys['ShiftLeft']) this.player.y -= moveSpeed;
                        this.player.velocity.y = 0;
                        this.player.onGround = false;
                    } else {
                        // ÈáçÂäõÂíåË∑≥Ë∫ç
                        this.player.velocity.y += this.gravity;

                        if (this.keys['Space'] && this.player.onGround) {
                            this.player.velocity.y = this.jumpPower;
                            this.player.onGround = false;
                        }

                        // ÂûÇÁõ¥ÁßªÂãï
                        const newY = this.player.y + this.player.velocity.y;
                        if (!this.checkCollision(this.player.x, newY, this.player.z)) {
                            this.player.y = newY;
                            this.player.onGround = false;
                        } else {
                            if (this.player.velocity.y < 0) {
                                this.player.onGround = true;
                            }
                            this.player.velocity.y = 0;
                        }
                    }

                    // Â§ö‰∫∫ÈÅäÊà≤‰ΩçÁΩÆÂêåÊ≠•
                    if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                        // ÊØèÈöîÂπæÂπÄÁôºÈÄÅ‰∏ÄÊ¨°‰ΩçÁΩÆÊõ¥Êñ∞
                        if (this.frameCount % 5 === 0) {
                            this.multiplayerManager.sendPlayerUpdate({
                                x: this.player.x,
                                y: this.player.y,
                                z: this.player.z,
                                angle: this.player.angle,
                                pitch: this.player.pitch
                            });
                        }
                    }
                }

                updateUI() {
                    document.getElementById('position').textContent =
                        `${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)}`;
                    document.getElementById('direction').textContent =
                        `${(this.player.angle * 180 / Math.PI).toFixed(0)}¬∞`;

                    const blockStats = this.getBlockStatistics();
                    document.getElementById('blockCount').textContent =
                        `${this.world.size} (${Object.keys(blockStats).length}Á®Æ)`;

                    // È°ØÁ§∫Áï∂ÂâçÈÅ∏‰∏≠ÊñπÂ°äÁöÑÈÄèÊòéÂ∫¶‰ø°ÊÅØ
                    const currentBlock = this.blockTypes[this.selectedBlock];
                    const transparentInfo = currentBlock?.transparent ? ` Œ±:${(currentBlock.alpha || 1).toFixed(1)}` : '';
                    document.getElementById('renderInfo').textContent =
                        `WebGL ${this.flying ? '(È£õË°å)' : '(ÁîüÂ≠ò)'} ${this.isMultiplayer ? '(Â§ö‰∫∫)' : '(ÂñÆ‰∫∫)'}${transparentInfo}`;

                    const biome = this.getBiome(this.player.x, this.player.z);
                    document.getElementById('biome').textContent = biome;

                    document.getElementById('triangleCount').textContent = this.triangleCount;
                    document.getElementById('vertexCount').textContent = this.vertexCount;
                    document.getElementById('drawCalls').textContent = this.drawCalls;

                    if (this.frameCount % 300 === 0) { // ÊØè5ÁßíË®òÈåÑ‰∏ÄÊ¨°
                        const instructionsVisible = document.getElementById('instructions').style.display !== 'none';
                        console.log(`ÈÅ∏ÂñÆÁãÄÊÖã: ${instructionsVisible ? 'È°ØÁ§∫' : 'Èö±Ëóè'}, ÈÅäÊà≤ÁãÄÊÖã: ${this.gameStarted ? 'ÈÄ≤Ë°å‰∏≠' : 'Êú™ÈñãÂßã'}`);
                    }

                    if (this.isMultiplayer) {
                        const otherPlayerCount = this.otherPlayers.size;
                        if (this.frameCount % 300 === 0) {
                            console.log(`ÂÖ∂‰ªñÁé©ÂÆ∂Êï∏Èáè: ${otherPlayerCount}`);
                        }
                    }
                }

                // Áç≤ÂèñÊñπÂ°äÁµ±Ë®à
                getBlockStatistics() {
                    const stats = {};
                    this.world.forEach((blockType) => {
                        stats[blockType] = (stats[blockType] || 0) + 1;
                    });
                    return stats;
                }

                getBiome(x, z) {
                    // ‰ΩøÁî®Ëàá‰∏ñÁïåÁîüÊàêÁõ∏ÂêåÁöÑÈÇèËºØ
                    const nx = x / this.worldSize;
                    const nz = z / this.worldSize;

                    const temperature = this.improvedNoise(nx * 2.5, nz * 2.5);
                    const humidity = this.improvedNoise(nx * 3.1 + 100, nz * 3.1 + 100);

                    if (temperature > 0.3 && humidity < -0.2) {
                        return 'Ê≤ôÊº†';
                    } else if (temperature < -0.3) {
                        return 'Èõ™Âú∞';
                    } else if (humidity > 0.4) {
                        return 'Ê£ÆÊûó';
                    } else if (temperature > 0.1 && humidity > 0.1) {
                        return 'Âè¢Êûó';
                    } else {
                        return 'Âπ≥Âéü';
                    }
                }

                updateMinimap() {
                    this.minimapCtx.fillStyle = '#000';
                    this.minimapCtx.fillRect(0, 0, 180, 180);

                    const mapRange = 20;
                    const scale = 180 / (mapRange * 2);

                    // Áπ™Ë£ΩÂú∞ÂΩ¢
                    for (let x = -mapRange; x <= mapRange; x++) {
                        for (let z = -mapRange; z <= mapRange; z++) {
                            const worldX = Math.floor(this.player.x) + x;
                            const worldZ = Math.floor(this.player.z) + z;
                            const height = this.getHighestBlock(worldX, worldZ);

                            if (height > -10) {
                                const brightness = Math.max(0, Math.min(1, (height + 5) / 15));
                                this.minimapCtx.fillStyle = `rgb(${Math.floor(76 * brightness)}, ${Math.floor(175 * brightness)}, ${Math.floor(80 * brightness)})`;
                                this.minimapCtx.fillRect(
                                    90 + x * scale - scale / 2,
                                    90 + z * scale - scale / 2,
                                    scale, scale
                                );
                            }
                        }
                    }

                    // Áπ™Ë£ΩÂÖ∂‰ªñÁé©ÂÆ∂ÔºàÂ§ö‰∫∫Ê®°ÂºèÔºâ
                    if (this.isMultiplayer) {
                        this.otherPlayers.forEach(player => {
                            const relativeX = player.x - this.player.x;
                            const relativeZ = player.z - this.player.z;

                            if (Math.abs(relativeX) <= mapRange && Math.abs(relativeZ) <= mapRange) {
                                this.minimapCtx.fillStyle = '#ff4444';
                                this.minimapCtx.fillRect(
                                    90 + relativeX * scale - 2,
                                    90 + relativeZ * scale - 2,
                                    4, 4
                                );
                            }
                        });
                    }

                    // Áπ™Ë£ΩÁé©ÂÆ∂‰ΩçÁΩÆ
                    this.minimapCtx.fillStyle = '#00ff88';
                    this.minimapCtx.fillRect(88, 88, 4, 4);

                    // Áπ™Ë£ΩÊñπÂêëÊåáÁ§∫Âô®
                    this.minimapCtx.strokeStyle = '#00ff88';
                    this.minimapCtx.lineWidth = 2;
                    this.minimapCtx.beginPath();
                    this.minimapCtx.moveTo(90, 90);
                    this.minimapCtx.lineTo(
                        90 + Math.cos(this.player.angle) * 15,
                        90 + Math.sin(this.player.angle) * 15
                    );
                    this.minimapCtx.stroke();
                }

                update(currentTime) {
                    // Ë®àÁÆóFPS
                    if (this.lastFrameTime) {
                        const deltaTime = currentTime - this.lastFrameTime;
                        this.frameCount++;

                        if (this.frameCount % 60 === 0) {
                            this.fps = Math.round(1000 / deltaTime);
                            document.getElementById('fpsCounter').textContent = this.fps;
                        }
                    }
                    this.lastFrameTime = currentTime;

                    // Êõ¥Êñ∞ÈÅäÊà≤ÈÇèËºØ
                    this.updatePlayer();
                    this.updateUI();
                    this.updateMinimap();
                }

                gameLoop() {
                    const currentTime = performance.now();

                    this.update(currentTime);
                    this.render();

                    requestAnimationFrame(() => this.gameLoop());
                }

                // ÂàáÊèõÂÖ®Ëû¢ÂπïÊ®°Âºè
                toggleFullscreen() {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().then(() => {
                            console.log('ÈÄ≤ÂÖ•ÂÖ®Ëû¢ÂπïÊ®°Âºè');
                            if (this.isMultiplayer) {
                                this.chatSystem.addSystemMessage('Â∑≤ÈÄ≤ÂÖ•ÂÖ®Ëû¢ÂπïÊ®°Âºè');
                            }
                        }).catch(err => {
                            console.error('ÁÑ°Ê≥ïÈÄ≤ÂÖ•ÂÖ®Ëû¢ÂπïÊ®°Âºè:', err);
                        });
                    } else {
                        document.exitFullscreen().then(() => {
                            console.log('ÈÄÄÂá∫ÂÖ®Ëû¢ÂπïÊ®°Âºè');
                            if (this.isMultiplayer) {
                                this.chatSystem.addSystemMessage('Â∑≤ÈÄÄÂá∫ÂÖ®Ëû¢ÂπïÊ®°Âºè');
                            }
                        }).catch(err => {
                            console.error('ÁÑ°Ê≥ïÈÄÄÂá∫ÂÖ®Ëû¢ÂπïÊ®°Âºè:', err);
                        });
                    }
                }
            } // WebGLMinecraft È°ûÂà•ÁµêÊùü

            // ÂïüÂãïÈÅäÊà≤
            window.addEventListener('load', () => {
                // Ê™¢Êü•WebGLÊîØÊè¥
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!gl) {
                    document.body.innerHTML = `
            <div class="error-message">
                <h3>‚ùå WebGL ‰∏çÊîØÊè¥</h3>
                <p>ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥WebGLÔºåÁÑ°Ê≥ïÈÅãË°åÊ≠§ÈÅäÊà≤„ÄÇ</p>
                <p>Ë´ãÂòóË©¶‰ΩøÁî®Áèæ‰ª£ÁÄèË¶ΩÂô®Â¶ÇChrome„ÄÅFirefoxÊàñEdge„ÄÇ</p>
                <button onclick="location.reload()">ÈáçÊñ∞Ê™¢Ê∏¨</button>
            </div>
        `;
                    return;
                }

                try {
                    new WebGLMinecraft();
                    console.log('üéÆ WebGL Minecraft Â§ö‰∫∫ÁâàÂ∑≤ÂïüÂãïÔºÅ');
                    console.log('üìã ÂäüËÉΩÂàóË°®:');
                    console.log('  ‚úÖ ESCÈçµÊö´ÂÅú/ÊÅ¢Âæ©');
                    console.log('  ‚úÖ Â§ö‰∫∫ÈÅäÊà≤ÊîØÊè¥');
                    console.log('  ‚úÖ ËÅäÂ§©Á≥ªÁµ± (TÈçµ)');
                    console.log('  ‚úÖ Áé©ÂÆ∂ÂêçÁâåÈ°ØÁ§∫');
                    console.log('  ‚úÖ ÊàøÈñìÁ≥ªÁµ±');
                    console.log('  ‚úÖ ÂØ¶ÊôÇÂêåÊ≠•');
                } catch (error) {
                    console.error('ÈÅäÊà≤ÂïüÂãïÂ§±Êïó:', error);
                    document.body.innerHTML = `
            <div class="error-message">
                <h3>‚ùå ÂïüÂãïÂ§±Êïó</h3>
                <p>ÈÅäÊà≤ÂïüÂãïÊôÇÁôºÁîüÈåØË™§: ${error.message}</p>
                <button onclick="location.reload()">ÈáçÊñ∞ÂïüÂãï</button>
            </div>
        `;
                }
            });

            // Ê∑ªÂä†‰∏Ä‰∫õÂØ¶Áî®ÁöÑÂÖ®ÂüüÂáΩÊï∏
            window.toggleFullscreen = function () {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            };

            // ÊÄßËÉΩÁõ£Êéß
            window.addEventListener('beforeunload', () => {
                console.log('ÈÅäÊà≤ÊúÉË©±ÁµêÊùü');
            });

            // ËôïÁêÜÈ†ÅÈù¢ÂèØË¶ãÊÄßËÆäÂåñ
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('ÈÅäÊà≤Êö´ÂÅú');
                } else {
                    console.log('ÈÅäÊà≤ÊÅ¢Âæ©');
                }
            });

        </script>
    </body>

</html>
