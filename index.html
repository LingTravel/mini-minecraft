<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minecraft WebGL - å®Œç¾ç‰ˆ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');

        :root {
            /* æ©˜è‰²ä¸»é¡Œè‰²å½©ç³»çµ± */
            --primary: #FF6B35;
            --primary-dark: #E55A2B;
            --primary-light: #FF8A5B;
            --secondary: #FFA500;
            --accent: #FFB84D;

            /* èƒŒæ™¯è‰²å½© */
            --bg-primary: #0A0A0A;
            --bg-secondary: #1A1A1A;
            --bg-tertiary: #2A2A2A;
            --bg-glass: rgba(255, 107, 53, 0.08);
            --bg-glass-hover: rgba(255, 107, 53, 0.15);

            /* æ–‡å­—è‰²å½© */
            --text-primary: #FFFFFF;
            --text-secondary: #CCCCCC;
            --text-muted: #888888;
            --text-accent: var(--primary);

            /* é‚Šæ¡†å’Œé™°å½± */
            --border: rgba(255, 107, 53, 0.2);
            --border-hover: rgba(255, 107, 53, 0.4);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 12px 48px rgba(255, 107, 53, 0.2);

            /* ç»ç’ƒæ•ˆæœ */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            overflow: hidden;
            user-select: none;
            color: var(--text-primary);
            font-weight: 400;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* éŠæˆ²å®¹å™¨ */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 100%);
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            width: 100%;
            height: 100%;
        }

        /* æº–æ˜Ÿ - æ›´ç²¾ç·»çš„è¨­è¨ˆ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 107, 53, 0.3);
            border-radius: 1px;
        }

        #crosshair::before {
            width: 2px;
            height: 12px;
            left: 9px;
            top: 4px;
        }

        #crosshair::after {
            width: 12px;
            height: 2px;
            left: 4px;
            top: 9px;
        }

        /* ç°¡åŒ–çš„éŠæˆ²UI - åªä¿ç•™å¿…è¦ä¿¡æ¯ */
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 300px;
        }

        .ui-panel {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px 20px;
            box-shadow: var(--shadow);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ui-panel:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-hover);
            background: var(--bg-glass-hover);
        }

        .ui-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 14px;
            font-weight: 400;
        }

        .ui-row:last-child {
            margin-bottom: 0;
        }

        .ui-label {
            color: var(--text-secondary);
            margin-right: 12px;
            font-weight: 400;
        }

        .ui-value {
            color: var(--text-accent);
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        /* é‡æ–°è¨­è¨ˆçš„ç‰©å“æ¬„ - æ›´å…·ç¾æ„Ÿ */
        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            padding: 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        #inventory::-webkit-scrollbar {
            display: none;
        }

        .inventory-slot {
            width: 52px;
            height: 52px;
            border: 2px solid var(--border);
            background: var(--bg-glass);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-weight: 500;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, var(--bg-glass-hover), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .inventory-slot:hover::before {
            transform: translateX(100%);
        }

        .inventory-slot:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
            background: var(--bg-glass-hover);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.25);
        }

        .inventory-slot.active {
            border-color: var(--primary);
            background: var(--bg-glass-hover);
            box-shadow: 0 0 16px rgba(255, 107, 53, 0.4);
            transform: translateY(-2px);
        }

        .inventory-slot .block-icon {
            font-size: 20px;
            margin-bottom: 2px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .inventory-slot .block-name {
            font-size: 8px;
            opacity: 0.8;
            text-align: center;
            font-weight: 400;
            line-height: 1.1;
        }

        /* å®Œå…¨é‡å¯«çš„Minecraft Javaç‰ˆèŠå¤©ç³»çµ± */
        #chatSystem {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 320px;
            z-index: 200;
            pointer-events: none;
            font-family: 'Minecraft', 'JetBrains Mono', monospace;
        }

        #chatMessages {
            max-height: 160px;
            overflow-y: auto;
            /* ä¿®æ”¹ç‚ºautoï¼Œå…è¨±æ»¾å‹• */
            margin-bottom: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 0;
            pointer-events: none;
            /* é»˜èªä¸æ¥æ”¶æ»‘é¼ äº‹ä»¶ */
        }

        #chatMessages.visible {
            opacity: 1;
            pointer-events: auto;
            /* å¯è¦‹æ™‚æ¥æ”¶æ»‘é¼ äº‹ä»¶ï¼Œå…è¨±æ»¾å‹• */
        }

        #chatSystem.active {
            pointer-events: auto;
            /* èŠå¤©æ¿€æ´»æ™‚æ¥æ”¶æ»‘é¼ äº‹ä»¶ */
        }


        .chat-message {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 1px 4px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            animation: slideInLeft 0.2s ease;
            word-wrap: break-word;
            line-height: 1.2;
            max-width: 100%;
            white-space: pre-wrap;
            margin: 0;
            border: none;
        }

        /* Minecraft Javaç‰ˆèŠå¤©é¡è‰²ç³»çµ± */
        .chat-message.system {
            color: #FFFF55;
        }

        .chat-message.player {
            color: #FFFFFF;
        }

        .chat-message.error {
            color: #FF5555;
        }

        .chat-message.command {
            color: #55FFFF;
        }

        .chat-message.info {
            color: #55FF55;
        }

        .chat-message.warning {
            color: #FFAA00;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-5px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #chatInput {
            display: none;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 0;
            pointer-events: auto;
            /* å§‹çµ‚æ¥æ”¶æ»‘é¼ äº‹ä»¶ */
            position: relative;
            height: 20px;
        }

        #chatInput.active {
            display: block;
        }

        #messageInput {
            width: 100%;
            padding: 2px 4px;
            background: transparent;
            border: none;
            color: white;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            outline: none;
            height: 16px;
            line-height: 16px;
        }

        #messageInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* ç©å®¶åç‰Œ */
        .player-nametag {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            border: 1px solid var(--primary);
            pointer-events: none;
            z-index: 150;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
            backdrop-filter: blur(5px);
        }

        /* ä¿®å¾©ï¼šç¾ä»£åŒ–ä¸»é¸å–® - æŒ‰éˆ•ç½®ä¸­ */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-container {
            background: var(--bg-glass);
            backdrop-filter: blur(40px);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 48px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* æ·»åŠ å‚ç›´æ»¾å‹• */
            box-shadow: var(--shadow);
            animation: menuSlideIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            /* ç¢ºä¿å…§å®¹ç½®ä¸­ */
        }

        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateY(40px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .menu-title {
            text-align: center;
            margin-bottom: 40px;
        }

        .menu-title h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .menu-subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 400;
        }

        /* ä¿®å¾©ï¼šéŠæˆ²æ¨¡å¼æŒ‰éˆ•ç½®ä¸­ */
        .game-modes {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin: 24px 0;
            align-items: center;
            /* ç¢ºä¿æŒ‰éˆ•ç½®ä¸­ */
        }

        .mode-button {
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px 32px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            text-align: center;
            color: var(--text-primary);
            width: 280px;
            /* å›ºå®šå¯¬åº¦ç¢ºä¿ä¸€è‡´æ€§ */
            max-width: 100%;
        }

        .mode-button:hover {
            transform: translateY(-4px);
            border-color: var(--border-hover);
            background: var(--bg-glass-hover);
            box-shadow: var(--shadow-hover);
        }

        .mode-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .mode-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-accent);
            margin-bottom: 4px;
        }

        .mode-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 24px;
            align-items: center;
            /* ç¢ºä¿æŒ‰éˆ•ç½®ä¸­ */
        }

        .menu-btn {
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 24px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 1rem;
            font-weight: 500;
            min-width: 200px;
            text-align: center;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            border-color: var(--border-hover);
            background: var(--bg-glass-hover);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.25);
        }

        .menu-btn.primary {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .menu-btn.primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
        }

        /* ä¿®å¾©ï¼šè¨­å®šé¸å–® - å®Œæ•´çš„æ»‘æ¡¿ç³»çµ± */
        #settingsMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .settings-container {
            background: var(--bg-glass);
            backdrop-filter: blur(40px);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 48px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* æ·»åŠ å‚ç›´æ»¾å‹• */
            box-shadow: var(--shadow);
        }


        .settings-container h2 {
            text-align: center;
            margin-bottom: 32px;
            font-size: 2rem;
            color: var(--text-accent);
        }

        .setting-group {
            margin-bottom: 32px;
            padding: 20px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 16px;
        }

        .setting-group h3 {
            color: var(--text-accent);
            margin-bottom: 20px;
            font-size: 1.3rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px 0;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 1rem;
            min-width: 150px;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 200px;
        }

        .slider {
            flex: 1;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.1);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
        }

        .slider::-moz-range-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.1);
        }

        .slider-value {
            color: var(--text-accent);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            min-width: 60px;
            text-align: center;
            background: var(--bg-glass);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        /* ä¿®å¾©ï¼šæš«åœé¸å–® */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .pause-container {
            background: var(--bg-glass);
            backdrop-filter: blur(40px);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 48px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* æ·»åŠ å‚ç›´æ»¾å‹• */
            box-shadow: var(--shadow);
            text-align: center;
        }

        .pause-container h2 {
            margin-bottom: 32px;
            font-size: 2rem;
            color: var(--text-accent);
        }

        /* å¤šäººéŠæˆ²é¸å–® */
        #multiplayerMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .multiplayer-container {
            background: var(--bg-glass);
            backdrop-filter: blur(40px);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 48px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* æ·»åŠ å‚ç›´æ»¾å‹• */
            box-shadow: var(--shadow);
        }

        .multiplayer-container h2 {
            text-align: center;
            margin-bottom: 32px;
            font-size: 2rem;
            color: var(--text-accent);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .input-group input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
        }

        .input-group input::placeholder {
            color: var(--text-muted);
        }

        #roomInfo {
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
        }

        #roomInfo h3 {
            color: var(--text-accent);
            margin-bottom: 12px;
        }

        #roomInfo p {
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        #playerList {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 4px;
            background: var(--bg-glass);
            border-radius: 6px;
            color: var(--text-primary);
        }

        .player-item:last-child {
            margin-bottom: 0;
        }

        /* ç§»å‹•ç«¯æ§åˆ¶ - çµ±ä¸€çš„æ¨£å¼ */
        #mobileControls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            pointer-events: none;
            display: none;
        }

        /* å·¦ä¸‹è§’æ–æ¡¿ */
        .mobile-joystick {
            position: absolute;
            bottom: 60px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 107, 53, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        /* å³å´çµ±ä¸€çš„æŒ‰éˆ•å®¹å™¨ */
        .mobile-buttons-container {
            position: absolute;
            bottom: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
            z-index: 92;
        }

        /* çµ±ä¸€çš„æŒ‰éˆ•æ¨£å¼ */
        .mobile-btn {
            width: 65px;
            height: 65px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            pointer-events: auto;
            touch-action: manipulation;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        /* æŒ‰éˆ•åœ–æ¨™ */
        .mobile-btn .btn-icon {
            font-size: 22px;
            line-height: 1;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }

        /* æŒ‰éˆ•æ¨™ç±¤ */
        .mobile-btn .btn-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* æŒ‰éˆ•æ‡¸åœ/æŒ‰ä¸‹æ•ˆæœ */
        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(255, 107, 53, 0.3);
            border-color: rgba(255, 107, 53, 0.5);
        }

        /* æ¿€æ´»ç‹€æ…‹ï¼ˆç”¨æ–¼åˆ‡æ›é¡æŒ‰éˆ•ï¼‰ */
        .mobile-btn.active {
            background: rgba(255, 107, 53, 0.4);
            border-color: rgba(255, 107, 53, 0.6);
        }

        .mobile-btn.active .btn-label {
            color: rgba(255, 255, 255, 1);
        }

        /* ç‰¹æ®ŠæŒ‰éˆ•æ¨£å¼ */
        #sneakBtn.active {
            background: rgba(100, 150, 255, 0.4);
            border-color: rgba(100, 150, 255, 0.6);
        }

        #flyBtn.active {
            background: rgba(100, 255, 100, 0.4);
            border-color: rgba(100, 255, 100, 0.6);
        }

        /* èŠå¤©æŒ‰éˆ•ç‰¹æ®Šæ¨£å¼ */
        #mobileChatBtn {
            background: rgba(255, 107, 53, 0.2);
            border-color: rgba(255, 107, 53, 0.3);
        }

        /* æŒ‰éˆ•å‹•ç•«æ•ˆæœ */
        @keyframes buttonPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 107, 53, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0);
            }
        }

        .mobile-btn:active {
            animation: buttonPulse 0.5s;
        }

        /* éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-height: 600px) {
            .mobile-buttons-container {
                bottom: 40px;
                gap: 6px;
            }

            .mobile-btn {
                width: 55px;
                height: 55px;
            }

            .mobile-btn .btn-icon {
                font-size: 20px;
            }

            .mobile-btn .btn-label {
                font-size: 8px;
            }

            .mobile-joystick {
                width: 100px;
                height: 100px;
                bottom: 40px;
            }
        }

        @media (max-width: 400px) {
            .mobile-buttons-container {
                right: 10px;
            }

            .mobile-joystick {
                left: 20px;
            }
        }

        /* å¹³æ¿å„ªåŒ– */
        @media (min-width: 768px) and (max-width: 1024px) {
            .mobile-buttons-container {
                right: 30px;
                bottom: 80px;
                gap: 10px;
            }

            .mobile-btn {
                width: 70px;
                height: 70px;
            }

            .mobile-btn .btn-icon {
                font-size: 24px;
            }

            .mobile-btn .btn-label {
                font-size: 10px;
            }

            .mobile-joystick {
                width: 140px;
                height: 140px;
                left: 50px;
                bottom: 80px;
            }

            .joystick-knob {
                width: 50px;
                height: 50px;
            }
        }

        /* ç§»å‹•ç«¯é¸å–®æŒ‰éˆ•ï¼ˆå³ä¸Šè§’ï¼‰ */
        .mobile-menu-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            pointer-events: auto;
            touch-action: manipulation;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            z-index: 95;
        }

        .mobile-menu-btn .menu-icon {
            font-size: 24px;
            color: white;
            line-height: 1;
        }

        .mobile-menu-btn .menu-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .mobile-menu-btn:active {
            transform: scale(0.95);
            background: rgba(255, 107, 53, 0.3);
            border-color: rgba(255, 107, 53, 0.5);
        }

        /* èŠå¤©è¼¸å…¥æ¿€æ´»æ™‚çš„è¦†è“‹å±¤ */
        .chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 199;
            display: none;
            pointer-events: auto;
        }

        .chat-overlay.active {
            display: block;
        }

        /* éš±è—ç§»å‹•æ§åˆ¶åœ¨éè§¸æ§è¨­å‚™ä¸Š */
        @media (hover: hover) and (pointer: fine) {
            #mobileControls {
                display: none !important;
            }
        }

        /* é¡¯ç¤ºç§»å‹•æ§åˆ¶åœ¨è§¸æ§è¨­å‚™ä¸Š */
        @media (hover: none) and (pointer: coarse) {
            #mobileControls {
                display: block !important;
            }
        }

        /* æ–¹å¡Šåˆ‡æ›é€šçŸ¥ */
        /* ä¿®å¾©ï¼šæ–¹å¡Šåˆ‡æ›é€šçŸ¥ä½ç½® - å¾ä¸­å¤®ç§»åˆ°ç‰©å“æ¬„ä¸Šæ–¹ */
        #blockSwitchNotification {
            position: fixed;
            bottom: 100px;
            /* æ”¾åœ¨ç‰©å“æ¬„ä¸Šæ–¹ */
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 10px 15px;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-primary);
            box-shadow: var(--shadow);
            text-align: center;
        }

        /* è¼‰å…¥ç•«é¢ */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 400;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 500;
        }

        .loading-bar {
            width: 300px;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* éŒ¯èª¤è¨Šæ¯ */
        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-glass);
            color: var(--text-primary);
            padding: 32px;
            border-radius: 16px;
            text-align: center;
            z-index: 300;
            border: 1px solid #ff4444;
            box-shadow: 0 20px 60px rgba(255, 68, 68, 0.3);
            max-width: 400px;
            backdrop-filter: blur(20px);
        }

        .error-message h3 {
            color: #ff4444;
            margin-bottom: 16px;
            font-size: 1.5rem;
        }

        .error-message button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 16px;
            transition: all 0.3s ease;
        }

        .error-message button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        /* æ»¾å‹•æ¢æ¨£å¼ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-glass);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }

        /* å‹•ç•«æ•ˆæœ */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .loading::after {
            content: '';
            animation: pulse 1.5s infinite;
        }

        /* è§¸æ§å„ªåŒ– */
        @media (hover: none) and (pointer: coarse) {
            #mobileControls {
                display: block;
            }

            .inventory-slot:hover {
                transform: none;
            }

            .mode-button:hover {
                transform: none;
            }

            .menu-btn:hover {
                transform: none;
            }
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        /* éŸ¿æ‡‰å¼è¨­è¨ˆå¢å¼· */
        @media (max-height: 700px) {

            .menu-container,
            .settings-container,
            .pause-container,
            .multiplayer-container {
                padding: 30px;
                max-height: 90vh;
            }

            .menu-title h1 {
                font-size: 2.5rem;
                margin-bottom: 5px;
            }

            .menu-subtitle {
                font-size: 0.9rem;
            }

            .game-modes {
                margin: 15px 0;
                gap: 12px;
            }

            .mode-button {
                padding: 18px 24px;
            }
        }

        @media (max-height: 500px) {

            .menu-container,
            .settings-container,
            .pause-container,
            .multiplayer-container {
                padding: 20px;
                max-height: 95vh;
            }

            .menu-title h1 {
                font-size: 2rem;
                margin-bottom: 3px;
            }

            .menu-subtitle {
                font-size: 0.8rem;
            }

            .game-modes {
                margin: 10px 0;
                gap: 8px;
            }

            .mode-button {
                padding: 12px 18px;
            }

            .mode-icon {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }

            .mode-title {
                font-size: 1rem;
            }

            .mode-desc {
                font-size: 0.8rem;
            }
        }

        /* æ»¾å‹•æ¢æ¨£å¼ - ç¢ºä¿èˆ‡éŠæˆ²é¢¨æ ¼ä¸€è‡´ */
        .menu-container::-webkit-scrollbar,
        .settings-container::-webkit-scrollbar,
        .pause-container::-webkit-scrollbar,
        .multiplayer-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .menu-container::-webkit-scrollbar-track,
        .settings-container::-webkit-scrollbar-track,
        .pause-container::-webkit-scrollbar-track,
        .multiplayer-container::-webkit-scrollbar-track {
            background: var(--bg-glass);
            border-radius: 4px;
        }

        .menu-container::-webkit-scrollbar-thumb,
        .settings-container::-webkit-scrollbar-thumb,
        .pause-container::-webkit-scrollbar-thumb,
        .multiplayer-container::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        .menu-container::-webkit-scrollbar-thumb:hover,
        .settings-container::-webkit-scrollbar-thumb:hover,
        .pause-container::-webkit-scrollbar-thumb:hover,
        .multiplayer-container::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair"></div>

        <!-- ç°¡åŒ–çš„éŠæˆ²UI - åªä¿ç•™å¿…è¦ä¿¡æ¯ -->
        <div id="gameUI">
            <div class="ui-panel">
                <div class="ui-row">
                    <span class="ui-label">åº§æ¨™</span>
                    <span class="ui-value" id="position">0, 0, 0</span>
                </div>
                <div class="ui-row">
                    <span class="ui-label">FPS</span>
                    <span class="ui-value" id="fpsDisplay">60</span>
                </div>
                <div class="ui-row" id="multiplayerInfo" style="display: none;">
                    <span class="ui-label">ç©å®¶</span>
                    <span class="ui-value" id="playerCount">1</span>
                </div>
                <div class="ui-row" id="connectionInfo" style="display: none;">
                    <span class="ui-label">æˆ¿é–“</span>
                    <span class="ui-value" id="roomStatus">é›¢ç·š</span>
                </div>
            </div>
        </div>

        <!-- é‡æ–°è¨­è¨ˆçš„ç‰©å“æ¬„ -->
        <div id="inventory">
            <div class="inventory-slot active" data-block="grass">
                <div class="block-icon">ğŸŸ©</div>
                <div class="block-name">è‰åœ°</div>
            </div>
            <div class="inventory-slot" data-block="stone">
                <div class="block-icon">â¬œ</div>
                <div class="block-name">çŸ³é ­</div>
            </div>
            <div class="inventory-slot" data-block="wood">
                <div class="block-icon">ğŸŸ«</div>
                <div class="block-name">æœ¨é ­</div>
            </div>
            <div class="inventory-slot" data-block="water">
                <div class="block-icon">ğŸŸ¦</div>
                <div class="block-name">æ°´</div>
            </div>
            <div class="inventory-slot" data-block="sand">
                <div class="block-icon">ğŸŸ¨</div>
                <div class="block-name">æ²™å­</div>
            </div>
            <div class="inventory-slot" data-block="snow">
                <div class="block-icon">â„ï¸</div>
                <div class="block-name">é›ª</div>
            </div>
            <div class="inventory-slot" data-block="leaves">
                <div class="block-icon">ğŸŸ¢</div>
                <div class="block-name">æ¨¹è‘‰</div>
            </div>
            <div class="inventory-slot" data-block="cobblestone">
                <div class="block-icon">ğŸ”˜</div>
                <div class="block-name">éµåµçŸ³</div>
            </div>
            <div class="inventory-slot" data-block="brick">
                <div class="block-icon">ğŸ§±</div>
                <div class="block-name">ç£šå¡Š</div>
            </div>
            <div class="inventory-slot" data-block="glass">
                <div class="block-icon">ğŸ”·</div>
                <div class="block-name">ç»ç’ƒ</div>
            </div>
        </div>

        <!-- å®Œå…¨é‡å¯«çš„Minecraft Javaç‰ˆèŠå¤©ç³»çµ± -->
        <div id="chatSystem">
            <div id="chatMessages"></div>
            <div id="chatInput">
                <input type="text" id="messageInput" placeholder="è¼¸å…¥è¨Šæ¯æˆ–æŒ‡ä»¤..." maxlength="256">
            </div>
        </div>

        <!-- ç©å®¶åç‰Œå®¹å™¨ -->
        <div id="playerNameTags"></div>

        <!-- åœ¨ç§»å‹•ç«¯æ§åˆ¶ä¸­æ·»åŠ é¸å–®æŒ‰éˆ• -->
        <div id="mobileControls">
            <!-- å·¦ä¸‹è§’æ–æ¡¿ -->
            <div class="mobile-joystick" id="moveJoystick">
                <div class="joystick-knob" id="moveKnob"></div>
            </div>

            <!-- å³ä¸Šè§’é¸å–®æŒ‰éˆ•ï¼ˆé¡ä¼¼ESCï¼‰ -->
            <div class="mobile-menu-btn" id="mobileMenuBtn">
                <span class="menu-icon">â˜°</span>
                <span class="menu-label">é¸å–®</span>
            </div>

            <!-- å³å´çµ±ä¸€çš„æŒ‰éˆ•åˆ— -->
            <div class="mobile-buttons-container">
                <div class="mobile-btn" id="jumpBtn" title="è·³èº">
                    <span class="btn-icon">â¬†ï¸</span>
                    <span class="btn-label">è·³èº</span>
                </div>
                <div class="mobile-btn" id="sneakBtn" title="æ½›è¡Œ">
                    <span class="btn-icon">â¬‡ï¸</span>
                    <span class="btn-label">æ½›è¡Œ</span>
                </div>
                <div class="mobile-btn" id="breakBtn" title="ç ´å£">
                    <span class="btn-icon">â›ï¸</span>
                    <span class="btn-label">ç ´å£</span>
                </div>
                <div class="mobile-btn" id="placeBtn" title="æ”¾ç½®">
                    <span class="btn-icon">ğŸ§±</span>
                    <span class="btn-label">æ”¾ç½®</span>
                </div>
                <div class="mobile-btn" id="flyBtn" title="é£›è¡Œ">
                    <span class="btn-icon">ğŸš</span>
                    <span class="btn-label">é£›è¡Œ</span>
                </div>
                <div class="mobile-btn" id="mobileChatBtn" title="èŠå¤©">
                    <span class="btn-icon">ğŸ’¬</span>
                    <span class="btn-label">èŠå¤©</span>
                </div>
            </div>
        </div>

        <!-- è¼‰å…¥ç•«é¢ -->
        <div id="loading" style="display: none;">
            æ­£åœ¨åˆå§‹åŒ–ä¸–ç•Œ
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>
    </div>

    <!-- ä¿®å¾©ï¼šä¸»é¸å–® - æŒ‰éˆ•ç½®ä¸­ -->
    <div id="mainMenu">
        <div class="menu-container">
            <div class="menu-title">
                <h1>Minecraft</h1>
                <p class="menu-subtitle">WebGL å®Œç¾ç‰ˆ</p>
            </div>

            <div class="game-modes">
                <button class="mode-button" id="singlePlayerButton">
                    <div class="mode-icon">ğŸ¯</div>
                    <div class="mode-title">å–®äººéŠæˆ²</div>
                    <div class="mode-desc">æ¢ç´¢ç„¡é™ä¸–ç•Œ</div>
                </button>
                <button class="mode-button" id="multiPlayerStartButton">
                    <div class="mode-icon">ğŸ‘¥</div>
                    <div class="mode-title">å¤šäººéŠæˆ²</div>
                    <div class="mode-desc">èˆ‡æœ‹å‹å»ºé€ </div>
                </button>
            </div>

            <div class="menu-buttons">
                <button class="menu-btn" id="settingsMenuButton">âš™ï¸ è¨­å®š</button>
            </div>
        </div>
    </div>

    <!-- ä¿®å¾©ï¼šè¨­å®šé¸å–® - å®Œæ•´çš„æ»‘æ¡¿ç³»çµ± -->
    <div id="settingsMenu">
        <div class="settings-container">
            <h2>âš™ï¸ éŠæˆ²è¨­å®š</h2>

            <div class="setting-group">
                <h3>ğŸ® éŠæˆ²è¨­å®š</h3>
                <div class="setting-item">
                    <span class="setting-label">è¦–é‡è·é›¢</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="renderDistanceSlider" min="8" max="64" value="32"
                                step="4">
                            <span class="slider-value" id="renderDistanceValue">32 æ ¼</span>
                        </div>
                    </div>
                </div>
                <div class="setting-item">
                    <span class="setting-label">è¦–é‡è§’åº¦ (FOV)</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="fovSlider" min="30" max="110" value="70" step="5">
                            <span class="slider-value" id="fovValue">70Â°</span>
                        </div>
                    </div>
                </div>
                <div class="setting-item">
                    <span class="setting-label">æ»‘é¼ éˆæ•åº¦</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="sensitivitySlider" min="0.1" max="3.0" value="1.0"
                                step="0.1">
                            <span class="slider-value" id="sensitivityValue">1.0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="setting-group">
                <h3>âš¡ æ€§èƒ½è¨­å®š</h3>
                <div class="setting-item">
                    <span class="setting-label">æœ€å¤§FPS</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="maxFpsSlider" min="30" max="120" value="60"
                                step="10">
                            <span class="slider-value" id="maxFpsValue">60</span>
                        </div>
                    </div>
                </div>
                <div class="setting-item">
                    <span class="setting-label">å€å¡Šæ›´æ–°é »ç‡</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="chunkUpdateSlider" min="1" max="10" value="5"
                                step="1">
                            <span class="slider-value" id="chunkUpdateValue">5</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="setting-group">
                <h3>ğŸµ éŸ³æ•ˆè¨­å®š</h3>
                <div class="setting-item">
                    <span class="setting-label">ä¸»éŸ³é‡</span>
                    <div class="setting-control">
                        <div class="slider-container">
                            <input type="range" class="slider" id="volumeSlider" min="0" max="100" value="50" step="5">
                            <span class="slider-value" id="volumeValue">50%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-buttons">
                <button class="menu-btn primary" id="saveSettingsButton">ğŸ’¾ ä¿å­˜è¨­å®š</button>
                <button class="menu-btn" id="backToMainMenuButton">â¬…ï¸ è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>
    </div>

    <!-- ä¿®å¾©ï¼šæš«åœé¸å–® -->
    <div id="pauseMenu">
        <div class="pause-container">
            <h2>â¸ï¸ éŠæˆ²æš«åœ</h2>
            <div class="menu-buttons">
                <button class="menu-btn primary" id="resumeButton">â–¶ï¸ ç¹¼çºŒéŠæˆ²</button>
                <button class="menu-btn" id="multiplayerButton">ğŸ‘¥ å¤šäººéŠæˆ²</button>
                <button class="menu-btn" id="settingsButton">âš™ï¸ è¨­å®š</button>
                <button class="menu-btn" id="mainMenuButton">ğŸ  ä¸»é¸å–®</button>
            </div>
        </div>
    </div>

    <!-- å¤šäººéŠæˆ²é¸å–® -->
    <div id="multiplayerMenu">
        <div class="multiplayer-container">
            <h2>ğŸ‘¥ å¤šäººéŠæˆ²</h2>

            <div class="input-group">
                <label>ç©å®¶åç¨±</label>
                <input type="text" id="playerName" placeholder="è¼¸å…¥ä½ çš„åç¨±" maxlength="16">
            </div>

            <div class="input-group">
                <label>æˆ¿é–“ID</label>
                <input type="text" id="roomId" placeholder="è¼¸å…¥æˆ¿é–“IDæˆ–ç•™ç©ºå‰µå»ºæ–°æˆ¿é–“" maxlength="10">
            </div>

            <div class="menu-buttons">
                <button class="menu-btn primary" id="joinRoomButton">ğŸšª åŠ å…¥æˆ¿é–“</button>
                <button class="menu-btn" id="createRoomButton">â• å‰µå»ºæˆ¿é–“</button>
                <button class="menu-btn" id="backToGameButton">â¬…ï¸ è¿”å›</button>
            </div>

            <div id="roomInfo" style="display: none;">
                <h3>æˆ¿é–“è³‡è¨Š</h3>
                <p>æˆ¿é–“ID: <span id="currentRoomId"></span></p>
                <p>ç©å®¶æ•¸é‡: <span id="roomPlayerCount">1</span></p>
                <div id="playerList"></div>
                <div class="menu-buttons" style="margin-top: 20px;">
                    <button class="menu-btn primary" id="startGameButton">ğŸ® é–‹å§‹éŠæˆ²</button>
                    <button class="menu-btn" id="leaveRoomButton">ğŸšª é›¢é–‹æˆ¿é–“</button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ–¹å¡Šåˆ‡æ›é€šçŸ¥ -->
    <div id="blockSwitchNotification"></div>

    <script>
        // Firebase é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyDFr6n0l_yc4UcyROw9pFbRRYeYOvAb2vc",
            authDomain: "mini-minecraft-c2d8e.firebaseapp.com",
            databaseURL: "https://mini-minecraft-c2d8e-default-rtdb.asia-southeast1.firebasedatabase.app/",
            projectId: "mini-minecraft-c2d8e",
            storageBucket: "mini-minecraft-c2d8e.appspot.com",
            messagingSenderId: "965733295205",
            appId: "1:965733295205:web:cdaa7cb8b80cd1824e928c"
        };

        let database = null;
        let firebaseAvailable = false;

        // åˆå§‹åŒ–Firebase
        try {
            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
            database = firebase.database();

            database.ref('.info/connected').on('value', (snapshot) => {
                firebaseAvailable = snapshot.val() === true;
                console.log('Firebaseé€£æ¥ç‹€æ…‹:', firebaseAvailable ? 'å·²é€£æ¥' : 'å·²æ–·é–‹');
            });

            console.log('Firebaseåˆå§‹åŒ–æˆåŠŸ');
        } catch (error) {
            console.error('Firebaseåˆå§‹åŒ–å¤±æ•—:', error);
            firebaseAvailable = false;
        }

        // ä¿®å¾©ï¼šéŠæˆ²è¨­å®šç®¡ç† - å®Œæ•´çš„è¨­å®šç³»çµ±
        class GameSettings {
            constructor() {
                this.settings = {
                    renderDistance: 32,
                    fov: 70,
                    maxFps: 60,
                    mouseSensitivity: 1.0,
                    volume: 50,
                    chunkUpdateRate: 5
                };
                this.loadSettings();
                this.setupSettingsUI();
            }

            loadSettings() {
                const saved = localStorage.getItem('minecraftSettings');
                if (saved) {
                    this.settings = { ...this.settings, ...JSON.parse(saved) };
                }
            }

            saveSettings() {
                localStorage.setItem('minecraftSettings', JSON.stringify(this.settings));
                console.log('è¨­å®šå·²ä¿å­˜:', this.settings);
            }

            setupSettingsUI() {
                // è¦–é‡è·é›¢æ»‘æ¡¿
                const renderDistanceSlider = document.getElementById('renderDistanceSlider');
                const renderDistanceValue = document.getElementById('renderDistanceValue');

                renderDistanceSlider.value = this.settings.renderDistance;
                renderDistanceValue.textContent = this.settings.renderDistance + ' æ ¼';

                renderDistanceSlider.addEventListener('input', (e) => {
                    this.settings.renderDistance = parseInt(e.target.value);
                    renderDistanceValue.textContent = this.settings.renderDistance + ' æ ¼';
                    if (window.game) {
                        window.game.renderDistance = this.settings.renderDistance;
                    }
                });

                // FOVæ»‘æ¡¿
                const fovSlider = document.getElementById('fovSlider');
                const fovValue = document.getElementById('fovValue');

                fovSlider.value = this.settings.fov;
                fovValue.textContent = this.settings.fov + 'Â°';

                fovSlider.addEventListener('input', (e) => {
                    this.settings.fov = parseInt(e.target.value);
                    fovValue.textContent = this.settings.fov + 'Â°';
                    if (window.game) {
                        window.game.updateProjectionMatrix();
                    }
                });

                // æ»‘é¼ éˆæ•åº¦æ»‘æ¡¿
                const sensitivitySlider = document.getElementById('sensitivitySlider');
                const sensitivityValue = document.getElementById('sensitivityValue');

                sensitivitySlider.value = this.settings.mouseSensitivity;
                sensitivityValue.textContent = this.settings.mouseSensitivity;

                sensitivitySlider.addEventListener('input', (e) => {
                    this.settings.mouseSensitivity = parseFloat(e.target.value);
                    sensitivityValue.textContent = this.settings.mouseSensitivity;
                });

                // æœ€å¤§FPSæ»‘æ¡¿
                const maxFpsSlider = document.getElementById('maxFpsSlider');
                const maxFpsValue = document.getElementById('maxFpsValue');

                maxFpsSlider.value = this.settings.maxFps;
                maxFpsValue.textContent = this.settings.maxFps;

                maxFpsSlider.addEventListener('input', (e) => {
                    this.settings.maxFps = parseInt(e.target.value);
                    maxFpsValue.textContent = this.settings.maxFps;
                });

                // å€å¡Šæ›´æ–°é »ç‡æ»‘æ¡¿
                const chunkUpdateSlider = document.getElementById('chunkUpdateSlider');
                const chunkUpdateValue = document.getElementById('chunkUpdateValue');

                chunkUpdateSlider.value = this.settings.chunkUpdateRate;
                chunkUpdateValue.textContent = this.settings.chunkUpdateRate;

                chunkUpdateSlider.addEventListener('input', (e) => {
                    this.settings.chunkUpdateRate = parseInt(e.target.value);
                    chunkUpdateValue.textContent = this.settings.chunkUpdateRate;
                });

                // éŸ³é‡æ»‘æ¡¿
                const volumeSlider = document.getElementById('volumeSlider');
                const volumeValue = document.getElementById('volumeValue');

                volumeSlider.value = this.settings.volume;
                volumeValue.textContent = this.settings.volume + '%';

                volumeSlider.addEventListener('input', (e) => {
                    this.settings.volume = parseInt(e.target.value);
                    volumeValue.textContent = this.settings.volume + '%';
                });

                // ä¿å­˜è¨­å®šæŒ‰éˆ•
                document.getElementById('saveSettingsButton').addEventListener('click', () => {
                    this.saveSettings();
                    if (window.game && window.game.chatSystem) {
                        window.game.chatSystem.addMessage('è¨­å®šå·²ä¿å­˜ï¼', 'system');
                    }
                });
            }

            get(key) {
                return this.settings[key];
            }

            set(key, value) {
                this.settings[key] = value;
            }
        }

        // å®Œå…¨é‡å¯«çš„Minecraft Javaç‰ˆèŠå¤©ç³»çµ±
        // å®Œå…¨é‡å¯«çš„Minecraft Javaç‰ˆèŠå¤©ç³»çµ±
        class MinecraftChatSystem {
            constructor() {
                this.messages = [];
                this.maxMessages = 100;
                this.isInputActive = false;
                this.chatHistory = [];
                this.historyIndex = -1;
                this.visibilityTimer = null;
                this.fadeDelay = 3000; // 3ç§’å¾Œæ·¡å‡ºï¼Œæ›´æ¥è¿‘MC
                this.commandRegistry = new Map();

                // æ–°å¢ï¼šèŠå¤©è¦†è“‹å±¤
                this.chatOverlay = null;

                this.setupElements();
                this.setupEventListeners();
                this.registerCommands();
                this.createChatOverlay();
            }

            // æ–°å¢ï¼šå‰µå»ºèŠå¤©è¦†è“‹å±¤
            createChatOverlay() {
                this.chatOverlay = document.createElement('div');
                this.chatOverlay.className = 'chat-overlay';
                document.body.appendChild(this.chatOverlay);

                // é»æ“Šè¦†è“‹å±¤é—œé–‰èŠå¤©
                this.chatOverlay.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.deactivateInput();
                });
            }

            setupElements() {
                this.chatMessages = document.getElementById('chatMessages');
                this.chatInput = document.getElementById('chatInput');
                this.messageInput = document.getElementById('messageInput');
            }

            setupEventListeners() {
                this.messageInput.addEventListener('keydown', (e) => {
                    // é˜»æ­¢äº‹ä»¶å†’æ³¡
                    e.stopPropagation();

                    if (e.code === 'Enter') {
                        e.preventDefault();
                        this.sendMessage();
                    } else if (e.code === 'Escape') {
                        e.preventDefault();
                        this.deactivateInput();
                    } else if (e.code === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory(-1);
                    } else if (e.code === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory(1);
                    } else if (e.code === 'Tab') {
                        e.preventDefault();
                        this.autoComplete();
                    }
                });

                // åœ¨ç§»å‹•è¨­å‚™ä¸Šï¼Œè¼¸å…¥æ¡†å¤±å»ç„¦é»æ™‚é—œé–‰èŠå¤©
                this.messageInput.addEventListener('blur', () => {
                    // å»¶é²æª¢æŸ¥ï¼Œç¢ºä¿ä¸æ˜¯å› ç‚ºé»æ“Šç™¼é€æŒ‰éˆ•
                    setTimeout(() => {
                        if (this.isInputActive && document.activeElement !== this.messageInput) {
                            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                            if (isMobile) {
                                this.deactivateInput();
                            }
                        }
                    }, 200);
                });
            }

            // è¨»å†Šæ‰€æœ‰æŒ‡ä»¤
            registerCommands() {
                this.commandRegistry.set('help', {
                    description: 'é¡¯ç¤ºå¹«åŠ©ä¿¡æ¯',
                    usage: '/help [æŒ‡ä»¤åç¨±]',
                    category: 'ç³»çµ±',
                    execute: (args) => this.showHelp(args)
                });

                this.commandRegistry.set('clear', {
                    description: 'æ¸…é™¤èŠå¤©è¨˜éŒ„',
                    usage: '/clear',
                    category: 'ç³»çµ±',
                    execute: () => this.clearMessages()
                });

                this.commandRegistry.set('time', {
                    description: 'é¡¯ç¤ºç•¶å‰æ™‚é–“',
                    usage: '/time',
                    category: 'ä¿¡æ¯',
                    execute: () => this.showTime()
                });

                this.commandRegistry.set('tp', {
                    description: 'å‚³é€åˆ°æŒ‡å®šåº§æ¨™',
                    usage: '/tp <x> <y> <z>',
                    category: 'éŠæˆ²',
                    execute: (args) => this.handleTeleport(args)
                });

                this.commandRegistry.set('fly', {
                    description: 'åˆ‡æ›é£›è¡Œæ¨¡å¼',
                    usage: '/fly',
                    category: 'éŠæˆ²',
                    execute: () => this.toggleFly()
                });

                this.commandRegistry.set('players', {
                    description: 'é¡¯ç¤ºåœ¨ç·šç©å®¶',
                    usage: '/players',
                    category: 'å¤šäºº',
                    execute: () => this.listPlayers()
                });

                this.commandRegistry.set('ping', {
                    description: 'é¡¯ç¤ºç¶²çµ¡å»¶é²',
                    usage: '/ping',
                    category: 'ç¶²çµ¡',
                    execute: () => this.showPing()
                });

                this.commandRegistry.set('coords', {
                    description: 'é¡¯ç¤ºç•¶å‰åº§æ¨™',
                    usage: '/coords',
                    category: 'ä¿¡æ¯',
                    execute: () => this.showCoords()
                });

                this.commandRegistry.set('biome', {
                    description: 'é¡¯ç¤ºç•¶å‰ç”Ÿç‰©ç¾¤è½',
                    usage: '/biome',
                    category: 'ä¿¡æ¯',
                    execute: () => this.showBiome()
                });

                this.commandRegistry.set('fps', {
                    description: 'é¡¯ç¤ºFPSä¿¡æ¯',
                    usage: '/fps',
                    category: 'ç³»çµ±',
                    execute: () => this.showFPS()
                });

                this.commandRegistry.set('seed', {
                    description: 'é¡¯ç¤ºä¸–ç•Œç¨®å­',
                    usage: '/seed',
                    category: 'ä¿¡æ¯',
                    execute: () => this.showSeed()
                });

                this.commandRegistry.set('gamemode', {
                    description: 'åˆ‡æ›éŠæˆ²æ¨¡å¼',
                    usage: '/gamemode <creative|survival>',
                    category: 'éŠæˆ²',
                    execute: (args) => this.changeGamemode(args)
                });
            }

            // æ¿€æ´»èŠå¤©è¼¸å…¥
            activateInput() {
                console.log('èŠå¤©ç³»çµ±ï¼šæ¿€æ´»è¼¸å…¥');

                this.isInputActive = true;
                this.chatInput.classList.add('active');
                this.chatInput.style.display = 'block';

                // é¡¯ç¤ºè¦†è“‹å±¤ï¼ˆç§»å‹•è¨­å‚™ï¼‰
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile && this.chatOverlay) {
                    this.chatOverlay.classList.add('active');
                }

                // æ•´å€‹èŠå¤©ç³»çµ±æ¥æ”¶æ»‘é¼ äº‹ä»¶
                document.getElementById('chatSystem').classList.add('active');

                // èšç„¦è¼¸å…¥æ¡†
                if (isMobile) {
                    setTimeout(() => {
                        this.messageInput.focus();
                        this.messageInput.click(); // iOSéœ€è¦clickäº‹ä»¶
                    }, 100);
                } else {
                    this.messageInput.focus();
                }

                this.showMessages();

                // é‡‹æ”¾æ»‘é¼ æŒ‡é‡é–å®š
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }

                if (this.visibilityTimer) {
                    clearTimeout(this.visibilityTimer);
                    this.visibilityTimer = null;
                }
            }

            // åœç”¨èŠå¤©è¼¸å…¥
            deactivateInput() {
                console.log('èŠå¤©ç³»çµ±ï¼šé—œé–‰è¼¸å…¥');

                this.isInputActive = false;
                this.chatInput.classList.remove('active');
                this.chatInput.style.display = 'none';
                this.messageInput.value = '';
                this.messageInput.blur();
                this.historyIndex = -1;

                // éš±è—è¦†è“‹å±¤
                if (this.chatOverlay) {
                    this.chatOverlay.classList.remove('active');
                }

                // æ•´å€‹èŠå¤©ç³»çµ±ä¸å†æ¥æ”¶æ»‘é¼ äº‹ä»¶
                document.getElementById('chatSystem').classList.remove('active');

                this.startFadeTimer();

                // å¦‚æœéŠæˆ²æ­£åœ¨é€²è¡Œï¼Œé‡æ–°é–å®šæ»‘é¼ æŒ‡é‡ï¼ˆåƒ…é™æ¡Œé¢ï¼‰
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (!isMobile && window.game && window.game.gameStarted && !window.game.isPaused) {
                    window.game.canvas.requestPointerLock();
                }
            }

            // é¡¯ç¤ºèŠå¤©è¨Šæ¯
            showMessages() {
                this.chatMessages.classList.add('visible');
                if (this.visibilityTimer) {
                    clearTimeout(this.visibilityTimer);
                    this.visibilityTimer = null;
                }
            }

            // éš±è—èŠå¤©è¨Šæ¯
            hideMessages() {
                if (!this.isInputActive) {
                    this.chatMessages.classList.remove('visible');
                }
            }

            // é–‹å§‹æ·¡å‡ºè¨ˆæ™‚å™¨
            startFadeTimer() {
                if (this.visibilityTimer) {
                    clearTimeout(this.visibilityTimer);
                }
                this.visibilityTimer = setTimeout(() => {
                    this.hideMessages();
                }, this.fadeDelay);
            }

            // æ·»åŠ è¨Šæ¯ - å®Œå…¨æŒ‰ç…§MC Javaç‰ˆæ¨£å¼
            addMessage(content, type = 'system', playerName = null) {
                const message = {
                    content: content,
                    type: type,
                    playerName: playerName,
                    timestamp: Date.now(),
                    id: Math.random().toString(36).substr(2, 9)
                };

                this.messages.push(message);

                if (this.messages.length > this.maxMessages) {
                    this.messages.shift();
                }

                this.renderMessage(message);
                this.showMessages();
                this.startFadeTimer();
                this.scrollToBottom();
            }

            // æ¸²æŸ“å–®å€‹è¨Šæ¯ - MC Javaç‰ˆæ ¼å¼
            renderMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.type}`;
                messageDiv.id = `msg-${message.id}`;

                let content = '';
                switch (message.type) {
                    case 'system':
                        content = `[${this.formatTime()}] [ç³»çµ±] ${message.content}`;
                        break;
                    case 'player':
                        content = `[${this.formatTime()}] <${message.playerName}> ${message.content}`;
                        break;
                    case 'error':
                        content = `[${this.formatTime()}] [éŒ¯èª¤] ${message.content}`;
                        break;
                    case 'command':
                        content = `[${this.formatTime()}] [æŒ‡ä»¤] ${message.content}`;
                        break;
                    case 'info':
                        content = `[${this.formatTime()}] [ä¿¡æ¯] ${message.content}`;
                        break;
                    case 'warning':
                        content = `[${this.formatTime()}] [è­¦å‘Š] ${message.content}`;
                        break;
                    default:
                        content = `[${this.formatTime()}] ${message.content}`;
                }

                messageDiv.textContent = content;
                this.chatMessages.appendChild(messageDiv);

                const messageElements = this.chatMessages.children;
                if (messageElements.length > this.maxMessages) {
                    messageElements[0].remove();
                }
            }

            formatTime() {
                const now = new Date();
                return now.toTimeString().slice(0, 8);
            }

            // ç™¼é€è¨Šæ¯
            sendMessage() {
                const content = this.messageInput.value.trim();
                if (!content) return;

                this.chatHistory.unshift(content);
                if (this.chatHistory.length > 50) {
                    this.chatHistory.pop();
                }

                if (content.startsWith('/')) {
                    this.handleCommand(content);
                } else {
                    if (window.game && window.game.isMultiplayer && window.game.multiplayerManager.isConnected) {
                        window.game.multiplayerManager.sendChatMessage(content);
                        this.addMessage(content, 'player', window.game.multiplayerManager.playerName || 'ä½ ');
                    } else {
                        this.addMessage(content, 'player', 'ä½ ');
                    }
                }

                this.deactivateInput();
            }

            // è™•ç†æŒ‡ä»¤
            handleCommand(command) {
                const args = command.slice(1).split(' ');
                const cmd = args[0].toLowerCase();
                const commandArgs = args.slice(1);

                const commandInfo = this.commandRegistry.get(cmd);
                if (commandInfo) {
                    try {
                        commandInfo.execute(commandArgs);
                    } catch (error) {
                        this.addMessage(`æŒ‡ä»¤åŸ·è¡ŒéŒ¯èª¤: ${error.message}`, 'error');
                    }
                } else {
                    this.addMessage(`æœªçŸ¥æŒ‡ä»¤: /${cmd}ã€‚è¼¸å…¥ /help æŸ¥çœ‹å¯ç”¨æŒ‡ä»¤ã€‚`, 'error');
                }
            }

            // å®Œæ•´çš„å¹«åŠ©ç³»çµ±
            showHelp(args) {
                if (args.length === 0) {
                    const categories = {};
                    this.commandRegistry.forEach((info, cmd) => {
                        if (!categories[info.category]) {
                            categories[info.category] = [];
                        }
                        categories[info.category].push(cmd);
                    });

                    this.addMessage('=== æŒ‡ä»¤å¹«åŠ© ===', 'command');
                    Object.keys(categories).forEach(category => {
                        this.addMessage(`${category}:`, 'command');
                        categories[category].forEach(cmd => {
                            this.addMessage(`  /${cmd} - ${this.commandRegistry.get(cmd).description}`, 'command');
                        });
                    });
                    this.addMessage('ä½¿ç”¨ /help <æŒ‡ä»¤åç¨±> æŸ¥çœ‹è©³ç´°ç”¨æ³•', 'info');
                } else {
                    const cmd = args[0].toLowerCase();
                    const commandInfo = this.commandRegistry.get(cmd);
                    if (commandInfo) {
                        this.addMessage(`=== /${cmd} æŒ‡ä»¤å¹«åŠ© ===`, 'command');
                        this.addMessage(`æè¿°: ${commandInfo.description}`, 'info');
                        this.addMessage(`ç”¨æ³•: ${commandInfo.usage}`, 'info');
                        this.addMessage(`åˆ†é¡: ${commandInfo.category}`, 'info');
                    } else {
                        this.addMessage(`æŒ‡ä»¤ /${cmd} ä¸å­˜åœ¨`, 'error');
                    }
                }
            }

            clearMessages() {
                this.messages = [];
                this.chatMessages.innerHTML = '';
                this.addMessage('èŠå¤©è¨˜éŒ„å·²æ¸…é™¤', 'system');
            }

            showTime() {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('zh-TW');
                const dateStr = now.toLocaleDateString('zh-TW');
                this.addMessage(`ç•¶å‰æ™‚é–“: ${dateStr} ${timeStr}`, 'info');
            }

            handleTeleport(args) {
                if (args.length !== 3) {
                    this.addMessage('ç”¨æ³•: /tp <x> <y> <z>', 'error');
                    return;
                }

                const x = parseFloat(args[0]);
                const y = parseFloat(args[1]);
                const z = parseFloat(args[2]);

                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    this.addMessage('åº§æ¨™å¿…é ˆæ˜¯æ•¸å­—', 'error');
                    return;
                }

                if (window.game && window.game.player) {
                    window.game.player.x = x;
                    window.game.player.y = y;
                    window.game.player.z = z;
                    this.addMessage(`å·²å‚³é€åˆ° (${x}, ${y}, ${z})`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•å‚³é€ï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            toggleFly() {
                if (window.game) {
                    window.game.flying = !window.game.flying;
                    const status = window.game.flying ? 'é–‹å•Ÿ' : 'é—œé–‰';
                    this.addMessage(`é£›è¡Œæ¨¡å¼å·²${status}`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•åˆ‡æ›é£›è¡Œæ¨¡å¼ï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            listPlayers() {
                if (window.game && window.game.isMultiplayer) {
                    const players = window.game.multiplayerManager.getOtherPlayers();
                    const currentPlayer = window.game.multiplayerManager.playerName || 'ä½ ';

                    this.addMessage(`=== åœ¨ç·šç©å®¶ (${players.length + 1}) ===`, 'info');
                    this.addMessage(`â€¢ ${currentPlayer} (ä½ )`, 'info');

                    players.forEach(player => {
                        this.addMessage(`â€¢ ${player.name}`, 'info');
                    });
                } else {
                    this.addMessage('å–®äººæ¨¡å¼ - åªæœ‰ä½ ä¸€å€‹ç©å®¶', 'info');
                }
            }

            showPing() {
                if (window.game && window.game.isMultiplayer && window.firebaseAvailable) {
                    const startTime = Date.now();
                    window.database.ref('.info/serverTimeOffset').once('value', () => {
                        const ping = Date.now() - startTime;
                        this.addMessage(`ç¶²çµ¡å»¶é²: ${ping}ms`, 'info');
                    });
                } else {
                    this.addMessage('ç„¡æ³•æ¸¬é‡å»¶é²ï¼šæœªé€£æ¥åˆ°ä¼ºæœå™¨', 'warning');
                }
            }

            showCoords() {
                if (window.game && window.game.player) {
                    const x = window.game.player.x.toFixed(2);
                    const y = window.game.player.y.toFixed(2);
                    const z = window.game.player.z.toFixed(2);
                    this.addMessage(`ç•¶å‰åº§æ¨™: X=${x}, Y=${y}, Z=${z}`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•ç²å–åº§æ¨™ï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            showBiome() {
                if (window.game && window.game.player) {
                    const biome = window.game.getBiome(window.game.player.x, window.game.player.z);
                    this.addMessage(`ç•¶å‰ç”Ÿç‰©ç¾¤è½: ${biome}`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•ç²å–ç”Ÿç‰©ç¾¤è½ï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            showFPS() {
                if (window.game) {
                    this.addMessage(`ç•¶å‰FPS: ${window.game.fps}`, 'info');
                    this.addMessage(`ä¸‰è§’å½¢æ•¸: ${window.game.triangleCount}`, 'info');
                    this.addMessage(`ç¹ªè£½èª¿ç”¨: ${window.game.drawCalls}`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•ç²å–FPSï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            showSeed() {
                if (window.game) {
                    this.addMessage(`ä¸–ç•Œç¨®å­: ${window.game.worldSeed || 'random'}`, 'info');
                } else {
                    this.addMessage('ç„¡æ³•ç²å–ç¨®å­ï¼šéŠæˆ²æœªå•Ÿå‹•', 'error');
                }
            }

            changeGamemode(args) {
                if (args.length === 0) {
                    this.addMessage('ç”¨æ³•: /gamemode <creative|survival>', 'error');
                    return;
                }

                const mode = args[0].toLowerCase();
                if (mode === 'creative' || mode === 'c') {
                    this.addMessage('éŠæˆ²æ¨¡å¼å·²åˆ‡æ›ç‚ºå‰µé€ æ¨¡å¼', 'info');
                } else if (mode === 'survival' || mode === 's') {
                    this.addMessage('éŠæˆ²æ¨¡å¼å·²åˆ‡æ›ç‚ºç”Ÿå­˜æ¨¡å¼', 'info');
                } else {
                    this.addMessage('ç„¡æ•ˆçš„éŠæˆ²æ¨¡å¼ã€‚å¯ç”¨æ¨¡å¼: creative, survival', 'error');
                }
            }

            navigateHistory(direction) {
                if (this.chatHistory.length === 0) return;

                this.historyIndex += direction;

                if (this.historyIndex < -1) {
                    this.historyIndex = -1;
                } else if (this.historyIndex >= this.chatHistory.length) {
                    this.historyIndex = this.chatHistory.length - 1;
                }

                if (this.historyIndex === -1) {
                    this.messageInput.value = '';
                } else {
                    this.messageInput.value = this.chatHistory[this.historyIndex];
                }
            }

            autoComplete() {
                const input = this.messageInput.value;
                const cursorPos = this.messageInput.selectionStart;
                const beforeCursor = input.substring(0, cursorPos);

                if (beforeCursor.startsWith('/')) {
                    const cmdPart = beforeCursor.slice(1);
                    const matches = Array.from(this.commandRegistry.keys()).filter(cmd =>
                        cmd.startsWith(cmdPart.toLowerCase())
                    );

                    if (matches.length === 1) {
                        this.messageInput.value = '/' + matches[0] + input.substring(cursorPos);
                        this.messageInput.setSelectionRange(matches[0].length + 1, matches[0].length + 1);
                    } else if (matches.length > 1) {
                        this.addMessage(`å¯ç”¨æŒ‡ä»¤: ${matches.join(', ')}`, 'info');
                    }
                } else {
                    const words = beforeCursor.split(' ');
                    const lastWord = words[words.length - 1];

                    if (lastWord.length < 2) return;

                    let playerNames = [];
                    if (window.game && window.game.isMultiplayer) {
                        const players = window.game.multiplayerManager.getOtherPlayers();
                        playerNames = players.map(p => p.name);
                        playerNames.push(window.game.multiplayerManager.playerName || 'ä½ ');
                    }

                    const matches = playerNames.filter(name =>
                        name.toLowerCase().startsWith(lastWord.toLowerCase())
                    );

                    if (matches.length === 1) {
                        words[words.length - 1] = matches[0];
                        const newValue = words.join(' ') + input.substring(cursorPos);
                        this.messageInput.value = newValue;
                        this.messageInput.setSelectionRange(words.join(' ').length, words.join(' ').length);
                    } else if (matches.length > 1) {
                        this.addMessage(`å¯èƒ½çš„ç©å®¶: ${matches.join(', ')}`, 'info');
                    }
                }
            }

            receiveMessage(data) {
                this.addMessage(data.message, 'player', data.playerName);
            }

            scrollToBottom() {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            isActive() {
                return this.isInputActive;
            }

            destroy() {
                if (this.visibilityTimer) {
                    clearTimeout(this.visibilityTimer);
                }
                if (this.chatOverlay && this.chatOverlay.parentNode) {
                    this.chatOverlay.parentNode.removeChild(this.chatOverlay);
                }
            }
        }

        // å„ªåŒ–çš„ç‰©å“æ¬„æ»¾å‹•ç³»çµ±ï¼ˆæ”¯æ´æ»‘é¼ æ»¾è¼ªï¼‰
        class InventoryScrollSystem {
            constructor() {
                this.inventory = document.getElementById('inventory');
                this.isScrolling = false;
                this.scrollVelocity = 0;
                this.scrollThreshold = 50;
                this.accumulatedDelta = 0;
                this.friction = 0.95;
                this.setupScrolling();
            }

            setupScrolling() {
                // æ»‘é¼ æ»¾è¼ª - å®Œå…¨æŒ‰ç…§Minecraftæ–¹å¼
                document.addEventListener('wheel', (e) => {
                    if (!window.game || !window.game.gameStarted || window.game.isPaused || window.game.chatSystem.isActive()) return;

                    e.preventDefault();
                    this.handleScroll(e.deltaY);
                });

                // è§¸æ§æ»¾å‹•
                let startX = 0;
                let startScrollLeft = 0;

                this.inventory.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startScrollLeft = this.inventory.scrollLeft;
                });

                this.inventory.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const x = e.touches[0].clientX;
                    const walk = (x - startX) * 2;
                    this.inventory.scrollLeft = startScrollLeft - walk;
                });

                this.startInertiaAnimation();
            }

            handleScroll(deltaY) {
                this.accumulatedDelta += deltaY;

                if (Math.abs(this.accumulatedDelta) >= this.scrollThreshold) {
                    const direction = this.accumulatedDelta > 0 ? 1 : -1;
                    this.switchBlock(direction);
                    this.accumulatedDelta = 0;
                }
            }

            switchBlock(direction) {
                if (!window.game) return;

                const blockTypes = Object.keys(window.game.blockTypes);
                const currentIndex = blockTypes.indexOf(window.game.selectedBlock);
                let newIndex;

                if (direction > 0) {
                    newIndex = (currentIndex + 1) % blockTypes.length;
                } else {
                    newIndex = (currentIndex - 1 + blockTypes.length) % blockTypes.length;
                }

                window.game.selectedBlock = blockTypes[newIndex];
                window.game.updateInventoryUI();
                window.game.showBlockSwitchNotification();

                const selectedSlot = document.querySelector('.inventory-slot.active');
                if (selectedSlot) {
                    selectedSlot.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'center'
                    });
                }
            }

            startInertiaAnimation() {
                const animate = () => {
                    if (Math.abs(this.scrollVelocity) > 0.1) {
                        this.inventory.scrollLeft += this.scrollVelocity;
                        this.scrollVelocity *= this.friction;
                    }
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        // ä¿®å¾©ï¼šç§»å‹•ç«¯æ§åˆ¶ç³»çµ± - ä¿®å¾©æ–æ¡¿æ–¹å‘å’Œæ·»åŠ æ½›è¡ŒæŒ‰éˆ•
        // å®Œå…¨é‡å¯«çš„ç§»å‹•ç«¯æ§åˆ¶ç³»çµ± - æ”¯æŒå¤šé»è§¸æ§
        // å®Œå…¨é‡å¯«çš„ç§»å‹•ç«¯æ§åˆ¶ç³»çµ± - æ”¯æŒå¤šé»è§¸æ§
        class MobileControls {
            constructor(game) {
                this.game = game;
                this.isMobile = this.detectMobile();

                // æ–æ¡¿ç›¸é—œ
                this.joystickActive = false;
                this.joystickTouchId = null;
                this.joystickCenter = { x: 0, y: 0 };
                this.joystickRadius = 60;
                this.moveVector = { x: 0, y: 0 };

                // è¦–è§’æ§åˆ¶ç›¸é—œ
                this.lookTouchId = null;
                this.lastLookPosition = null;

                // åˆå§‹åŒ–
                if (this.isMobile) {
                    this.init();
                }
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                    (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
            }

            init() {
                // é¡¯ç¤ºç§»å‹•æ§åˆ¶ä»‹é¢
                const mobileControls = document.getElementById('mobileControls');
                if (mobileControls) {
                    mobileControls.style.display = 'block';
                }

                // è¨­ç½®å„å€‹æ§åˆ¶çµ„ä»¶
                this.setupJoystick();
                this.setupButtons();
                this.setupMenuButton();
                this.setupViewControl();
            }

            // ========== æ–æ¡¿æ§åˆ¶ ==========
            setupJoystick() {
                const joystick = document.getElementById('moveJoystick');
                const knob = document.getElementById('moveKnob');

                if (!joystick || !knob) {
                    console.error('æ‰¾ä¸åˆ°æ–æ¡¿å…ƒç´ ');
                    return;
                }

                // æ–æ¡¿è§¸æ§é–‹å§‹
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // åªè™•ç†ç¬¬ä¸€å€‹è§¸æ§é»ä½œç‚ºæ–æ¡¿æ§åˆ¶
                    if (this.joystickTouchId === null && e.touches.length > 0) {
                        const touch = e.touches[0];
                        this.joystickTouchId = touch.identifier;
                        this.joystickActive = true;

                        // æ›´æ–°æ–æ¡¿ä¸­å¿ƒä½ç½®
                        const rect = joystick.getBoundingClientRect();
                        this.joystickCenter = {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        };

                        joystick.style.opacity = '1';
                        this.updateJoystickPosition(touch.clientX, touch.clientY);
                    }
                });

                // æ–æ¡¿è§¸æ§ç§»å‹•
                document.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive || this.joystickTouchId === null) return;

                    // æ‰¾åˆ°å°æ‡‰çš„è§¸æ§é»
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.joystickTouchId) {
                            e.preventDefault();
                            this.updateJoystickPosition(touch.clientX, touch.clientY);
                            break;
                        }
                    }
                });

                // æ–æ¡¿è§¸æ§çµæŸ
                document.addEventListener('touchend', (e) => {
                    // æª¢æŸ¥æ˜¯å¦æ˜¯æ–æ¡¿çš„è§¸æ§çµæŸ
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.identifier === this.joystickTouchId) {
                            this.resetJoystick();
                            break;
                        }
                    }
                });

                // è§¸æ§å–æ¶ˆï¼ˆä¾‹å¦‚ä¾†é›»ä¸­æ–·ï¼‰
                document.addEventListener('touchcancel', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.identifier === this.joystickTouchId) {
                            this.resetJoystick();
                            break;
                        }
                    }
                });
            }

            updateJoystickPosition(touchX, touchY) {
                const knob = document.getElementById('moveKnob');
                if (!knob) return;

                const dx = touchX - this.joystickCenter.x;
                const dy = touchY - this.joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= this.joystickRadius) {
                    // åœ¨æ–æ¡¿ç¯„åœå…§
                    knob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    this.moveVector.x = dx / this.joystickRadius;
                    this.moveVector.y = -dy / this.joystickRadius; // Yè»¸åè½‰
                } else {
                    // é™åˆ¶åœ¨æ–æ¡¿é‚Šç·£
                    const angle = Math.atan2(dy, dx);
                    const limitedX = Math.cos(angle) * this.joystickRadius;
                    const limitedY = Math.sin(angle) * this.joystickRadius;
                    knob.style.transform = `translate(-50%, -50%) translate(${limitedX}px, ${limitedY}px)`;
                    this.moveVector.x = Math.cos(angle);
                    this.moveVector.y = -Math.sin(angle); // Yè»¸åè½‰
                }
            }

            resetJoystick() {
                const joystick = document.getElementById('moveJoystick');
                const knob = document.getElementById('moveKnob');

                this.joystickActive = false;
                this.joystickTouchId = null;
                this.moveVector = { x: 0, y: 0 };

                if (knob) {
                    knob.style.transform = 'translate(-50%, -50%)';
                }
                if (joystick) {
                    joystick.style.opacity = '0.8';
                }
            }

            // ========== é¸å–®æŒ‰éˆ•ï¼ˆESCåŠŸèƒ½ï¼‰ ==========
            setupMenuButton() {
                const menuBtn = document.getElementById('mobileMenuBtn');
                if (!menuBtn) {
                    console.warn('æ‰¾ä¸åˆ°é¸å–®æŒ‰éˆ•');
                    return;
                }

                menuBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // æä¾›è¦–è¦ºåé¥‹
                    menuBtn.style.transform = 'scale(0.95)';

                    // åŸ·è¡Œæš«åœ/æ¢å¾©åŠŸèƒ½ï¼ˆé¡ä¼¼ESCéµï¼‰
                    if (this.game.gameStarted) {
                        if (this.game.isPaused) {
                            this.game.resumeGame();
                        } else {
                            this.game.pauseGame();
                        }
                    }

                    // æ¢å¾©æŒ‰éˆ•å¤§å°
                    setTimeout(() => {
                        menuBtn.style.transform = 'scale(1)';
                    }, 100);
                });
            }

            // ========== æŒ‰éˆ•æ§åˆ¶ ==========
            setupButtons() {
                // è·³èºæŒ‰éˆ•ï¼ˆæŒ‰ä½ï¼‰
                this.setupButton('jumpBtn', {
                    start: () => {
                        this.game.keys['Space'] = true;
                    },
                    end: () => {
                        this.game.keys['Space'] = false;
                    }
                }, false);

                // æ½›è¡ŒæŒ‰éˆ•ï¼ˆåˆ‡æ›å¼ï¼‰
                this.setupButton('sneakBtn', {
                    start: () => {
                        this.game.keys['ShiftLeft'] = !this.game.keys['ShiftLeft'];
                        const btn = document.getElementById('sneakBtn');
                        if (btn) {
                            if (this.game.keys['ShiftLeft']) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        }
                    }
                }, true);

                // ç ´å£æ–¹å¡ŠæŒ‰éˆ•ï¼ˆå–®æ“Šï¼‰
                this.setupButton('breakBtn', {
                    start: () => {
                        if (!this.game.gameStarted || !this.game.worldGenerated) return;

                        const target = this.game.getTargetBlock();
                        if (target) {
                            this.game.removeBlock(target.x, target.y, target.z);
                            if (this.game.isMultiplayer && this.game.multiplayerManager.isConnected) {
                                this.game.multiplayerManager.sendBlockUpdate(target.x, target.y, target.z, null, 'break');
                            }
                        }
                    }
                }, false);

                // æ”¾ç½®æ–¹å¡ŠæŒ‰éˆ•ï¼ˆå–®æ“Šï¼‰
                this.setupButton('placeBtn', {
                    start: () => {
                        if (!this.game.gameStarted || !this.game.worldGenerated) return;

                        const target = this.game.getTargetBlock();
                        if (target) {
                            const place = this.game.getPlacePosition(target);
                            if (place && !this.game.isPlayerColliding(place.x, place.y, place.z)) {
                                this.game.setBlock(place.x, place.y, place.z, this.game.selectedBlock);
                                this.game.regenerateNearbyChunks(place.x, place.y, place.z);
                                if (this.game.isMultiplayer && this.game.multiplayerManager.isConnected) {
                                    this.game.multiplayerManager.sendBlockUpdate(place.x, place.y, place.z, this.game.selectedBlock, 'place');
                                }
                            }
                        }
                    }
                }, false);

                // é£›è¡ŒæŒ‰éˆ•ï¼ˆåˆ‡æ›å¼ï¼‰
                this.setupButton('flyBtn', {
                    start: () => {
                        this.game.flying = !this.game.flying;
                        const btn = document.getElementById('flyBtn');
                        if (btn) {
                            if (this.game.flying) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        }
                        const status = this.game.flying ? 'é–‹å•Ÿ' : 'é—œé–‰';
                        this.game.chatSystem.addMessage(`é£›è¡Œæ¨¡å¼ï¼š${status}`, 'system');
                    }
                }, true);

                // èŠå¤©æŒ‰éˆ•ï¼ˆå–®æ“Šï¼‰
                this.setupButton('mobileChatBtn', {
                    start: () => {
                        if (this.game.gameStarted) {
                            console.log('é–‹å•ŸèŠå¤©');
                            this.game.chatSystem.activateInput();

                            // æä¾›è¦–è¦ºåé¥‹
                            const btn = document.getElementById('mobileChatBtn');
                            if (btn) {
                                btn.style.background = 'rgba(255, 107, 53, 0.3)';
                                setTimeout(() => {
                                    btn.style.background = '';
                                }, 200);
                            }
                        }
                    }
                }, false);
            }

            setupButton(buttonId, handlers, isToggle = false) {
                const button = document.getElementById(buttonId);
                if (!button) {
                    console.warn(`æ‰¾ä¸åˆ°æŒ‰éˆ•: ${buttonId}`);
                    return;
                }

                // è§¸æ§äº‹ä»¶
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (handlers.start) handlers.start();

                    // è¦–è¦ºåé¥‹ï¼ˆéåˆ‡æ›æŒ‰éˆ•ï¼‰
                    if (!isToggle) {
                        button.style.transform = 'scale(0.95)';
                    }
                });

                if (handlers.end) {
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handlers.end();
                        button.style.transform = 'scale(1)';
                    });

                    button.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        handlers.end();
                        button.style.transform = 'scale(1)';
                    });
                } else if (!isToggle) {
                    // å¦‚æœæ²’æœ‰endè™•ç†å™¨ä¸”ä¸æ˜¯åˆ‡æ›æŒ‰éˆ•ï¼Œtouchendæ™‚æ¢å¾©ç¸®æ”¾
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        button.style.transform = 'scale(1)';
                    });

                    button.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        button.style.transform = 'scale(1)';
                    });
                }
            }

            // ========== è¦–è§’æ§åˆ¶ï¼ˆå¤šé»è§¸æ§ï¼‰ ==========
            setupViewControl() {
                const canvas = this.game.canvas;

                // è¦–è§’æ§åˆ¶è§¸æ§é–‹å§‹
                canvas.addEventListener('touchstart', (e) => {
                    // æ‰¾ä¸€å€‹ä¸æ˜¯æ–æ¡¿çš„è§¸æ§é»ä½œç‚ºè¦–è§’æ§åˆ¶
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];

                        // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰è¦–è§’æ§åˆ¶é»ï¼Œæˆ–æ˜¯å¦æ˜¯æ–æ¡¿è§¸æ§
                        if (this.lookTouchId === null && touch.identifier !== this.joystickTouchId) {
                            // æª¢æŸ¥è§¸æ§é»æ˜¯å¦åœ¨UIå…ƒç´ ä¸Š
                            const element = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (element && (element.id === 'gameCanvas')) {
                                this.lookTouchId = touch.identifier;
                                this.lastLookPosition = {
                                    x: touch.clientX,
                                    y: touch.clientY
                                };
                                break;
                            }
                        }
                    }
                });

                // è¦–è§’æ§åˆ¶è§¸æ§ç§»å‹•
                canvas.addEventListener('touchmove', (e) => {
                    if (this.lookTouchId === null) return;

                    // æ‰¾åˆ°è¦–è§’æ§åˆ¶çš„è§¸æ§é»
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouchId && this.lastLookPosition) {
                            e.preventDefault();

                            const deltaX = touch.clientX - this.lastLookPosition.x;
                            const deltaY = touch.clientY - this.lastLookPosition.y;

                            // æ‡‰ç”¨éˆæ•åº¦è¨­ç½®
                            const sensitivity = this.game.gameSettings.get('mouseSensitivity') * 0.005;

                            // æ›´æ–°ç©å®¶è¦–è§’
                            this.game.player.angle += deltaX * sensitivity;
                            this.game.player.pitch -= deltaY * sensitivity;

                            // é™åˆ¶ä¿¯ä»°è§’åº¦
                            this.game.player.pitch = Math.max(
                                -Math.PI / 2 + 0.1,
                                Math.min(Math.PI / 2 - 0.1, this.game.player.pitch)
                            );

                            // æ›´æ–°æœ€å¾Œä½ç½®
                            this.lastLookPosition = {
                                x: touch.clientX,
                                y: touch.clientY
                            };
                            break;
                        }
                    }
                });

                // è¦–è§’æ§åˆ¶è§¸æ§çµæŸ
                canvas.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.identifier === this.lookTouchId) {
                            this.lookTouchId = null;
                            this.lastLookPosition = null;
                            break;
                        }
                    }
                });

                // è§¸æ§å–æ¶ˆ
                canvas.addEventListener('touchcancel', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.identifier === this.lookTouchId) {
                            this.lookTouchId = null;
                            this.lastLookPosition = null;
                            break;
                        }
                        if (touch.identifier === this.joystickTouchId) {
                            this.resetJoystick();
                            break;
                        }
                    }
                });

                // é˜²æ­¢é è¨­çš„è§¸æ§è¡Œç‚º
                canvas.addEventListener('touchstart', (e) => {
                    // åªåœ¨éUIå…ƒç´ ä¸Šé˜²æ­¢é»˜èªè¡Œç‚º
                    const element = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
                    if (!element || (!element.classList.contains('mobile-btn') &&
                        !element.classList.contains('mobile-chat-btn') &&
                        !element.classList.contains('mobile-menu-btn'))) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            // ========== æ›´æ–°æ–¹æ³• ==========
            update() {
                if (!this.isMobile || !this.joystickActive) return;

                // æ ¹æ“šæ–æ¡¿è¼¸å…¥è¨ˆç®—ç§»å‹•
                const speed = this.game.moveSpeed;
                const angle = this.game.player.angle;

                // è¨ˆç®—ç§»å‹•å‘é‡
                const forwardX = Math.cos(angle) * this.moveVector.y * speed;
                const forwardZ = Math.sin(angle) * this.moveVector.y * speed;
                const rightX = Math.cos(angle + Math.PI / 2) * this.moveVector.x * speed;
                const rightZ = Math.sin(angle + Math.PI / 2) * this.moveVector.x * speed;

                // æ‡‰ç”¨ç§»å‹•
                const newX = this.game.player.x + forwardX + rightX;
                const newZ = this.game.player.z + forwardZ + rightZ;

                // ç¢°æ’æª¢æ¸¬
                if (!this.game.checkCollision(newX, this.game.player.y, this.game.player.z)) {
                    this.game.player.x = newX;
                }
                if (!this.game.checkCollision(this.game.player.x, this.game.player.y, newZ)) {
                    this.game.player.z = newZ;
                }
            }

            // ========== è¼”åŠ©æ–¹æ³• ==========
            handleBlockBreak() {
                if (!this.game.gameStarted || !this.game.worldGenerated) return;

                const target = this.game.getTargetBlock();
                if (target) {
                    this.game.removeBlock(target.x, target.y, target.z);
                    if (this.game.isMultiplayer && this.game.multiplayerManager.isConnected) {
                        this.game.multiplayerManager.sendBlockUpdate(target.x, target.y, target.z, null, 'break');
                    }
                }
            }

            handleBlockPlace() {
                if (!this.game.gameStarted || !this.game.worldGenerated) return;

                const target = this.game.getTargetBlock();
                if (target) {
                    const place = this.game.getPlacePosition(target);
                    if (place && !this.game.isPlayerColliding(place.x, place.y, place.z)) {
                        this.game.setBlock(place.x, place.y, place.z, this.game.selectedBlock);
                        this.game.regenerateNearbyChunks(place.x, place.y, place.z);
                        if (this.game.isMultiplayer && this.game.multiplayerManager.isConnected) {
                            this.game.multiplayerManager.sendBlockUpdate(place.x, place.y, place.z, this.game.selectedBlock, 'place');
                        }
                    }
                }
            }
        }

        // å¤šäººéŠæˆ²ç¶²è·¯ç®¡ç†é¡åˆ¥ï¼ˆå„ªåŒ–ç‰ˆï¼‰
        class FirebaseMultiplayerManager {
            constructor() {
                this.isHost = false;
                this.isConnected = false;
                this.roomId = null;
                this.playerId = null;
                this.playerName = '';
                this.otherPlayers = new Map();
                this.callbacks = {
                    onPlayerJoin: null,
                    onPlayerLeave: null,
                    onPlayerMove: null,
                    onBlockUpdate: null,
                    onChatMessage: null,
                    onRoomUpdate: null
                };

                this.roomRef = null;
                this.playersRef = null;
                this.messagesRef = null;
                this.blocksRef = null;
                this.listeners = [];
                this.lastUpdateTime = 0;
                this.updateThrottle = 50;
                this.connectionQuality = 'good';
            }

            setCallback(event, callback) {
                this.callbacks[event] = callback;
            }

            async connectToRoom(roomId, playerName) {
                return new Promise((resolve, reject) => {
                    try {
                        if (!firebaseAvailable) {
                            reject(new Error('Firebaseæœªé€£æ¥'));
                            return;
                        }

                        this.roomId = roomId || this.generateRoomId();
                        this.playerName = playerName || 'Player';
                        this.playerId = this.generatePlayerId();
                        this.isHost = !roomId;

                        this.roomRef = database.ref(`rooms/${this.roomId}`);
                        this.playersRef = this.roomRef.child('players');
                        this.messagesRef = this.roomRef.child('messages');
                        this.blocksRef = this.roomRef.child('blocks');

                        this.roomRef.once('value')
                            .then((snapshot) => {
                                const roomData = snapshot.val();

                                if (!roomData && !this.isHost) {
                                    reject(new Error('æˆ¿é–“ä¸å­˜åœ¨'));
                                    return;
                                }

                                if (roomData && roomData.players) {
                                    const playerCount = Object.keys(roomData.players).length;
                                    if (playerCount >= 10) {
                                        reject(new Error('æˆ¿é–“å·²æ»¿'));
                                        return;
                                    }
                                }

                                return this.joinRoom();
                            })
                            .then(() => {
                                this.isConnected = true;
                                this.setupListeners();
                                this.startConnectionMonitoring();

                                console.log(`å·²é€£æ¥åˆ°æˆ¿é–“: ${this.roomId}, ç©å®¶ID: ${this.playerId}`);

                                resolve({
                                    roomId: this.roomId,
                                    playerId: this.playerId,
                                    isHost: this.isHost,
                                    success: true
                                });
                            })
                            .catch(reject);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            async joinRoom() {
                const playerData = {
                    id: this.playerId,
                    name: this.playerName,
                    x: Math.random() * 20 - 10,
                    y: 10,
                    z: Math.random() * 20 - 10,
                    angle: 0,
                    pitch: 0,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP,
                    isHost: this.isHost,
                    online: true,
                    joinTime: firebase.database.ServerValue.TIMESTAMP
                };

                await this.playersRef.child(this.playerId).set(playerData);
                this.playersRef.child(this.playerId).onDisconnect().remove();

                if (this.isHost) {
                    await this.roomRef.update({
                        created: firebase.database.ServerValue.TIMESTAMP,
                        host: this.playerId,
                        maxPlayers: 10,
                        gameMode: 'creative'
                    });
                }
            }

            setupListeners() {
                const playersAddedListener = this.playersRef.on('child_added', (snapshot) => {
                    const player = snapshot.val();
                    if (player.id !== this.playerId) {
                        this.otherPlayers.set(player.id, player);
                        if (this.callbacks.onPlayerJoin) {
                            this.callbacks.onPlayerJoin(player);
                        }
                        this.updateRoomInfo();
                    }
                });

                const playersRemovedListener = this.playersRef.on('child_removed', (snapshot) => {
                    const player = snapshot.val();
                    if (player.id !== this.playerId) {
                        this.otherPlayers.delete(player.id);
                        if (this.callbacks.onPlayerLeave) {
                            this.callbacks.onPlayerLeave(player);
                        }
                        this.updateRoomInfo();
                    }
                });

                const playersChangedListener = this.playersRef.on('child_changed', (snapshot) => {
                    const player = snapshot.val();
                    if (player.id !== this.playerId) {
                        this.otherPlayers.set(player.id, player);
                        if (this.callbacks.onPlayerMove) {
                            this.callbacks.onPlayerMove({
                                type: 'playerUpdate',
                                playerId: player.id,
                                playerName: player.name,
                                x: player.x,
                                y: player.y,
                                z: player.z,
                                angle: player.angle,
                                pitch: player.pitch
                            });
                        }
                    }
                });

                const messagesListener = this.messagesRef.limitToLast(1).on('child_added', (snapshot) => {
                    const message = snapshot.val();
                    if (message.playerId !== this.playerId) {
                        if (this.callbacks.onChatMessage) {
                            this.callbacks.onChatMessage(message);
                        }
                    }
                });

                const blocksListener = this.blocksRef.limitToLast(1).on('child_added', (snapshot) => {
                    const blockUpdate = snapshot.val();
                    if (blockUpdate.playerId !== this.playerId) {
                        if (this.callbacks.onBlockUpdate) {
                            this.callbacks.onBlockUpdate(blockUpdate);
                        }
                    }
                });

                this.listeners = [
                    { ref: this.playersRef, event: 'child_added', listener: playersAddedListener },
                    { ref: this.playersRef, event: 'child_removed', listener: playersRemovedListener },
                    { ref: this.playersRef, event: 'child_changed', listener: playersChangedListener },
                    { ref: this.messagesRef, event: 'child_added', listener: messagesListener },
                    { ref: this.blocksRef, event: 'child_added', listener: blocksListener }
                ];
            }

            startConnectionMonitoring() {
                setInterval(() => {
                    if (this.isConnected) {
                        const startTime = Date.now();
                        database.ref('.info/serverTimeOffset').once('value', () => {
                            const ping = Date.now() - startTime;
                            if (ping > 500) {
                                this.connectionQuality = 'poor';
                                this.updateThrottle = 200;
                            } else if (ping > 200) {
                                this.connectionQuality = 'fair';
                                this.updateThrottle = 100;
                            } else {
                                this.connectionQuality = 'good';
                                this.updateThrottle = 50;
                            }
                        });
                    }
                }, 5000);
            }

            sendPlayerUpdate(playerData) {
                if (!this.isConnected) return;

                const now = Date.now();
                if (now - this.lastUpdateTime < this.updateThrottle) {
                    return;
                }
                this.lastUpdateTime = now;

                this.playersRef.child(this.playerId).update({
                    x: Math.round(playerData.x * 100) / 100,
                    y: Math.round(playerData.y * 100) / 100,
                    z: Math.round(playerData.z * 100) / 100,
                    angle: Math.round(playerData.angle * 1000) / 1000,
                    pitch: Math.round(playerData.pitch * 1000) / 1000,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                }).catch(error => {
                    console.error('ç™¼é€ç©å®¶æ›´æ–°å¤±æ•—:', error);
                });
            }

            sendBlockUpdate(x, y, z, blockType, action) {
                if (!this.isConnected) return;

                const blockData = {
                    type: 'blockUpdate',
                    playerId: this.playerId,
                    playerName: this.playerName,
                    x: Math.floor(x),
                    y: Math.floor(y),
                    z: Math.floor(z),
                    blockType: blockType,
                    action: action,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };

                this.blocksRef.push(blockData).catch(error => {
                    console.error('ç™¼é€æ–¹å¡Šæ›´æ–°å¤±æ•—:', error);
                });
            }

            sendChatMessage(message) {
                if (!this.isConnected || !message.trim()) return;

                const chatData = {
                    type: 'chatMessage',
                    playerId: this.playerId,
                    playerName: this.playerName,
                    message: message.trim().substring(0, 256),
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };

                this.messagesRef.push(chatData).catch(error => {
                    console.error('ç™¼é€èŠå¤©è¨Šæ¯å¤±æ•—:', error);
                });
            }

            updateRoomInfo() {
                if (this.callbacks.onRoomUpdate) {
                    const allPlayers = [
                        {
                            id: this.playerId,
                            name: this.playerName,
                            isHost: this.isHost
                        },
                        ...Array.from(this.otherPlayers.values())
                    ];

                    this.callbacks.onRoomUpdate({
                        roomId: this.roomId,
                        players: allPlayers
                    });
                }
            }

            disconnect() {
                this.listeners.forEach(({ ref, event, listener }) => {
                    ref.off(event, listener);
                });
                this.listeners = [];

                if (this.playersRef && this.playerId) {
                    this.playersRef.child(this.playerId).remove();
                }

                if (this.isHost && this.otherPlayers.size === 0 && this.roomRef) {
                    this.roomRef.remove();
                }

                this.otherPlayers.clear();
                this.isConnected = false;
                this.roomId = null;
                this.playerId = null;
                console.log('å·²æ–·é–‹Firebaseé€£æ¥');
            }

            getOtherPlayers() {
                return Array.from(this.otherPlayers.values());
            }

            getConnectionStatus() {
                return {
                    isConnected: this.isConnected,
                    roomId: this.roomId,
                    playerId: this.playerId,
                    playerName: this.playerName,
                    playerCount: this.otherPlayers.size + 1,
                    isHost: this.isHost,
                    firebaseConnected: firebaseAvailable,
                    connectionQuality: this.connectionQuality
                };
            }

            generateRoomId() {
                return Math.random().toString(36).substr(2, 6).toUpperCase();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }
        }

        // ä¿®å¾©ï¼šWebGL Minecraft ä¸»éŠæˆ²é¡åˆ¥ - å¯¦ç¾çœŸæ­£çš„20 TPSç³»çµ±
        class WebGLMinecraft {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // åˆå§‹åŒ–WebGL
                this.gl = this.canvas.getContext('webgl', {
                    antialias: true,
                    alpha: false,
                    depth: true,
                    stencil: false,
                    preserveDrawingBuffer: false,
                    powerPreference: 'high-performance'
                }) || this.canvas.getContext('experimental-webgl');

                if (!this.gl) {
                    this.showError('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´WebGLï¼');
                    return;
                }

                // ç³»çµ±åˆå§‹åŒ–
                this.gameSettings = new GameSettings();
                this.chatSystem = new MinecraftChatSystem();
                this.multiplayerManager = new FirebaseMultiplayerManager();
                this.mobileControls = new MobileControls(this);
                this.inventoryScrollSystem = new InventoryScrollSystem();
                this.isMultiplayer = false;

                // ä¿®å¾©ï¼šå¯¦ç¾çœŸæ­£çš„Minecraft tickç³»çµ±
                this.TICKS_PER_SECOND = 20; // Minecraftæ¨™æº–TPS
                this.TICK_INTERVAL = 1000 / this.TICKS_PER_SECOND; // 50ms per tick
                this.lastTickTime = 0;
                this.tickAccumulator = 0;
                this.currentTick = 0;

                // æ€§èƒ½è¨ˆæ•¸å™¨
                this.frameCount = 0;
                this.lastFrameTime = 0;
                this.fps = 60;
                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                // éŠæˆ²ç‹€æ…‹
                this.gameStarted = false;
                this.worldGenerated = false;
                this.flying = false;
                this.isPaused = false;
                this.worldSeed = Math.random().toString(36).substr(2, 9);

                // ä¿®å¾©ï¼šä½¿ç”¨çœŸå¯¦Minecraftç§»å‹•é€Ÿåº¦ï¼ˆåŸºæ–¼tickï¼‰
                this.moveSpeed = 4.317 / this.TICKS_PER_SECOND; // 4.317 m/s Ã· 20 TPS
                this.sprintMultiplier = 1.3;
                this.sneakMultiplier = 0.3;
                this.flySpeedMultiplier = 2.0;

                // ç©å®¶ - ä½¿ç”¨çœŸå¯¦Minecraftæ•¸å€¼
                // åœ¨åˆå§‹åŒ–ç©å®¶æ™‚æ·»åŠ ç›¸æ©Ÿä½ç½®å±¬æ€§
                this.player = {
                    x: 0, y: 10, z: 0,
                    angle: 0, pitch: 0,
                    velocity: { x: 0, y: 0, z: 0 },
                    onGround: false,
                    // æ–°å¢ï¼šç›¸æ©Ÿä½ç½®å±¬æ€§
                    cameraX: null,
                    cameraY: null,
                    cameraZ: null
                };

                // å…¶ä»–ç©å®¶æ¸²æŸ“æ•¸æ“š
                this.otherPlayers = new Map();

                // ä¸–ç•Œè¨­å®š
                this.world = new Map();
                this.worldSize = 128;
                this.renderDistance = this.gameSettings.get('renderDistance');
                this.gravity = -0.08; // MinecraftçœŸå¯¦é‡åŠ›ï¼ˆæ¯tickï¼‰
                this.jumpPower = 0.42; // MinecraftçœŸå¯¦è·³èºé«˜åº¦

                // é‡å¯«çš„æ–¹å¡Šé¡å‹ç³»çµ±ï¼ˆåƒè€ƒMinecraftåŸç‰ˆé¡è‰²ï¼‰
                this.blockTypes = {
                    grass: {
                        colors: {
                            top: [0.486, 0.733, 0.216],
                            side: [0.545, 0.675, 0.322],
                            bottom: [0.545, 0.396, 0.216]
                        },
                        id: 1,
                        name: 'è‰åœ°',
                        icon: 'ğŸŸ©',
                        transparent: false,
                        alpha: 1.0
                    },
                    stone: {
                        colors: {
                            top: [0.502, 0.502, 0.502],
                            side: [0.502, 0.502, 0.502],
                            bottom: [0.502, 0.502, 0.502]
                        },
                        id: 2,
                        name: 'çŸ³é ­',
                        icon: 'â¬œ',
                        transparent: false,
                        alpha: 1.0
                    },
                    wood: {
                        colors: {
                            top: [0.647, 0.498, 0.286],
                            side: [0.647, 0.498, 0.286],
                            bottom: [0.647, 0.498, 0.286]
                        },
                        id: 3,
                        name: 'æœ¨é ­',
                        icon: 'ğŸŸ«',
                        transparent: false,
                        alpha: 1.0
                    },
                    water: {
                        colors: {
                            top: [0.247, 0.463, 0.894],
                            side: [0.247, 0.463, 0.894],
                            bottom: [0.196, 0.369, 0.714]
                        },
                        id: 4,
                        transparent: true,
                        alpha: 0.8,
                        name: 'æ°´',
                        icon: 'ğŸŸ¦',
                        renderType: 'transparent'
                    },
                    sand: {
                        colors: {
                            top: [0.918, 0.835, 0.647],
                            side: [0.918, 0.835, 0.647],
                            bottom: [0.918, 0.835, 0.647]
                        },
                        id: 5,
                        name: 'æ²™å­',
                        icon: 'ğŸŸ¨',
                        transparent: false,
                        alpha: 1.0
                    },
                    snow: {
                        colors: {
                            top: [0.980, 0.980, 0.980],
                            side: [0.980, 0.980, 0.980],
                            bottom: [0.980, 0.980, 0.980]
                        },
                        id: 6,
                        name: 'é›ª',
                        icon: 'â„ï¸',
                        transparent: false,
                        alpha: 1.0
                    },
                    leaves: {
                        colors: {
                            top: [0.486, 0.733, 0.216],
                            side: [0.486, 0.733, 0.216],
                            bottom: [0.486, 0.733, 0.216]
                        },
                        id: 7,
                        name: 'æ¨¹è‘‰',
                        icon: 'ğŸŸ¢',
                        transparent: false,
                        alpha: 1.0
                    },
                    cobblestone: {
                        colors: {
                            top: [0.502, 0.502, 0.502],
                            side: [0.502, 0.502, 0.502],
                            bottom: [0.502, 0.502, 0.502]
                        },
                        id: 8,
                        name: 'éµåµçŸ³',
                        icon: 'ğŸ”˜',
                        transparent: false,
                        alpha: 1.0
                    },
                    brick: {
                        colors: {
                            top: [0.588, 0.294, 0.196],
                            side: [0.588, 0.294, 0.196],
                            bottom: [0.588, 0.294, 0.196]
                        },
                        id: 9,
                        name: 'ç£šå¡Š',
                        icon: 'ğŸ§±',
                        transparent: false,
                        alpha: 1.0
                    },
                    glass: {
                        colors: {
                            top: [0.8, 0.9, 1.0],
                            side: [0.8, 0.9, 1.0],
                            bottom: [0.8, 0.9, 1.0]
                        },
                        id: 10,
                        transparent: true,
                        alpha: 0.3, // å¢åŠ ä¸€é»å¡«å……çš„ä¸é€æ˜åº¦ï¼Œå¾0.1èª¿æ•´åˆ°0.3
                        name: 'ç»ç’ƒ',
                        icon: 'ğŸ”·',
                        renderType: 'glass' // ä¿®æ”¹ç‚ºå°ˆç”¨æ¸²æŸ“é¡å‹
                    }
                };

                this.selectedBlock = 'grass';
                this.keys = {};
                this.mouse = { locked: false };

                // WebGLè³‡æº
                this.shaderProgram = null;
                this.wireframeShaderProgram = null;
                this.buffers = {};
                this.uniforms = {};
                this.wireframeUniforms = {};
                this.attributes = {};
                this.wireframeAttributes = {};

                // æ¸²æŸ“æ•¸æ“š
                this.vertices = [];
                this.indices = [];
                this.colors = [];
                this.normals = [];
                this.chunkMeshes = new Map();

                // çŸ©é™£
                this.projectionMatrix = this.createMat4();
                this.viewMatrix = this.createMat4();
                this.modelMatrix = this.createMat4();

                // è¨­å®šå¤šäººéŠæˆ²å›èª¿
                this.setupMultiplayerCallbacks();
                this.showMainMenu();
                this.initializeWebGL();

                // å°‡éŠæˆ²å¯¦ä¾‹è¨­ç‚ºå…¨åŸŸè®Šæ•¸
                window.game = this;
            }

            showMainMenu() {
                const mainMenu = document.getElementById('mainMenu');
                mainMenu.style.display = 'flex';
                mainMenu.style.opacity = '0';

                setTimeout(() => {
                    mainMenu.style.transition = 'opacity 0.5s ease';
                    mainMenu.style.opacity = '1';
                }, 50);

                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('loading').style.display = 'none';

                console.log('ä¸»é¸å–®å·²é¡¯ç¤º');
            }

            // è¨­å®šå¤šäººéŠæˆ²å›èª¿å‡½æ•¸
            setupMultiplayerCallbacks() {
                this.multiplayerManager.setCallback('onPlayerJoin', (player) => {
                    this.chatSystem.addMessage(`${player.name} åŠ å…¥äº†éŠæˆ²`, 'system');
                    this.otherPlayers.set(player.id, player);
                    this.updateConnectionUI();
                });

                this.multiplayerManager.setCallback('onPlayerLeave', (player) => {
                    this.chatSystem.addMessage(`${player.name} é›¢é–‹äº†éŠæˆ²`, 'system');
                    this.otherPlayers.delete(player.id);
                    this.updateConnectionUI();
                });

                this.multiplayerManager.setCallback('onPlayerMove', (data) => {
                    if (data.playerId !== this.multiplayerManager.playerId) {
                        this.otherPlayers.set(data.playerId, {
                            id: data.playerId,
                            name: data.playerName,
                            x: data.x,
                            y: data.y,
                            z: data.z,
                            angle: data.angle,
                            pitch: data.pitch
                        });
                    }
                });

                this.multiplayerManager.setCallback('onBlockUpdate', (data) => {
                    if (data.action === 'place') {
                        this.setBlock(data.x, data.y, data.z, data.blockType);
                        this.chatSystem.addMessage(`${data.playerName} æ”¾ç½®äº†${this.blockTypes[data.blockType]?.name || 'æ–¹å¡Š'}`, 'system');
                    } else if (data.action === 'break') {
                        this.removeBlock(data.x, data.y, data.z);
                        this.chatSystem.addMessage(`${data.playerName} ç ´å£äº†æ–¹å¡Š`, 'system');
                    }
                    this.regenerateNearbyChunks(data.x, data.y, data.z);
                });

                this.multiplayerManager.setCallback('onChatMessage', (data) => {
                    this.chatSystem.receiveMessage(data);
                });

                this.multiplayerManager.setCallback('onRoomUpdate', (data) => {
                    this.updateRoomInfo(data);
                });
            }

            // æ›´æ–°é€£ç·šUI
            updateConnectionUI() {
                const status = this.multiplayerManager.getConnectionStatus();

                if (this.isMultiplayer) {
                    document.getElementById('multiplayerInfo').style.display = 'flex';
                    document.getElementById('connectionInfo').style.display = 'flex';
                    document.getElementById('playerCount').textContent = status.playerCount;
                    document.getElementById('roomStatus').textContent =
                        status.isConnected ? status.roomId : 'é›¢ç·š';
                } else {
                    document.getElementById('multiplayerInfo').style.display = 'none';
                    document.getElementById('connectionInfo').style.display = 'none';
                }
            }

            // æ›´æ–°æˆ¿é–“è³‡è¨Š
            updateRoomInfo(data) {
                document.getElementById('currentRoomId').textContent = data.roomId;
                document.getElementById('roomPlayerCount').textContent = data.players.length;

                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';

                data.players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item';
                    playerDiv.textContent = `${player.name} ${player.isHost ? '(ä¸»æ©Ÿ)' : ''}`;
                    playerList.appendChild(playerDiv);
                });

                const startButton = document.getElementById('startGameButton');
                if (startButton) {
                    startButton.textContent = this.gameStarted ? 'ğŸ® è¿”å›éŠæˆ²' : 'ğŸ® é–‹å§‹éŠæˆ²';
                }
            }

            // æ›´æ–°æŠ•å½±çŸ©é™£ï¼ˆæ”¯æ´FOVè¨­å®šï¼‰
            // æ›´æ–°æŠ•å½±çŸ©é™£ï¼ˆæ”¯æ´FOVè¨­å®šå’Œè¿‘å¹³é¢èª¿æ•´ï¼‰
            updateProjectionMatrix() {
                const aspect = this.canvas.width / this.canvas.height;
                const fov = (this.gameSettings.get('fov') * Math.PI) / 180;

                // ä¿®å¾©ï¼šèª¿æ•´è¿‘å¹³é¢è·é›¢ï¼Œé˜²æ­¢è¿‘è·é›¢æ¸²æŸ“å•é¡Œ
                const nearPlane = 0.05; // æ›´å°çš„è¿‘å¹³é¢è·é›¢
                const farPlane = 1000.0;

                this.perspective(this.projectionMatrix, fov, aspect, nearPlane, farPlane);
            }

            // ç°¡åŒ–çš„4x4çŸ©é™£å‰µå»º
            createMat4() {
                return new Float32Array(16);
            }

            // é€è¦–æŠ•å½±çŸ©é™£
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
            }

            // è¦–åœ–çŸ©é™£
            lookAt(out, eye, center, up) {
                const eyex = eye[0], eyey = eye[1], eyez = eye[2];
                const centerx = center[0], centery = center[1], centerz = center[2];
                const upx = up[0], upy = up[1], upz = up[2];

                const z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                const nz0 = z0 * len, nz1 = z1 * len, nz2 = z2 * len;

                const x0 = upy * nz2 - upz * nz1;
                const x1 = upz * nz0 - upx * nz2;
                const x2 = upx * nz1 - upy * nz0;
                len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                const nx0 = x0 * len, nx1 = x1 * len, nx2 = x2 * len;

                const y0 = nz1 * nx2 - nz2 * nx1;
                const y1 = nz2 * nx0 - nz0 * nx2;
                const y2 = nz0 * nx1 - nz1 * nx0;

                out[0] = nx0; out[1] = y0; out[2] = nz0; out[3] = 0;
                out[4] = nx1; out[5] = y1; out[6] = nz1; out[7] = 0;
                out[8] = nx2; out[9] = y2; out[10] = nz2; out[11] = 0;
                out[12] = -(nx0 * eyex + nx1 * eyey + nx2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(nz0 * eyex + nz1 * eyey + nz2 * eyez);
                out[15] = 1;
            }

            // å–®ä½çŸ©é™£
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            }

            async initializeWebGL() {
                try {
                    this.showLoading();
                    await this.setupShaders();
                    this.setupBuffers();
                    this.setupMatrices();
                    this.setupEventListeners();
                    await this.generateWorld();
                    this.hideLoading();
                    this.gameLoop();
                } catch (error) {
                    this.showError('WebGLåˆå§‹åŒ–å¤±æ•—: ' + error.message);
                }
            }

            async setupShaders() {
                // å„ªåŒ–çš„ä¸»è¦è‘—è‰²å™¨ï¼ˆæ”¯æ´çœŸæ­£çš„é€æ˜åº¦ï¼‰
                const vertexShaderSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    attribute vec3 aNormal;
                    attribute float aAlpha;
                    
                    uniform mat4 uProjectionMatrix;
                    uniform mat4 uViewMatrix;
                    uniform mat4 uModelMatrix;
                    uniform vec3 uLightDirection;
                    uniform vec3 uAmbientLight;
                    uniform float uTime;
                    
                    varying vec3 vColor;
                    varying float vLighting;
                    varying float vAlpha;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
                        gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
                        
                        // æ”¹é€²çš„å…‰ç…§è¨ˆç®—
                        vec3 normal = normalize((uModelMatrix * vec4(aNormal, 0.0)).xyz);
                        float directional = max(dot(normal, normalize(uLightDirection)), 0.0);
                        
                        // æ·»åŠ ç’°å¢ƒå…‰é®è”½
                        float ao = 1.0;
                        if (normal.y < 0.0) ao = 0.8; // åº•é¢è¼ƒæš—
                        if (abs(normal.x) > 0.5 || abs(normal.z) > 0.5) ao = 0.9; // å´é¢ç¨æš—
                        
                        vLighting = (uAmbientLight.x + directional * 0.7) * ao;
                        
                        vColor = aColor;
                        vAlpha = aAlpha;
                        vNormal = normal;
                        vPosition = gl_Position.xyz;
                        vWorldPosition = worldPosition.xyz;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    
                    varying vec3 vColor;
                    varying float vLighting;
                    varying float vAlpha;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    
                    uniform vec3 uCameraPosition;
                    uniform float uTime;
                    
                    void main() {
                        // åŸºç¤å…‰ç…§è¨ˆç®—
                        vec3 ambient = vColor * 0.3;
                        vec3 diffuse = vColor * vLighting * 0.7;
                        vec3 finalColor = ambient + diffuse;
                        
                        // æ”¹é€²çš„è·é›¢éœ§æ•ˆæœ
                        float distance = length(vWorldPosition - uCameraPosition);
                        float fogStart = 25.0;
                        float fogEnd = 50.0;
                        float fogFactor = clamp((distance - fogStart) / (fogEnd - fogStart), 0.0, 0.8);
                        vec3 fogColor = vec3(0.7, 0.8, 0.9);
                        finalColor = mix(finalColor, fogColor, fogFactor);
                        
                        // é€æ˜åº¦è™•ç†
                        float alpha = vAlpha;
                        
                        // å°æ–¼é€æ˜ç‰©é«”ï¼Œæ·»åŠ è²æ¶…çˆ¾æ•ˆæœ
                        if (vAlpha < 1.0) {
                            vec3 viewDir = normalize(uCameraPosition - vWorldPosition);
                            float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 1.5);
                            alpha = mix(vAlpha, min(vAlpha * 2.0, 1.0), fresnel * 0.3);
                            
                            // æ°´çš„æ³¢å‹•æ•ˆæœ
                            if (vAlpha > 0.7 && vAlpha < 0.9) {
                                float wave = sin(vWorldPosition.x * 0.5 + uTime * 0.001) * 
                                           cos(vWorldPosition.z * 0.5 + uTime * 0.001) * 0.1;
                                finalColor += vec3(0.1, 0.1, 0.2) * wave;
                            }
                        }
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;

                // å„ªåŒ–çš„ç·šæ¡†è‘—è‰²å™¨ï¼ˆç”¨æ–¼ç»ç’ƒï¼‰
                const wireframeVertexSource = `
                    attribute vec3 aPosition;
                    
                    uniform mat4 uProjectionMatrix;
                    uniform mat4 uViewMatrix;
                    uniform mat4 uModelMatrix;
                    
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
                        gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
                        vWorldPosition = worldPosition.xyz;
                    }
                `;

                const wireframeFragmentSource = `
    precision mediump float;
    
    uniform vec3 uWireframeColor;
    uniform float uWireframeAlpha;
    uniform vec3 uCameraPosition;
    
    varying vec3 vWorldPosition;
    
    void main() {
        // è·é›¢è¡°æ¸› - æ›´å¹³æ»‘çš„éæ¸¡
        float distance = length(vWorldPosition - uCameraPosition);
        float alpha = uWireframeAlpha * (1.0 - clamp(distance / 40.0, 0.0, 0.7));
        
        // æ·»åŠ é‚Šç·£å¢å¼·æ•ˆæœ
        vec3 finalColor = uWireframeColor;
        
        // æ·»åŠ ç»ç’ƒçš„å¾®å…‰æ•ˆæœ
        finalColor += vec3(0.1, 0.1, 0.2) * (1.0 - distance / 20.0);
        
        gl_FragColor = vec4(finalColor, alpha);
    }
`;

                // ç·¨è­¯ä¸»è¦è‘—è‰²å™¨
                const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

                this.shaderProgram = this.gl.createProgram();
                this.gl.attachShader(this.shaderProgram, vertexShader);
                this.gl.attachShader(this.shaderProgram, fragmentShader);
                this.gl.linkProgram(this.shaderProgram);

                if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
                    throw new Error('ä¸»è‘—è‰²å™¨ç¨‹åºéˆæ¥å¤±æ•—: ' + this.gl.getProgramInfoLog(this.shaderProgram));
                }

                // ç·¨è­¯ç·šæ¡†è‘—è‰²å™¨
                const wireframeVertex = this.compileShader(wireframeVertexSource, this.gl.VERTEX_SHADER);
                const wireframeFragment = this.compileShader(wireframeFragmentSource, this.gl.FRAGMENT_SHADER);

                this.wireframeShaderProgram = this.gl.createProgram();
                this.gl.attachShader(this.wireframeShaderProgram, wireframeVertex);
                this.gl.attachShader(this.wireframeShaderProgram, wireframeFragment);
                this.gl.linkProgram(this.wireframeShaderProgram);

                if (!this.gl.getProgramParameter(this.wireframeShaderProgram, this.gl.LINK_STATUS)) {
                    throw new Error('ç·šæ¡†è‘—è‰²å™¨ç¨‹åºéˆæ¥å¤±æ•—: ' + this.gl.getProgramInfoLog(this.wireframeShaderProgram));
                }

                // ç²å–ä¸»è¦è‘—è‰²å™¨çš„å±¬æ€§å’Œçµ±ä¸€è®Šé‡
                this.gl.useProgram(this.shaderProgram);
                this.attributes = {
                    position: this.gl.getAttribLocation(this.shaderProgram, 'aPosition'),
                    color: this.gl.getAttribLocation(this.shaderProgram, 'aColor'),
                    normal: this.gl.getAttribLocation(this.shaderProgram, 'aNormal'),
                    alpha: this.gl.getAttribLocation(this.shaderProgram, 'aAlpha')
                };

                this.uniforms = {
                    projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                    viewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uViewMatrix'),
                    modelMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelMatrix'),
                    lightDirection: this.gl.getUniformLocation(this.shaderProgram, 'uLightDirection'),
                    ambientLight: this.gl.getUniformLocation(this.shaderProgram, 'uAmbientLight'),
                    cameraPosition: this.gl.getUniformLocation(this.shaderProgram, 'uCameraPosition'),
                    time: this.gl.getUniformLocation(this.shaderProgram, 'uTime')
                };

                // ç²å–ç·šæ¡†è‘—è‰²å™¨çš„å±¬æ€§å’Œçµ±ä¸€è®Šé‡
                this.gl.useProgram(this.wireframeShaderProgram);
                this.wireframeAttributes = {
                    position: this.gl.getAttribLocation(this.wireframeShaderProgram, 'aPosition')
                };

                this.wireframeUniforms = {
                    projectionMatrix: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uProjectionMatrix'),
                    viewMatrix: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uViewMatrix'),
                    modelMatrix: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uModelMatrix'),
                    wireframeColor: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uWireframeColor'),
                    wireframeAlpha: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uWireframeAlpha'),
                    cameraPosition: this.gl.getUniformLocation(this.wireframeShaderProgram, 'uCameraPosition')
                };
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    this.gl.deleteShader(shader);
                    throw new Error('è‘—è‰²å™¨ç·¨è­¯å¤±æ•—: ' + error);
                }

                return shader;
            }

            setupBuffers() {
                // ä¸»è¦ç·©è¡å€
                this.buffers.position = this.gl.createBuffer();
                this.buffers.color = this.gl.createBuffer();
                this.buffers.normal = this.gl.createBuffer();
                this.buffers.alpha = this.gl.createBuffer();
                this.buffers.index = this.gl.createBuffer();

                // ç·šæ¡†ç·©è¡å€
                this.buffers.wireframePosition = this.gl.createBuffer();
                this.buffers.wireframeIndex = this.gl.createBuffer();
            }

            setupMatrices() {
                // æŠ•å½±çŸ©é™£
                this.updateProjectionMatrix();

                // WebGLç‹€æ…‹è¨­ç½®
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.depthFunc(this.gl.LESS);
                this.gl.depthMask(true);

                // é¢å‰”é™¤
                this.gl.enable(this.gl.CULL_FACE);
                this.gl.cullFace(this.gl.BACK);
                this.gl.frontFace(this.gl.CCW);

                // æ··åˆè¨­ç½®
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                // æ¸…ç©ºè¨­ç½®
                this.gl.clearColor(0.5, 0.7, 1.0, 1.0);
                this.gl.clearDepth(1.0);

                // è¦–å£è¨­ç½®
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            showLoading() {
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
                    <h3>âŒ éŒ¯èª¤</h3>
                    <p>${message}</p>
                    <button onclick="location.reload()">é‡æ–°è¼‰å…¥</button>
                `;
                document.body.appendChild(errorDiv);
            }

            // ä¿®å¾©ï¼šæš«åœ/æ¢å¾©éŠæˆ²
            pauseGame() {
                this.isPaused = true;
                document.getElementById('pauseMenu').style.display = 'flex'; // ä¿®å¾©ï¼šç¢ºä¿é¡¯ç¤ºæš«åœé¸å–®
                if (this.mouse.locked) {
                    document.exitPointerLock();
                }
            }

            resumeGame() {
                this.isPaused = false;
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                if (this.gameStarted) {
                    this.canvas.requestPointerLock();
                }
            }

            // é¡¯ç¤ºè¨­å®šé¸å–®
            showSettingsMenu() {
                document.getElementById('settingsMenu').style.display = 'flex';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'none';
            }

            // é¡¯ç¤ºå¤šäººéŠæˆ²é¸å–®
            showMultiplayerMenu() {
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'flex';

                const playerNameInput = document.getElementById('playerName');
                if (!playerNameInput.value) {
                    playerNameInput.value = 'Player' + Math.floor(Math.random() * 1000);
                }
            }

            // è¿”å›ä¸»é¸å–®
            returnToMainMenu() {
                this.gameStarted = false;
                this.isPaused = false;
                this.isMultiplayer = false;

                if (this.multiplayerManager.isConnected) {
                    this.multiplayerManager.disconnect();
                }

                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                this.showMainMenu();

                if (this.mouse.locked) {
                    document.exitPointerLock();
                }

                this.player = {
                    x: 0, y: 10, z: 0,
                    angle: 0, pitch: 0,
                    velocity: { x: 0, y: 0, z: 0 },
                    onGround: false
                };

                this.otherPlayers.clear();
                this.updateConnectionUI();
                console.log('å·²è¿”å›ä¸»é¸å–®');
            }

            // åŠ å…¥æˆ¿é–“
            async joinRoom() {
                const playerName = document.getElementById('playerName').value.trim();
                const roomId = document.getElementById('roomId').value.trim();

                if (!playerName) {
                    this.showStatusMessage('è«‹è¼¸å…¥ç©å®¶åç¨±', true);
                    return;
                }

                if (!roomId) {
                    this.showStatusMessage('è«‹è¼¸å…¥æˆ¿é–“ID', true);
                    return;
                }

                try {
                    this.setButtonLoading('joinRoomButton', true, 'åŠ å…¥ä¸­...');

                    const connectionResult = await this.multiplayerManager.connectToRoom(roomId, playerName);
                    this.isMultiplayer = true;

                    document.getElementById('roomInfo').style.display = 'block';
                    this.updateConnectionUI();

                    this.chatSystem.addMessage(`å·²åŠ å…¥æˆ¿é–“ ${connectionResult.roomId}`, 'system');
                    this.chatSystem.addMessage(`é»æ“Š"é–‹å§‹éŠæˆ²"ä¾†é€²å…¥ä¸–ç•Œ`, 'system');

                    this.setButtonLoading('joinRoomButton', false);
                    this.showStatusMessage('æˆåŠŸåŠ å…¥æˆ¿é–“ï¼');

                } catch (error) {
                    console.error('åŠ å…¥æˆ¿é–“å¤±æ•—:', error);
                    this.showStatusMessage('åŠ å…¥æˆ¿é–“å¤±æ•—: ' + error.message, true);
                    this.setButtonLoading('joinRoomButton', false);
                }
            }

            // å‰µå»ºæˆ¿é–“
            async createRoom() {
                const playerName = document.getElementById('playerName').value.trim();

                if (!playerName) {
                    this.showStatusMessage('è«‹è¼¸å…¥ç©å®¶åç¨±', true);
                    return;
                }

                try {
                    this.setButtonLoading('createRoomButton', true, 'å‰µå»ºä¸­...');

                    const connectionResult = await this.multiplayerManager.connectToRoom(null, playerName);
                    this.isMultiplayer = true;

                    document.getElementById('roomId').value = connectionResult.roomId;
                    document.getElementById('roomInfo').style.display = 'block';
                    this.updateConnectionUI();

                    this.chatSystem.addMessage(`æˆ¿é–“å·²å‰µå»ºï¼æˆ¿é–“ID: ${connectionResult.roomId}`, 'system');
                    this.chatSystem.addMessage(`åˆ†äº«æ­¤IDçµ¦æœ‹å‹ä¾†åŠ å…¥éŠæˆ²ï¼`, 'system');

                    this.setButtonLoading('createRoomButton', false);
                    this.showStatusMessage('æˆ¿é–“å‰µå»ºæˆåŠŸï¼');

                } catch (error) {
                    console.error('å‰µå»ºæˆ¿é–“å¤±æ•—:', error);
                    this.showStatusMessage('å‰µå»ºæˆ¿é–“å¤±æ•—: ' + error.message, true);
                    this.setButtonLoading('createRoomButton', false);
                }
            }

            // é›¢é–‹æˆ¿é–“
            leaveRoom() {
                if (this.multiplayerManager.isConnected) {
                    this.multiplayerManager.disconnect();
                    this.chatSystem.addMessage('å·²é›¢é–‹æˆ¿é–“', 'system');
                }

                this.isMultiplayer = false;
                document.getElementById('roomInfo').style.display = 'none';
                document.getElementById('roomId').value = '';
                this.updateConnectionUI();
                this.otherPlayers.clear();

                // æ¸…é™¤ç©å®¶åç‰Œ
                document.getElementById('playerNameTags').innerHTML = '';
            }

            // è¨­ç½®æŒ‰éˆ•è¼‰å…¥ç‹€æ…‹
            setButtonLoading(buttonId, loading, loadingText = 'è™•ç†ä¸­...') {
                const button = document.getElementById(buttonId);
                if (!button) return;

                if (loading) {
                    button.dataset.originalText = button.textContent;
                    button.textContent = loadingText;
                    button.disabled = true;
                } else {
                    button.textContent = button.dataset.originalText || button.textContent;
                    button.disabled = false;
                }
            }

            // é¡¯ç¤ºç‹€æ…‹è¨Šæ¯
            showStatusMessage(message, isError = false) {
                this.chatSystem.addMessage(message, isError ? 'error' : 'info');
            }

            setupEventListeners() {
                // ä¸»é¸å–®æŒ‰éˆ•
                document.getElementById('singlePlayerButton').addEventListener('click', () => {
                    this.isMultiplayer = false;
                    this.startGame();
                });

                // ä¿®æ­£ï¼šå¤šäººéŠæˆ²æŒ‰éˆ•ç›´æ¥é€²å…¥å¤šäººé¸å–®
                document.getElementById('multiPlayerStartButton').addEventListener('click', () => {
                    document.getElementById('mainMenu').style.display = 'none';
                    this.showMultiplayerMenu();
                });

                // è¨­å®šæŒ‰éˆ•
                document.getElementById('settingsMenuButton').addEventListener('click', () => {
                    this.showSettingsMenu();
                });

                // è¨­å®šé¸å–®æŒ‰éˆ•
                document.getElementById('backToMainMenuButton').addEventListener('click', () => {
                    document.getElementById('settingsMenu').style.display = 'none';
                    this.showMainMenu();
                });

                // æš«åœé¸å–®æŒ‰éˆ•
                document.getElementById('resumeButton').addEventListener('click', () => {
                    this.resumeGame();
                });

                document.getElementById('multiplayerButton').addEventListener('click', () => {
                    this.showMultiplayerMenu();
                });

                document.getElementById('settingsButton').addEventListener('click', () => {
                    this.showSettingsMenu();
                });

                document.getElementById('mainMenuButton').addEventListener('click', () => {
                    this.returnToMainMenu();
                });

                // å¤šäººéŠæˆ²é¸å–®æŒ‰éˆ•
                document.getElementById('joinRoomButton').addEventListener('click', () => {
                    this.joinRoom();
                });

                document.getElementById('createRoomButton').addEventListener('click', () => {
                    this.createRoom();
                });

                document.getElementById('startGameButton').addEventListener('click', () => {
                    this.startMultiplayerGame();
                });

                document.getElementById('leaveRoomButton').addEventListener('click', () => {
                    this.leaveRoom();
                });

                document.getElementById('backToGameButton').addEventListener('click', () => {
                    if (this.multiplayerManager.isConnected) {
                        this.startMultiplayerGame();
                    } else {
                        document.getElementById('multiplayerMenu').style.display = 'none';
                        if (this.gameStarted) {
                            this.resumeGame();
                        } else {
                            this.showMainMenu();
                        }
                    }
                });

                // ä¿®å¾©ï¼šéµç›¤äº‹ä»¶ - ESCæš«åœåŠŸèƒ½
                // ä¿®å¾©ï¼šéµç›¤äº‹ä»¶è™•ç†
                document.addEventListener('keydown', (e) => {
                    // ä¿®å¾©ï¼šå¦‚æœèŠå¤©æ¿€æ´»ï¼Œåªè™•ç†ESCå’ŒEnterï¼Œå…¶ä»–æŒ‰éµè®“èŠå¤©æ¡†è™•ç†
                    if (this.chatSystem.isActive()) {
                        if (e.code === 'Escape') {
                            e.preventDefault();
                            this.chatSystem.deactivateInput();
                        }
                        // å…¶ä»–æŒ‰éµä¸æ””æˆªï¼Œè®“èŠå¤©è¼¸å…¥æ¡†æ­£å¸¸è™•ç†
                        return;
                    }

                    // ESCéµæš«åœ/æ¢å¾©
                    if (e.code === 'Escape') {
                        e.preventDefault();
                        if (this.gameStarted) {
                            if (this.isPaused) {
                                this.resumeGame();
                            } else {
                                this.pauseGame();
                            }
                        }
                        return;
                    }

                    // Téµé–‹å•ŸèŠå¤©
                    if (e.code === 'KeyT' && this.gameStarted && !this.isPaused) {
                        e.preventDefault();
                        this.chatSystem.activateInput();
                        return;
                    }

                    // éŠæˆ²æš«åœæ™‚ä¸è™•ç†ç§»å‹•æŒ‰éµ
                    if (this.isPaused) return;

                    this.keys[e.code] = true;

                    // å…¶ä»–éŠæˆ²æŒ‰éµè™•ç†...
                    // æ•¸å­—éµé¸æ“‡æ–¹å¡Š
                    if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                        const index = parseInt(e.code.slice(-1)) - 1;
                        const types = Object.keys(this.blockTypes);
                        if (types[index]) {
                            this.selectedBlock = types[index];
                            this.updateInventoryUI();
                            this.showBlockSwitchNotification();
                        }
                    }

                    // é£›è¡Œæ¨¡å¼åˆ‡æ›
                    if (e.code === 'KeyF') {
                        this.flying = !this.flying;
                        this.player.velocity.y = 0;
                        const status = this.flying ? 'é–‹å•Ÿ' : 'é—œé–‰';
                        this.chatSystem.addMessage(`é£›è¡Œæ¨¡å¼ï¼š${status}`, 'system');
                    }

                    // é˜²æ­¢ç©ºç™½éµæ»¾å‹•é é¢ï¼ˆåªåœ¨éŠæˆ²ä¸­ï¼‰
                    if (e.code === 'Space') {
                        e.preventDefault();
                    }

                    // F11å…¨è¢å¹•
                    if (e.code === 'F11') {
                        e.preventDefault();
                        this.toggleFullscreen();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    // ä¿®å¾©ï¼šèŠå¤©æ¿€æ´»æ™‚ä¸è™•ç†æŒ‰éµé‡‹æ”¾
                    if (this.isPaused || this.chatSystem.isActive()) return;
                    this.keys[e.code] = false;
                });

                // æ»‘é¼ äº‹ä»¶
                this.canvas.addEventListener('click', () => {
                    if (this.gameStarted && !this.isPaused && !this.chatSystem.isActive()) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked && !this.isPaused && !this.chatSystem.isActive()) {
                        // ä½¿ç”¨è¨­å®šä¸­çš„æ»‘é¼ éˆæ•åº¦
                        const sensitivity = this.gameSettings.get('mouseSensitivity') * 0.003;
                        this.player.angle += e.movementX * sensitivity;
                        this.player.pitch -= e.movementY * sensitivity;
                        this.player.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.player.pitch));
                    }
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.gameStarted || !this.worldGenerated || this.isPaused || this.chatSystem.isActive()) return;

                    const target = this.getTargetBlock();
                    if (target) {
                        if (e.button === 0) { // å·¦éµ - ç ´å£
                            this.removeBlock(target.x, target.y, target.z);

                            if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                                this.multiplayerManager.sendBlockUpdate(target.x, target.y, target.z, null, 'break');
                            }
                        } else if (e.button === 2) { // å³éµ - æ”¾ç½®
                            const place = this.getPlacePosition(target);
                            if (place && !this.isPlayerColliding(place.x, place.y, place.z)) {
                                this.setBlock(place.x, place.y, place.z, this.selectedBlock);
                                this.regenerateNearbyChunks(place.x, place.y, place.z);

                                if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                                    this.multiplayerManager.sendBlockUpdate(place.x, place.y, place.z, this.selectedBlock, 'place');
                                }
                            }
                        }
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // ç‰©å“æ¬„é»æ“Š
                document.querySelectorAll('.inventory-slot').forEach((slot) => {
                    slot.addEventListener('click', () => {
                        const blockType = slot.dataset.block;
                        this.selectedBlock = blockType;
                        this.updateInventoryUI();
                        this.showBlockSwitchNotification();
                    });
                });

                // è¦–çª—å¤§å°èª¿æ•´
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    this.updateProjectionMatrix();
                });

                // é˜²æ­¢é é¢æ»¾å‹•
                window.addEventListener('keydown', (e) => {
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        if (this.gameStarted && this.mouse.locked) {
                            e.preventDefault();
                        }
                    }
                });
            }

            // å•Ÿå‹•å¤šäººéŠæˆ²
            startMultiplayerGame() {
                if (!this.worldGenerated) {
                    this.showStatusMessage('ä¸–ç•Œé‚„åœ¨ç”Ÿæˆä¸­ï¼Œè«‹ç¨å€™...', true);
                    return;
                }

                if (!this.multiplayerManager.isConnected) {
                    this.showStatusMessage('å°šæœªé€£æ¥åˆ°æˆ¿é–“ï¼Œè«‹å…ˆå‰µå»ºæˆ–åŠ å…¥æˆ¿é–“', true);
                    return;
                }

                this.isMultiplayer = true;
                this.gameStarted = true;
                this.isPaused = false;

                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';

                // éš¨æ©Ÿæ”¾ç½®ç©å®¶ä½ç½®
                this.player.x = Math.random() * 10 - 5;
                this.player.z = Math.random() * 10 - 5;
                this.player.y = Math.max(5, this.getHighestBlock(this.player.x, this.player.z) + 3);

                this.chatSystem.addMessage('å¤šäººéŠæˆ²é–‹å§‹ï¼æŒ‰TéµèŠå¤©', 'system');
                this.chatSystem.addMessage(`ä½ çš„ä½ç½®: (${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)})`, 'system');

                console.log(`å¤šäººéŠæˆ²å·²å•Ÿå‹•ï¼æˆ¿é–“ID: ${this.multiplayerManager.roomId}`);
            }

            startGame() {
                if (!this.worldGenerated) {
                    this.showStatusMessage('ä¸–ç•Œé‚„åœ¨ç”Ÿæˆä¸­ï¼Œè«‹ç¨å€™...', true);
                    return;
                }

                this.gameStarted = true;
                this.isPaused = false;

                const mainMenu = document.getElementById('mainMenu');
                mainMenu.style.transition = 'opacity 0.5s ease';
                mainMenu.style.opacity = '0';

                setTimeout(() => {
                    mainMenu.style.display = 'none';
                }, 500);

                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';

                this.player.x = Math.random() * 10 - 5;
                this.player.z = Math.random() * 10 - 5;
                this.player.y = Math.max(5, this.getHighestBlock(this.player.x, this.player.z) + 3);

                console.log(`å–®äººéŠæˆ²å·²å•Ÿå‹•ï¼ç©å®¶ä½ç½®: (${this.player.x}, ${this.player.y}, ${this.player.z})`);
            }

            // é¡¯ç¤ºæ–¹å¡Šåˆ‡æ›é€šçŸ¥
            showBlockSwitchNotification() {
                const blockInfo = this.blockTypes[this.selectedBlock];
                if (!blockInfo) return;

                let notification = document.getElementById('blockSwitchNotification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'blockSwitchNotification';
                    document.body.appendChild(notification);
                }

                const transparentText = blockInfo.transparent ? ' (é€æ˜)' : '';
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">${blockInfo.icon}</span>
                        <span>${blockInfo.name}${transparentText}</span>
                    </div>
                `;

                notification.style.opacity = '1';

                if (this.notificationTimeout) {
                    clearTimeout(this.notificationTimeout);
                }

                this.notificationTimeout = setTimeout(() => {
                    notification.style.opacity = '0';
                }, 1500);
            }

            // é‡æ–°ç”Ÿæˆé™„è¿‘å€å¡Š
            regenerateNearbyChunks(x, y, z) {
                const chunkX = Math.floor((x + this.worldSize / 2) / 16);
                const chunkZ = Math.floor((z + this.worldSize / 2) / 16);

                this.generateChunkMesh(chunkX, chunkZ);

                const localX = (x + this.worldSize / 2) % 16;
                const localZ = (z + this.worldSize / 2) % 16;
                const maxChunkIndex = Math.ceil(this.worldSize / 16) - 1;

                if (localX === 0 && chunkX > 0) {
                    this.generateChunkMesh(chunkX - 1, chunkZ);
                }
                if (localX === 15 && chunkX < maxChunkIndex) {
                    this.generateChunkMesh(chunkX + 1, chunkZ);
                }
                if (localZ === 0 && chunkZ > 0) {
                    this.generateChunkMesh(chunkX, chunkZ - 1);
                }
                if (localZ === 15 && chunkZ < maxChunkIndex) {
                    this.generateChunkMesh(chunkX, chunkZ + 1);
                }
            }

            // å„ªåŒ–çš„ä¸–ç•Œç”Ÿæˆç³»çµ±
            async generateWorld() {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    let progress = 0;

                    console.log(`é–‹å§‹ç”Ÿæˆä¸–ç•Œï¼Œç¨®å­: ${this.worldSeed}`);

                    const heightMap = this.generateHeightMap();
                    const biomeMap = this.generateBiomeMap();

                    const generateChunk = (chunkX, chunkZ) => {
                        const chunkSize = 16;
                        const startX = chunkX * chunkSize - this.worldSize / 2;
                        const startZ = chunkZ * chunkSize - this.worldSize / 2;

                        for (let x = 0; x < chunkSize; x++) {
                            for (let z = 0; z < chunkSize; z++) {
                                const worldX = startX + x;
                                const worldZ = startZ + z;

                                if (Math.abs(worldX) >= this.worldSize / 2 || Math.abs(worldZ) >= this.worldSize / 2) continue;

                                const height = heightMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];
                                const biome = biomeMap[worldX + this.worldSize / 2][worldZ + this.worldSize / 2];

                                // åŸºå²©å±¤
                                for (let y = -5; y <= -3; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                }

                                // åœ°ä¸‹å±¤
                                for (let y = -2; y < height - 3; y++) {
                                    this.setBlock(worldX, y, worldZ, 'stone');
                                }

                                // æ¬¡è¡¨é¢å±¤
                                for (let y = Math.max(-2, height - 3); y < height; y++) {
                                    let subSurfaceBlock = 'stone';
                                    switch (biome) {
                                        case 'desert':
                                            subSurfaceBlock = 'sand';
                                            break;
                                        case 'snow':
                                            subSurfaceBlock = 'stone';
                                            break;
                                        default:
                                            subSurfaceBlock = 'stone';
                                    }
                                    this.setBlock(worldX, y, worldZ, subSurfaceBlock);
                                }

                                // è¡¨é¢æ–¹å¡Š
                                if (height >= -2) {
                                    let surfaceBlock = 'grass';
                                    switch (biome) {
                                        case 'desert':
                                            surfaceBlock = 'sand';
                                            break;
                                        case 'snow':
                                            surfaceBlock = 'snow';
                                            break;
                                        case 'forest':
                                            surfaceBlock = 'grass';
                                            break;
                                        case 'jungle':
                                            surfaceBlock = 'grass';
                                            break;
                                        default:
                                            surfaceBlock = 'grass';
                                    }
                                    this.setBlock(worldX, height, worldZ, surfaceBlock);
                                }

                                // ç”Ÿæˆæ¤è¢«
                                if (height > 0 && Math.random() < this.getVegetationChance(biome)) {
                                    this.generateVegetation(worldX, height + 1, worldZ, biome);
                                }

                                // æ°´é«”
                                if (height < 0) {
                                    for (let y = height + 1; y <= 0; y++) {
                                        this.setBlock(worldX, y, worldZ, 'water');
                                    }
                                }

                                // ç¤¦ç‰©ç”Ÿæˆ
                                this.generateOres(worldX, worldZ, height);
                            }
                        }

                        this.generateChunkMesh(chunkX, chunkZ);
                    };

                    const totalChunks = Math.pow(Math.ceil(this.worldSize / 16), 2);
                    let processedChunks = 0;

                    const processNextChunk = () => {
                        const chunksPerFrame = 3;
                        const chunksPerSide = Math.ceil(this.worldSize / 16);

                        for (let i = 0; i < chunksPerFrame && processedChunks < totalChunks; i++) {
                            const chunkX = Math.floor(processedChunks / chunksPerSide);
                            const chunkZ = processedChunks % chunksPerSide;

                            try {
                                generateChunk(chunkX, chunkZ);
                                processedChunks++;
                            } catch (error) {
                                console.error(`å€å¡Š (${chunkX}, ${chunkZ}) ç”Ÿæˆå¤±æ•—:`, error);
                                processedChunks++;
                            }
                        }

                        progress = (processedChunks / totalChunks) * 100;
                        const progressBar = document.getElementById('loadingProgress');
                        const loadingText = document.querySelector('#loading');

                        if (progressBar) {
                            progressBar.style.width = progress + '%';
                        }
                        if (loadingText) {
                            loadingText.textContent = `ç”Ÿæˆä¸–ç•Œ ${Math.floor(progress)}%`;
                        }

                        if (processedChunks >= totalChunks) {
                            this.worldGenerated = true;
                            console.log(`ä¸–ç•Œç”Ÿæˆå®Œæˆï¼Œè€—æ™‚: ${Date.now() - startTime}ms`);
                            console.log(`ç¸½å…±ç”Ÿæˆäº† ${this.world.size} å€‹æ–¹å¡Š`);
                            resolve();
                        } else {
                            requestAnimationFrame(processNextChunk);
                        }
                    };

                    processNextChunk();
                });
            }

            generateHeightMap() {
                const heightMap = [];
                for (let x = 0; x < this.worldSize; x++) {
                    heightMap[x] = [];
                    for (let z = 0; z < this.worldSize; z++) {
                        const nx = (x - this.worldSize / 2) / this.worldSize;
                        const nz = (z - this.worldSize / 2) / this.worldSize;

                        // å¤šå±¤å™ªè²ç”Ÿæˆæ›´çœŸå¯¦çš„åœ°å½¢
                        const continentalNoise = this.improvedNoise(nx * 0.3, nz * 0.3) * 20;
                        const mountainNoise = this.improvedNoise(nx * 1.5, nz * 1.5) * 12;
                        const hillNoise = this.improvedNoise(nx * 3, nz * 3) * 6;
                        const detailNoise = this.improvedNoise(nx * 6, nz * 6) * 3;
                        const fineNoise = this.improvedNoise(nx * 12, nz * 12) * 1;

                        const riverNoise = Math.abs(this.improvedNoise(nx * 2, nz * 1.2));
                        const isRiver = riverNoise < 0.08;

                        let height = 5 + continentalNoise + mountainNoise + hillNoise + detailNoise + fineNoise;

                        if (isRiver) {
                            height -= 8;
                        }

                        // é‚Šç•Œè¡°æ¸›
                        const distanceFromCenter = Math.sqrt(nx * nx + nz * nz);
                        if (distanceFromCenter > 0.8) {
                            height -= (distanceFromCenter - 0.8) * 30;
                        }

                        heightMap[x][z] = Math.floor(Math.max(-8, height));
                    }
                }
                return heightMap;
            }

            generateBiomeMap() {
                const biomeMap = [];
                for (let x = 0; x < this.worldSize; x++) {
                    biomeMap[x] = [];
                    for (let z = 0; z < this.worldSize; z++) {
                        const nx = (x - this.worldSize / 2) / this.worldSize;
                        const nz = (z - this.worldSize / 2) / this.worldSize;

                        const temperature = this.improvedNoise(nx * 2.2, nz * 2.2);
                        const humidity = this.improvedNoise(nx * 2.8 + 100, nz * 2.8 + 100);
                        const elevation = this.improvedNoise(nx * 1.5, nz * 1.5);

                        if (temperature > 0.4 && humidity < -0.3) {
                            biomeMap[x][z] = 'desert';
                        } else if (temperature < -0.4 || elevation > 0.6) {
                            biomeMap[x][z] = 'snow';
                        } else if (humidity > 0.5 && temperature > 0.1) {
                            biomeMap[x][z] = 'jungle';
                        } else if (humidity > 0.2 && temperature > -0.2) {
                            biomeMap[x][z] = 'forest';
                        } else {
                            biomeMap[x][z] = 'plains';
                        }
                    }
                }
                return biomeMap;
            }

            generateOres(x, z, surfaceHeight) {
                for (let y = -5; y < surfaceHeight - 5; y++) {
                    if (Math.random() < 0.02) {
                        if (y < -3 && Math.random() < 0.3) {
                            this.setBlock(x, y, z, 'cobblestone');
                        }
                    }
                }
            }

            improvedNoise(x, z) {
                const n1 = Math.sin(x * 2.1 + z * 1.7) * 0.5;
                const n2 = Math.sin(x * 1.3 - z * 2.3) * 0.3;
                const n3 = Math.sin(x * 3.7 + z * 0.9) * 0.2;
                const n4 = Math.sin(x * 5.1 + z * 4.7) * 0.1;
                const n5 = Math.sin(x * 8.3 + z * 7.1) * 0.05;
                return (n1 + n2 + n3 + n4 + n5);
            }

            getVegetationChance(biome) {
                switch (biome) {
                    case 'forest': return 0.12;
                    case 'jungle': return 0.18;
                    case 'plains': return 0.05;
                    case 'desert': return 0.008;
                    case 'snow': return 0.02;
                    default: return 0.03;
                }
            }

            generateVegetation(x, y, z, biome) {
                switch (biome) {
                    case 'forest':
                        if (Math.random() < 0.8) {
                            this.generateTree(x, y, z, 'wood', 'leaves');
                        }
                        break;
                    case 'jungle':
                        if (Math.random() < 0.9) {
                            this.generateTree(x, y, z, 'wood', 'leaves', true);
                        }
                        break;
                    case 'desert':
                        if (Math.random() < 0.4) {
                            this.generateCactus(x, y, z);
                        }
                        break;
                    case 'snow':
                        if (Math.random() < 0.6) {
                            this.generateTree(x, y, z, 'wood', 'leaves');
                        }
                        break;
                    default:
                        if (Math.random() < 0.7) {
                            this.generateTree(x, y, z, 'wood', 'leaves');
                        }
                }
            }

            generateTree(x, y, z, trunkType = 'wood', leafType = 'leaves', tall = false) {
                const height = tall ? 6 + Math.floor(Math.random() * 4) : 4 + Math.floor(Math.random() * 3);

                // æ¨¹å¹¹
                for (let i = 0; i < height; i++) {
                    this.setBlock(x, y + i, z, trunkType);
                }

                // æ¨¹è‘‰
                const leafY = y + height;
                const leafRadius = tall ? 3 : 2;

                for (let dx = -leafRadius; dx <= leafRadius; dx++) {
                    for (let dz = -leafRadius; dz <= leafRadius; dz++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const distance = Math.sqrt(dx * dx + dz * dz + dy * dy * 0.5);
                            if (distance <= leafRadius && Math.random() < 0.85) {
                                this.setBlock(x + dx, leafY + dy, z + dz, leafType);
                            }
                        }
                    }
                }

                // æ¨¹é ‚
                this.setBlock(x, leafY + 2, z, leafType);
            }

            generateCactus(x, y, z) {
                const height = 2 + Math.floor(Math.random() * 4);
                for (let i = 0; i < height; i++) {
                    this.setBlock(x, y + i, z, 'leaves');
                }
            }

            setBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                this.world.set(key, type);
            }

            getBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                return this.world.get(key);
            }

            removeBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                this.world.delete(key);
                this.regenerateNearbyChunks(x, y, z);
            }

            getHighestBlock(x, z) {
                for (let y = 30; y >= -10; y--) {
                    if (this.getBlock(Math.floor(x), y, Math.floor(z))) {
                        return y;
                    }
                }
                return 0;
            }

            updateInventoryUI() {
                document.querySelectorAll('.inventory-slot').forEach(slot => {
                    slot.classList.remove('active');
                    if (slot.dataset.block === this.selectedBlock) {
                        slot.classList.add('active');
                    }
                });
            }

            getTargetBlock() {
                const range = 8;
                const step = 0.05;

                const startX = this.player.x;
                const startY = this.player.y + 1.6;
                const startZ = this.player.z;

                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                for (let d = 0; d < range; d += step) {
                    const x = Math.floor(startX + dirX * d);
                    const y = Math.floor(startY + dirY * d);
                    const z = Math.floor(startZ + dirZ * d);

                    if (this.getBlock(x, y, z)) {
                        return {
                            x, y, z,
                            hitX: startX + dirX * d,
                            hitY: startY + dirY * d,
                            hitZ: startZ + dirZ * d
                        };
                    }
                }
                return null;
            }

            getPlacePosition(target) {
                if (!target) return null;

                const hitX = target.hitX - target.x;
                const hitY = target.hitY - target.y;
                const hitZ = target.hitZ - target.z;

                let placeX = target.x;
                let placeY = target.y;
                let placeZ = target.z;

                const absX = Math.abs(hitX - 0.5);
                const absY = Math.abs(hitY - 0.5);
                const absZ = Math.abs(hitZ - 0.5);

                if (absX > absY && absX > absZ) {
                    placeX += hitX > 0.5 ? 1 : -1;
                } else if (absY > absZ) {
                    placeY += hitY > 0.5 ? 1 : -1;
                } else {
                    placeZ += hitZ > 0.5 ? 1 : -1;
                }

                if (!this.getBlock(placeX, placeY, placeZ)) {
                    return { x: placeX, y: placeY, z: placeZ };
                }

                return null;
            }

            isPlayerColliding(x, y, z) {
                const px = Math.floor(this.player.x);
                const py = Math.floor(this.player.y);
                const pz = Math.floor(this.player.z);

                return (Math.abs(x - px) <= 1 && Math.abs(y - py) <= 2 && Math.abs(z - pz) <= 1);
            }

            checkCollision(x, y, z) {
                const blockX = Math.floor(x);
                const blockY = Math.floor(y);
                const blockZ = Math.floor(z);

                for (let dy = 0; dy < 2; dy++) {
                    if (this.getBlock(blockX, blockY + dy, blockZ)) {
                        return true;
                    }
                }
                return false;
            }

            // å„ªåŒ–çš„å€å¡Šç¶²æ ¼ç”Ÿæˆï¼ˆçœŸæ­£çš„é€æ˜åº¦æ”¯æ´ï¼‰
            generateChunkMesh(chunkX, chunkZ) {
                if (chunkX < 0 || chunkZ < 0 ||
                    chunkX >= Math.ceil(this.worldSize / 16) ||
                    chunkZ >= Math.ceil(this.worldSize / 16)) {
                    return;
                }

                const chunkSize = 16;
                const opaqueVertices = [];
                const opaqueColors = [];
                const opaqueNormals = [];
                const opaqueAlphas = [];
                const opaqueIndices = [];

                const transparentVertices = [];
                const transparentColors = [];
                const transparentNormals = [];
                const transparentAlphas = [];
                const transparentIndices = [];

                const wireframeVertices = [];
                const wireframeIndices = [];

                let opaqueIndexOffset = 0;
                let transparentIndexOffset = 0;
                let wireframeIndexOffset = 0;

                const startX = chunkX * chunkSize - this.worldSize / 2;
                const startZ = chunkZ * chunkSize - this.worldSize / 2;

                for (let x = 0; x < chunkSize; x++) {
                    for (let z = 0; z < chunkSize; z++) {
                        for (let y = -10; y < 60; y++) {
                            const worldX = startX + x;
                            const worldZ = startZ + z;
                            const blockType = this.getBlock(worldX, y, worldZ);

                            if (!blockType) continue;

                            const blockInfo = this.blockTypes[blockType];
                            if (!blockInfo) continue;

                            const faces = [
                                { dir: [0, 1, 0], visible: this.shouldRenderFace(worldX, y + 1, worldZ, blockType) },
                                { dir: [0, -1, 0], visible: this.shouldRenderFace(worldX, y - 1, worldZ, blockType) },
                                { dir: [1, 0, 0], visible: this.shouldRenderFace(worldX + 1, y, worldZ, blockType) },
                                { dir: [-1, 0, 0], visible: this.shouldRenderFace(worldX - 1, y, worldZ, blockType) },
                                { dir: [0, 0, 1], visible: this.shouldRenderFace(worldX, y, worldZ + 1, blockType) },
                                { dir: [0, 0, -1], visible: this.shouldRenderFace(worldX, y, worldZ - 1, blockType) }
                            ];

                            faces.forEach((face, faceIndex) => {
                                if (!face.visible) return;

                                const faceVertices = this.getFaceVertices(worldX, y, worldZ, faceIndex);
                                const blockAlpha = blockInfo.alpha || 1.0;

                                // æ ¹æ“šé¢çš„æ–¹å‘é¸æ“‡é¡è‰²
                                let blockColor;
                                if (blockInfo.colors) {
                                    switch (faceIndex) {
                                        case 0: blockColor = blockInfo.colors.top; break;
                                        case 1: blockColor = blockInfo.colors.bottom; break;
                                        default: blockColor = blockInfo.colors.side; break;
                                    }
                                } else {
                                    blockColor = [0.5, 0.5, 0.5];
                                }

                                const shadeFactor = this.calculateFaceShading(faceIndex, face.dir);
                                let shadedColor = [
                                    Math.max(0, Math.min(1, blockColor[0] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[1] * shadeFactor)),
                                    Math.max(0, Math.min(1, blockColor[2] * shadeFactor))
                                ];

                                // è™•ç†ä¸åŒçš„æ¸²æŸ“é¡å‹
                                if (blockInfo.renderType === 'wireframe') {
                                    // ç·šæ¡†æ¸²æŸ“ï¼ˆç»ç’ƒï¼‰- åŠ ç²—ç·šæ¢
                                    this.addWireframeData(faceVertices, wireframeVertices, wireframeIndices, wireframeIndexOffset);
                                    wireframeIndexOffset += 4;
                                } else if (blockInfo.transparent) {
                                    // é€æ˜æ¸²æŸ“ï¼ˆæ°´ï¼‰- çœŸæ­£çš„é€æ˜åº¦
                                    this.addFaceData(faceVertices, shadedColor, face.dir, blockAlpha,
                                        transparentVertices, transparentColors, transparentNormals,
                                        transparentAlphas, transparentIndices, transparentIndexOffset);
                                    transparentIndexOffset += 4;
                                } else {
                                    // ä¸é€æ˜æ¸²æŸ“
                                    this.addFaceData(faceVertices, shadedColor, face.dir, blockAlpha,
                                        opaqueVertices, opaqueColors, opaqueNormals,
                                        opaqueAlphas, opaqueIndices, opaqueIndexOffset);
                                    opaqueIndexOffset += 4;
                                }
                            });
                        }
                    }
                }

                // å­˜å„²å€å¡Šç¶²æ ¼æ•¸æ“š
                this.chunkMeshes.set(`${chunkX},${chunkZ}`, {
                    opaque: {
                        vertices: new Float32Array(opaqueVertices),
                        colors: new Float32Array(opaqueColors),
                        normals: new Float32Array(opaqueNormals),
                        alphas: new Float32Array(opaqueAlphas),
                        indices: new Uint16Array(opaqueIndices),
                        vertexCount: opaqueVertices.length / 3,
                        indexCount: opaqueIndices.length
                    },
                    transparent: {
                        vertices: new Float32Array(transparentVertices),
                        colors: new Float32Array(transparentColors),
                        normals: new Float32Array(transparentNormals),
                        alphas: new Float32Array(transparentAlphas),
                        indices: new Uint16Array(transparentIndices),
                        vertexCount: transparentVertices.length / 3,
                        indexCount: transparentIndices.length
                    },
                    wireframe: {
                        vertices: new Float32Array(wireframeVertices),
                        indices: new Uint16Array(wireframeIndices),
                        vertexCount: wireframeVertices.length / 3,
                        indexCount: wireframeIndices.length
                    }
                });
            }

            // æ·»åŠ é¢æ•¸æ“šçš„è¼”åŠ©æ–¹æ³•
            addFaceData(faceVertices, color, normal, alpha, vertices, colors, normals, alphas, indices, indexOffset) {
                for (let i = 0; i < 4; i++) {
                    vertices.push(...faceVertices[i]);
                    colors.push(...color);
                    normals.push(...normal);
                    alphas.push(alpha);
                }

                indices.push(
                    indexOffset, indexOffset + 1, indexOffset + 2,
                    indexOffset, indexOffset + 2, indexOffset + 3
                );
            }

            // æ·»åŠ ç·šæ¡†æ•¸æ“šçš„è¼”åŠ©æ–¹æ³•ï¼ˆåƒè€ƒMinecrafté¢¨æ ¼ï¼‰
            addWireframeData(faceVertices, vertices, indices, indexOffset) {
                for (let i = 0; i < 4; i++) {
                    vertices.push(...faceVertices[i]);
                }

                // å¤–é‚Šæ¡†ç·šæ¢ - åŸºæœ¬æ–¹å¡Šé‚Šç·£
                indices.push(
                    indexOffset, indexOffset + 1,
                    indexOffset + 1, indexOffset + 2,
                    indexOffset + 2, indexOffset + 3,
                    indexOffset + 3, indexOffset
                );

                // Minecrafté¢¨æ ¼ - æ·»åŠ å…§éƒ¨åå­—ç·šæ¢å¢å¼·è­˜åˆ¥åº¦
                if (Math.random() > 0.5) { // éš¨æ©Ÿæ·»åŠ ï¼Œæ¨¡æ“¬Minecraftä¸­çš„è®ŠåŒ–
                    // å°è§’ç·š
                    indices.push(
                        indexOffset, indexOffset + 2,
                        indexOffset + 1, indexOffset + 3
                    );
                }
            }

            renderGlassBlocks() {
                // é¦–å…ˆæ¸²æŸ“åŠé€æ˜å¡«å……
                this.gl.useProgram(this.shaderProgram);
                this.renderTransparentChunks();

                // ç„¶å¾Œæ¸²æŸ“ç·šæ¡†é‚Šç·£
                this.gl.useProgram(this.wireframeShaderProgram);
                this.renderWireframeChunks();

                // æ¢å¾©é»˜èªè¨­ç½®
                this.gl.lineWidth(1);
            }

            calculateFaceShading(faceIndex, normal) {
                const lightDirection = [0.4, 0.8, 0.6];
                const dotProduct = normal[0] * lightDirection[0] +
                    normal[1] * lightDirection[1] +
                    normal[2] * lightDirection[2];

                const baseBrightness = 0.7;
                const directionalLight = Math.max(0, dotProduct) * 0.3;

                // é¢å‘å…‰ç…§çš„èª¿æ•´
                let faceBrightness = 1.0;
                switch (faceIndex) {
                    case 0: faceBrightness = 1.0; break; // é ‚é¢æœ€äº®
                    case 1: faceBrightness = 0.5; break; // åº•é¢æœ€æš—
                    case 2:
                    case 3: faceBrightness = 0.8; break; // æ±è¥¿é¢
                    case 4:
                    case 5: faceBrightness = 0.6; break; // å—åŒ—é¢
                }

                return Math.max(0.3, Math.min(1.0, (baseBrightness + directionalLight) * faceBrightness));
            }

            shouldRenderFace(x, y, z, currentBlockType) {
                if (Math.abs(x) > this.worldSize || Math.abs(z) > this.worldSize || y < -10 || y > 60) {
                    return true;
                }

                const neighborBlock = this.getBlock(x, y, z);

                if (!neighborBlock) {
                    return true;
                }

                const neighborInfo = this.blockTypes[neighborBlock];
                const currentInfo = this.blockTypes[currentBlockType];

                // é€æ˜æ–¹å¡Šä¹‹é–“çš„æ¸²æŸ“é‚è¼¯
                if (currentInfo && currentInfo.transparent) {
                    if (neighborInfo && neighborInfo.transparent) {
                        return neighborBlock !== currentBlockType;
                    }
                    return false;
                }

                // ä¸é€æ˜æ–¹å¡Šä¸æ¸²æŸ“è¢«å…¶ä»–ä¸é€æ˜æ–¹å¡Šé®æ“‹çš„é¢
                if (neighborInfo && !neighborInfo.transparent) {
                    return false;
                }

                return true;
            }

            getFaceVertices(x, y, z, faceIndex) {
                const vertices = [
                    [[x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x + 1, y + 1, z]],
                    [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]],
                    [[x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1], [x + 1, y, z + 1]],
                    [[x, y, z + 1], [x, y + 1, z + 1], [x, y + 1, z], [x, y, z]],
                    [[x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1]],
                    [[x + 1, y, z], [x, y, z], [x, y + 1, z], [x + 1, y + 1, z]]
                ];

                return vertices[faceIndex];
            }

            // åˆ‡æ›å…¨è¢å¹•æ¨¡å¼
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().then(() => {
                        this.chatSystem.addMessage('å·²é€²å…¥å…¨è¢å¹•æ¨¡å¼', 'system');
                    }).catch(err => {
                        console.error('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼:', err);
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        this.chatSystem.addMessage('å·²é€€å‡ºå…¨è¢å¹•æ¨¡å¼', 'system');
                    }).catch(err => {
                        console.error('ç„¡æ³•é€€å‡ºå…¨è¢å¹•æ¨¡å¼:', err);
                    });
                }
            }

            updateViewMatrix() {
                // ç©å®¶çœ¼ç›ä½ç½®ï¼ˆç›¸æ©Ÿä½ç½®ï¼‰
                const eyeHeight = 1.6; // Minecraftä¸­ç©å®¶çœ¼ç›é«˜åº¦
                let eyeX = this.player.x;
                let eyeY = this.player.y + eyeHeight;
                let eyeZ = this.player.z;

                // è¦–ç·šæ–¹å‘
                const dirX = Math.cos(this.player.angle) * Math.cos(this.player.pitch);
                const dirY = Math.sin(this.player.pitch);
                const dirZ = Math.sin(this.player.angle) * Math.cos(this.player.pitch);

                // ä¿®å¾©ï¼šç›¸æ©Ÿç¢°æ’æª¢æ¸¬
                this.adjustCameraForCollision(eyeX, eyeY, eyeZ, dirX, dirY, dirZ);

                // æ›´æ–°å¾Œçš„çœ¼ç›ä½ç½®
                const eye = [this.player.cameraX || eyeX, this.player.cameraY || eyeY, this.player.cameraZ || eyeZ];

                // è¦–ç·šç›®æ¨™é»
                const target = [
                    eye[0] + dirX,
                    eye[1] + dirY,
                    eye[2] + dirZ
                ];

                const up = [0, 1, 0];
                this.lookAt(this.viewMatrix, eye, target, up);
            }

            // æ–°å¢ï¼šç›¸æ©Ÿç¢°æ’æª¢æ¸¬å’Œèª¿æ•´
            adjustCameraForCollision(eyeX, eyeY, eyeZ, dirX, dirY, dirZ) {
                // æœ€å°ç›¸æ©Ÿè·é›¢ï¼ˆå¾ç©å®¶ä¸­å¿ƒåˆ°æ–¹å¡Šè¡¨é¢çš„æœ€å°è·é›¢ï¼‰
                const minDistance = 0.15;

                // æª¢æŸ¥ç›¸æ©Ÿå‘¨åœçš„æ–¹å¡Š
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const blockX = Math.floor(eyeX + dx);
                            const blockY = Math.floor(eyeY + dy);
                            const blockZ = Math.floor(eyeZ + dz);

                            // å¦‚æœæ–¹å¡Šå­˜åœ¨ä¸”ä¸é€æ˜
                            const blockType = this.getBlock(blockX, blockY, blockZ);
                            if (blockType) {
                                const blockInfo = this.blockTypes[blockType];
                                if (blockInfo && !blockInfo.transparent) {
                                    // è¨ˆç®—ç›¸æ©Ÿåˆ°æ–¹å¡Šè¡¨é¢çš„è·é›¢
                                    const distances = this.distanceToBlockSurfaces(eyeX, eyeY, eyeZ, blockX, blockY, blockZ);

                                    // å¦‚æœè·é›¢å°æ–¼æœ€å°è·é›¢ï¼Œèª¿æ•´ç›¸æ©Ÿä½ç½®
                                    for (const face in distances) {
                                        if (distances[face] < minDistance) {
                                            // æ ¹æ“šé¢çš„æ–¹å‘èª¿æ•´ç›¸æ©Ÿä½ç½®
                                            switch (face) {
                                                case 'px': // +Xé¢
                                                    this.player.cameraX = blockX + 1 + minDistance;
                                                    break;
                                                case 'nx': // -Xé¢
                                                    this.player.cameraX = blockX - minDistance;
                                                    break;
                                                case 'py': // +Yé¢
                                                    this.player.cameraY = blockY + 1 + minDistance;
                                                    break;
                                                case 'ny': // -Yé¢
                                                    this.player.cameraY = blockY - minDistance;
                                                    break;
                                                case 'pz': // +Zé¢
                                                    this.player.cameraZ = blockZ + 1 + minDistance;
                                                    break;
                                                case 'nz': // -Zé¢
                                                    this.player.cameraZ = blockZ - minDistance;
                                                    break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // è¨ˆç®—ç›¸æ©Ÿåˆ°æ–¹å¡Šå„è¡¨é¢çš„è·é›¢
            distanceToBlockSurfaces(eyeX, eyeY, eyeZ, blockX, blockY, blockZ) {
                // è¨ˆç®—ç›¸æ©Ÿåˆ°æ–¹å¡Šå…­å€‹é¢çš„è·é›¢
                return {
                    'px': Math.abs(eyeX - (blockX + 1)), // +Xé¢
                    'nx': Math.abs(eyeX - blockX),       // -Xé¢
                    'py': Math.abs(eyeY - (blockY + 1)), // +Yé¢
                    'ny': Math.abs(eyeY - blockY),       // -Yé¢
                    'pz': Math.abs(eyeZ - (blockZ + 1)), // +Zé¢
                    'nz': Math.abs(eyeZ - blockZ)        // -Zé¢
                };
            }

            // å„ªåŒ–çš„æ¸²æŸ“ç³»çµ±ï¼ˆçœŸæ­£çš„é€æ˜åº¦å’ŒåŠ ç²—ç·šæ¡†ï¼‰
            render() {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                if (!this.gameStarted || !this.worldGenerated) return;

                this.triangleCount = 0;
                this.vertexCount = 0;
                this.drawCalls = 0;

                this.updateViewMatrix();
                this.identity(this.modelMatrix);

                const cameraPos = [this.player.x, this.player.y + 1.6, this.player.z];
                const currentTime = performance.now();

                try {
                    // ç¬¬ä¸€éšæ®µï¼šæ¸²æŸ“ä¸é€æ˜ç‰©é«”
                    this.gl.useProgram(this.shaderProgram);
                    this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, this.projectionMatrix);
                    this.gl.uniformMatrix4fv(this.uniforms.viewMatrix, false, this.viewMatrix);
                    this.gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix);
                    this.gl.uniform3f(this.uniforms.lightDirection, 0.4, 0.8, 0.6);
                    this.gl.uniform3f(this.uniforms.ambientLight, 0.7, 0.7, 0.7);
                    this.gl.uniform3fv(this.uniforms.cameraPosition, cameraPos);
                    this.gl.uniform1f(this.uniforms.time, currentTime);

                    this.gl.enable(this.gl.DEPTH_TEST);
                    this.gl.depthMask(true);
                    this.gl.disable(this.gl.BLEND);

                    this.renderOpaqueChunks();

                    // ç¬¬äºŒéšæ®µï¼šæ¸²æŸ“åŠé€æ˜ç‰©é«”ï¼ˆå¦‚æ°´ï¼‰
                    this.gl.enable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                    this.gl.depthMask(false);

                    this.renderTransparentChunks(cameraPos);

                    // ç¬¬ä¸‰éšæ®µï¼šæ¸²æŸ“ç»ç’ƒæ–¹å¡Šï¼ˆä½¿ç”¨Minecrafté¢¨æ ¼é‚Šæ¡†ï¼‰
                    this.gl.enable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                    this.gl.depthMask(false);
                    this.gl.lineWidth(3); // é»˜èªç²—ç·šæ¢

                    this.renderWireframeChunks();

                    // æ¢å¾©é»˜èªè¨­ç½®
                    this.gl.depthMask(true);
                    this.gl.disable(this.gl.BLEND);
                    this.gl.lineWidth(1);

                    // æ¸²æŸ“å…¶ä»–ç©å®¶
                    this.renderOtherPlayers();

                } catch (error) {
                    console.error('æ¸²æŸ“éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }

            renderOpaqueChunks() {
                const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                // å„ªåŒ–ï¼šæŒ‰è·é›¢æ’åºæ¸²æŸ“
                const chunksToRender = [];
                for (let dx = -renderChunkDistance; dx <= renderChunkDistance; dx++) {
                    for (let dz = -renderChunkDistance; dz <= renderChunkDistance; dz++) {
                        const chunkX = playerChunkX + dx;
                        const chunkZ = playerChunkZ + dz;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        if (distance <= renderChunkDistance &&
                            chunkX >= 0 && chunkZ >= 0 &&
                            chunkX < Math.ceil(this.worldSize / 16) &&
                            chunkZ < Math.ceil(this.worldSize / 16)) {
                            chunksToRender.push({ chunkX, chunkZ, distance });
                        }
                    }
                }

                chunksToRender.sort((a, b) => a.distance - b.distance);

                chunksToRender.forEach(({ chunkX, chunkZ }) => {
                    const chunkKey = `${chunkX},${chunkZ}`;
                    const meshData = this.chunkMeshes.get(chunkKey);

                    if (meshData && meshData.opaque && meshData.opaque.indexCount > 0) {
                        this.renderMesh(meshData.opaque, false);
                    }
                });
            }

            renderTransparentChunks(cameraPos) {
                const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                const transparentChunks = [];

                for (let dx = -renderChunkDistance; dx <= renderChunkDistance; dx++) {
                    for (let dz = -renderChunkDistance; dz <= renderChunkDistance; dz++) {
                        const chunkX = playerChunkX + dx;
                        const chunkZ = playerChunkZ + dz;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        if (distance <= renderChunkDistance &&
                            chunkX >= 0 && chunkZ >= 0 &&
                            chunkX < Math.ceil(this.worldSize / 16) &&
                            chunkZ < Math.ceil(this.worldSize / 16)) {

                            const chunkKey = `${chunkX},${chunkZ}`;
                            const meshData = this.chunkMeshes.get(chunkKey);

                            if (meshData && meshData.transparent && meshData.transparent.indexCount > 0) {
                                const chunkCenterX = (chunkX * 16) - this.worldSize / 2 + 8;
                                const chunkCenterZ = (chunkZ * 16) - this.worldSize / 2 + 8;
                                const chunkDistance = Math.sqrt(
                                    Math.pow(chunkCenterX - cameraPos[0], 2) +
                                    Math.pow(chunkCenterZ - cameraPos[2], 2)
                                );

                                transparentChunks.push({
                                    mesh: meshData.transparent,
                                    distance: chunkDistance
                                });
                            }
                        }
                    }
                }

                // å¾é åˆ°è¿‘æ’åº
                transparentChunks.sort((a, b) => b.distance - a.distance);

                // æ¸²æŸ“é€æ˜å€å¡Š
                transparentChunks.forEach(chunk => {
                    this.renderMesh(chunk.mesh, true);
                });
            }

            renderWireframeChunks() {
                const playerChunkX = Math.floor((this.player.x + this.worldSize / 2) / 16);
                const playerChunkZ = Math.floor((this.player.z + this.worldSize / 2) / 16);
                const renderChunkDistance = Math.ceil(this.renderDistance / 16);

                this.gl.useProgram(this.wireframeShaderProgram);
                this.gl.uniformMatrix4fv(this.wireframeUniforms.projectionMatrix, false, this.projectionMatrix);
                this.gl.uniformMatrix4fv(this.wireframeUniforms.viewMatrix, false, this.viewMatrix);
                this.gl.uniformMatrix4fv(this.wireframeUniforms.modelMatrix, false, this.modelMatrix);

                // ä¿®æ”¹ï¼šæ›´æ˜é¡¯çš„ç»ç’ƒé‚Šæ¡†é¡è‰²å’Œä¸é€æ˜åº¦
                this.gl.uniform3f(this.wireframeUniforms.wireframeColor, 0.9, 0.95, 1.0); // æ›´äº®çš„è—ç™½è‰²
                this.gl.uniform1f(this.wireframeUniforms.wireframeAlpha, 0.95); // æ›´é«˜çš„ä¸é€æ˜åº¦
                this.gl.uniform3fv(this.wireframeUniforms.cameraPosition, [this.player.x, this.player.y + 1.6, this.player.z]);

                // ä¿®æ”¹ï¼šå¢åŠ ç·šå¯¬ï¼Œæ¨¡ä»¿Minecraft Javaç‰ˆçš„ç²—é‚Šæ¡†
                const lineWidth = Math.max(3, Math.min(10, this.canvas.width / 200)); // æ›´ç²—çš„ç·šæ¢
                this.gl.lineWidth(lineWidth);

                for (let dx = -renderChunkDistance; dx <= renderChunkDistance; dx++) {
                    for (let dz = -renderChunkDistance; dz <= renderChunkDistance; dz++) {
                        const chunkX = playerChunkX + dx;
                        const chunkZ = playerChunkZ + dz;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        if (distance <= renderChunkDistance &&
                            chunkX >= 0 && chunkZ >= 0 &&
                            chunkX < Math.ceil(this.worldSize / 16) &&
                            chunkZ < Math.ceil(this.worldSize / 16)) {

                            const chunkKey = `${chunkX},${chunkZ}`;
                            const meshData = this.chunkMeshes.get(chunkKey);

                            if (meshData && meshData.wireframe && meshData.wireframe.indexCount > 0) {
                                this.renderWireframeMesh(meshData.wireframe);
                            }
                        }
                    }
                }
            }

            renderMesh(mesh, isTransparent) {
                if (!mesh || mesh.indexCount === 0) return;

                try {
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.vertices, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.position);
                    this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.colors, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.color);
                    this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.normals, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.normal);
                    this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                    if (mesh.alphas && this.attributes.alpha !== -1) {
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.alpha);
                        this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.alphas, this.gl.STATIC_DRAW);
                        this.gl.enableVertexAttribArray(this.attributes.alpha);
                        this.gl.vertexAttribPointer(this.attributes.alpha, 1, this.gl.FLOAT, false, 0, 0);
                    }

                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices, this.gl.STATIC_DRAW);

                    this.gl.drawElements(this.gl.TRIANGLES, mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);

                    this.triangleCount += mesh.indexCount / 3;
                    this.vertexCount += mesh.vertexCount;
                    this.drawCalls++;

                } catch (error) {
                    console.error('æ¸²æŸ“ç¶²æ ¼æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }

            renderWireframeMesh(mesh) {
                if (!mesh || mesh.indexCount === 0) return;

                try {
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.wireframePosition);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, mesh.vertices, this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.wireframeAttributes.position);
                    this.gl.vertexAttribPointer(this.wireframeAttributes.position, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.wireframeIndex);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices, this.gl.STATIC_DRAW);

                    this.gl.drawElements(this.gl.LINES, mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);

                    this.drawCalls++;

                } catch (error) {
                    console.error('æ¸²æŸ“ç·šæ¡†æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }

            // æ¸²æŸ“å…¶ä»–ç©å®¶
            renderOtherPlayers() {
                if (!this.isMultiplayer) return;

                this.cleanupPlayerNameTags();

                this.otherPlayers.forEach((player, playerId) => {
                    try {
                        this.renderPlayer(player);
                        this.renderPlayerNameTag(player);
                    } catch (error) {
                        console.error(`æ¸²æŸ“ç©å®¶ ${playerId} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                    }
                });
            }

            renderPlayer(player) {
                this.gl.useProgram(this.shaderProgram);

                const parts = [
                    { pos: [player.x, player.y + 1.75, player.z], size: [0.5, 0.5, 0.5], color: [0.9, 0.7, 0.6] },
                    { pos: [player.x, player.y + 1.125, player.z], size: [0.5, 0.75, 0.25], color: [0.2, 0.2, 0.8] },
                    { pos: [player.x - 0.375, player.y + 1.125, player.z], size: [0.25, 0.75, 0.25], color: [0.9, 0.7, 0.6] },
                    { pos: [player.x + 0.375, player.y + 1.125, player.z], size: [0.25, 0.75, 0.25], color: [0.9, 0.7, 0.6] },
                    { pos: [player.x - 0.125, player.y + 0.375, player.z], size: [0.25, 0.75, 0.25], color: [0.1, 0.1, 0.6] },
                    { pos: [player.x + 0.125, player.y + 0.375, player.z], size: [0.25, 0.75, 0.25], color: [0.1, 0.1, 0.6] }
                ];

                const vertices = [];
                const colors = [];
                const normals = [];
                const alphas = [];
                const indices = [];
                let indexOffset = 0;

                parts.forEach(part => {
                    const cubeVertices = this.createCube(
                        part.pos[0] - part.size[0] / 2,
                        part.pos[1] - part.size[1] / 2,
                        part.pos[2] - part.size[2] / 2,
                        part.size[0], part.size[1], part.size[2]
                    );

                    vertices.push(...cubeVertices);

                    for (let i = 0; i < 24; i++) {
                        colors.push(...part.color);
                        normals.push(0, 1, 0);
                        alphas.push(1.0);
                    }

                    for (let i = 0; i < 6; i++) {
                        const faceStart = indexOffset + i * 4;
                        indices.push(
                            faceStart, faceStart + 1, faceStart + 2,
                            faceStart, faceStart + 2, faceStart + 3
                        );
                    }
                    indexOffset += 24;
                });

                try {
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.position);
                    this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.color);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.color);
                    this.gl.vertexAttribPointer(this.attributes.color, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.normal);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.normal);
                    this.gl.vertexAttribPointer(this.attributes.normal, 3, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.alpha);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(alphas), this.gl.DYNAMIC_DRAW);
                    this.gl.enableVertexAttribArray(this.attributes.alpha);
                    this.gl.vertexAttribPointer(this.attributes.alpha, 1, this.gl.FLOAT, false, 0, 0);

                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.DYNAMIC_DRAW);

                    this.gl.drawElements(this.gl.TRIANGLES, indices.length, this.gl.UNSIGNED_SHORT, 0);

                    this.drawCalls++;
                } catch (error) {
                    console.error('æ¸²æŸ“ç©å®¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }

            createCube(x, y, z, width, height, depth) {
                return [
                    // å‰é¢
                    x, y, z + depth,
                    x + width, y, z + depth,
                    x + width, y + height, z + depth,
                    x, y + height, z + depth,

                    // å¾Œé¢
                    x + width, y, z,
                    x, y, z,
                    x, y + height, z,
                    x + width, y + height, z,

                    // å·¦é¢
                    x, y, z,
                    x, y, z + depth,
                    x, y + height, z + depth,
                    x, y + height, z,

                    // å³é¢
                    x + width, y, z + depth,
                    x + width, y, z,
                    x + width, y + height, z,
                    x + width, y + height, z + depth,

                    // ä¸Šé¢
                    x, y + height, z + depth,
                    x + width, y + height, z + depth,
                    x + width, y + height, z,
                    x, y + height, z,

                    // ä¸‹é¢
                    x, y, z,
                    x + width, y, z,
                    x + width, y, z + depth,
                    x, y, z + depth
                ];
            }

            cleanupPlayerNameTags() {
                const nameTagContainer = document.getElementById('playerNameTags');
                if (!nameTagContainer) return;

                const existingTags = nameTagContainer.querySelectorAll('.player-nametag');
                existingTags.forEach(tag => {
                    const playerId = tag.id.replace('nametag-', '');
                    if (!this.otherPlayers.has(playerId)) {
                        tag.remove();
                    }
                });
            }

            renderPlayerNameTag(player) {
                const screenPos = this.worldToScreen(player.x, player.y + 2.2, player.z);

                if (screenPos && screenPos.z > 0 && screenPos.z < 1) {
                    let nameTag = document.getElementById(`nametag-${player.id}`);

                    if (!nameTag) {
                        nameTag = document.createElement('div');
                        nameTag.id = `nametag-${player.id}`;
                        nameTag.className = 'player-nametag';
                        nameTag.textContent = player.name;
                        document.getElementById('playerNameTags').appendChild(nameTag);
                    }

                    nameTag.style.left = screenPos.x + 'px';
                    nameTag.style.top = screenPos.y + 'px';
                    nameTag.style.display = 'block';

                    const distance = Math.sqrt(
                        Math.pow(player.x - this.player.x, 2) +
                        Math.pow(player.z - this.player.z, 2)
                    );
                    const opacity = Math.max(0.3, Math.min(1.0, 1.0 - distance / 50));
                    nameTag.style.opacity = opacity;

                } else {
                    const nameTag = document.getElementById(`nametag-${player.id}`);
                    if (nameTag) {
                        nameTag.style.display = 'none';
                    }
                }
            }

            worldToScreen(worldX, worldY, worldZ) {
                try {
                    const worldPos = [worldX, worldY, worldZ, 1];
                    const viewPos = this.multiplyMatrixVector(this.viewMatrix, worldPos);
                    const clipPos = this.multiplyMatrixVector(this.projectionMatrix, viewPos);

                    if (Math.abs(clipPos[3]) < 0.0001) return null;

                    const ndcX = clipPos[0] / clipPos[3];
                    const ndcY = clipPos[1] / clipPos[3];
                    const ndcZ = clipPos[2] / clipPos[3];

                    if (ndcZ < -1 || ndcZ > 1 || Math.abs(ndcX) > 1 || Math.abs(ndcY) > 1) {
                        return null;
                    }

                    const screenX = (ndcX + 1) * 0.5 * this.canvas.width;
                    const screenY = (1 - ndcY) * 0.5 * this.canvas.height;

                    return {
                        x: screenX,
                        y: screenY,
                        z: ndcZ
                    };
                } catch (error) {
                    console.error('åº§æ¨™è½‰æ›éŒ¯èª¤:', error);
                    return null;
                }
            }

            multiplyMatrixVector(matrix, vector) {
                const result = [0, 0, 0, 0];
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i] += matrix[i * 4 + j] * vector[j];
                    }
                }
                return result;
            }

            // ä¿®å¾©ï¼šå¯¦ç¾çœŸæ­£çš„Minecraft tickç³»çµ±çš„ç©å®¶æ›´æ–°
            updatePlayer() {
                if (!this.gameStarted || !this.worldGenerated || this.isPaused || this.chatSystem.isActive()) return;

                // é‡ç½®ç›¸æ©Ÿä½ç½®ï¼Œè®“å®ƒåœ¨æ¯æ¬¡æ›´æ–°æ™‚é‡æ–°è¨ˆç®—
                this.player.cameraX = null;
                this.player.cameraY = null;
                this.player.cameraZ = null;


                // ä¿®å¾©ï¼šä½¿ç”¨åŸºæ–¼tickçš„ç§»å‹•é€Ÿåº¦
                const baseSpeed = this.moveSpeed; // å·²ç¶“æ˜¯æ¯tickçš„é€Ÿåº¦
                const sprintMultiplier = this.keys['ControlLeft'] ? this.sprintMultiplier : 1;
                const sneakMultiplier = this.keys['ShiftLeft'] && !this.flying ? this.sneakMultiplier : 1;
                const speed = baseSpeed * sprintMultiplier * sneakMultiplier;

                let moveX = 0, moveZ = 0;

                if (this.keys['KeyW']) {
                    moveX += Math.cos(this.player.angle) * speed;
                    moveZ += Math.sin(this.player.angle) * speed;
                }
                if (this.keys['KeyS']) {
                    moveX -= Math.cos(this.player.angle) * speed;
                    moveZ -= Math.sin(this.player.angle) * speed;
                }
                if (this.keys['KeyA']) {
                    moveX += Math.cos(this.player.angle - Math.PI / 2) * speed;
                    moveZ += Math.sin(this.player.angle - Math.PI / 2) * speed;
                }
                if (this.keys['KeyD']) {
                    moveX += Math.cos(this.player.angle + Math.PI / 2) * speed;
                    moveZ += Math.sin(this.player.angle + Math.PI / 2) * speed;
                }

                const newX = this.player.x + moveX;
                const newZ = this.player.z + moveZ;

                if (!this.checkCollision(newX, this.player.y, this.player.z)) {
                    this.player.x = newX;
                }
                if (!this.checkCollision(this.player.x, this.player.y, newZ)) {
                    this.player.z = newZ;
                }

                if (this.flying) {
                    const flySpeed = speed * this.flySpeedMultiplier;
                    if (this.keys['Space']) this.player.y += flySpeed;
                    if (this.keys['ShiftLeft']) this.player.y -= flySpeed;
                    this.player.velocity.y = 0;
                    this.player.onGround = false;
                } else {
                    // ä¿®å¾©ï¼šä½¿ç”¨åŸºæ–¼tickçš„é‡åŠ›
                    this.player.velocity.y += this.gravity;

                    if (this.keys['Space'] && this.player.onGround) {
                        this.player.velocity.y = this.jumpPower;
                        this.player.onGround = false;
                    }

                    const newY = this.player.y + this.player.velocity.y;
                    if (!this.checkCollision(this.player.x, newY, this.player.z)) {
                        this.player.y = newY;
                        this.player.onGround = false;
                    } else {
                        if (this.player.velocity.y < 0) {
                            this.player.onGround = true;
                        }
                        this.player.velocity.y = 0;
                    }
                }

                // æ›´æ–°ç§»å‹•ç«¯æ§åˆ¶
                if (this.mobileControls) {
                    this.mobileControls.update();
                }

                if (this.isMultiplayer && this.multiplayerManager.isConnected) {
                    if (this.currentTick % 3 === 0) { // æ¯3å€‹tickç™¼é€ä¸€æ¬¡æ›´æ–°
                        this.multiplayerManager.sendPlayerUpdate({
                            x: this.player.x,
                            y: this.player.y,
                            z: this.player.z,
                            angle: this.player.angle,
                            pitch: this.player.pitch
                        });
                    }
                }
            }

            updateUI() {
                document.getElementById('position').textContent =
                    `${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)}`;

                // æ›´æ–°FPSé¡¯ç¤º
                document.getElementById('fpsDisplay').textContent = this.fps;

                if (this.frameCount % 300 === 0) {
                    console.log(`éŠæˆ²ç‹€æ…‹: ${this.gameStarted ? 'é€²è¡Œä¸­' : 'æœªé–‹å§‹'}, å¤šäººæ¨¡å¼: ${this.isMultiplayer}, TPS: ${this.TICKS_PER_SECOND}`);
                }
            }

            getBiome(x, z) {
                const nx = x / this.worldSize;
                const nz = z / this.worldSize;

                const temperature = this.improvedNoise(nx * 2.5, nz * 2.5);
                const humidity = this.improvedNoise(nx * 3.1 + 100, nz * 3.1 + 100);

                if (temperature > 0.3 && humidity < -0.2) {
                    return 'æ²™æ¼ ';
                } else if (temperature < -0.3) {
                    return 'é›ªåœ°';
                } else if (humidity > 0.4) {
                    return 'æ£®æ—';
                } else if (temperature > 0.1 && humidity > 0.1) {
                    return 'å¢æ—';
                } else {
                    return 'å¹³åŸ';
                }
            }

            // ä¿®å¾©ï¼šå¯¦ç¾çœŸæ­£çš„Minecraft tickç³»çµ±
            update(currentTime) {
                // è¨ˆç®—FPS
                if (this.lastFrameTime) {
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.frameCount++;

                    if (this.frameCount % 60 === 0) {
                        this.fps = Math.round(1000 / deltaTime);
                    }
                }
                this.lastFrameTime = currentTime;

                // ä¿®å¾©ï¼šå¯¦ç¾20 TPS tickç³»çµ±
                this.tickAccumulator += currentTime - (this.lastTickTime || currentTime);
                this.lastTickTime = currentTime;

                // è™•ç†tickæ›´æ–°
                while (this.tickAccumulator >= this.TICK_INTERVAL) {
                    this.tick();
                    this.tickAccumulator -= this.TICK_INTERVAL;
                    this.currentTick++;
                }

                // æ›´æ–°UIï¼ˆæ¯å¹€æ›´æ–°ï¼‰
                this.updateUI();

                // æ›´æ–°æ¸²æŸ“è·é›¢
                this.renderDistance = this.gameSettings.get('renderDistance');
            }

            // ä¿®å¾©ï¼šæ–°å¢tickæ–¹æ³• - çœŸæ­£çš„Minecraft tickç³»çµ±
            tick() {
                if (!this.gameStarted || this.isPaused) return;

                // åœ¨æ¯å€‹tickä¸­æ›´æ–°ç©å®¶
                this.updatePlayer();

                // å…¶ä»–éœ€è¦æŒ‰tickæ›´æ–°çš„é‚è¼¯å¯ä»¥åœ¨é€™è£¡æ·»åŠ 
                // ä¾‹å¦‚ï¼šæ–¹å¡Šæ›´æ–°ã€å¯¦é«”æ›´æ–°ã€ç´…çŸ³æ›´æ–°ç­‰
            }

            gameLoop() {
                const currentTime = performance.now();

                this.update(currentTime);
                this.render();

                // ä½¿ç”¨è¨­å®šä¸­çš„æœ€å¤§FPSé™åˆ¶
                const maxFps = this.gameSettings.get('maxFps');
                const minFrameTime = 1000 / maxFps;
                const frameTime = currentTime - (this.lastRenderTime || 0);

                if (frameTime >= minFrameTime) {
                    this.lastRenderTime = currentTime;
                    requestAnimationFrame(() => this.gameLoop());
                } else {
                    setTimeout(() => this.gameLoop(), minFrameTime - frameTime);
                }
            }
        } // WebGLMinecraft é¡åˆ¥çµæŸ

        // å•Ÿå‹•éŠæˆ²
        window.addEventListener('load', () => {
            // æª¢æŸ¥WebGLæ”¯æ´
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                document.body.innerHTML = `
                    <div class="error-message">
                        <h3>âŒ WebGL ä¸æ”¯æ´</h3>
                        <p>æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´WebGLï¼Œç„¡æ³•é‹è¡Œæ­¤éŠæˆ²ã€‚</p>
                        <p>è«‹å˜—è©¦ä½¿ç”¨ç¾ä»£ç€è¦½å™¨å¦‚Chromeã€Firefoxæˆ–Edgeã€‚</p>
                        <button onclick="location.reload()">é‡æ–°æª¢æ¸¬</button>
                    </div>
                `;
                return;
            }

            try {
                new WebGLMinecraft();
                console.log('ğŸ® WebGL Minecraft å®Œç¾ç‰ˆå·²å•Ÿå‹•ï¼');
                console.log('ğŸ“‹ ä¿®å¾©å®Œæˆçš„åŠŸèƒ½åˆ—è¡¨:');
                console.log('  âœ… 1. è¨­å®šé¸å–® - å®Œæ•´çš„æ¸²æŸ“è·é›¢æ»‘æ¡¿ç³»çµ±');
                console.log('  âœ… 2. ESCæš«åœåŠŸèƒ½ - ä¿®å¾©æš«åœé¸å–®é¡¯ç¤º');
                console.log('  âœ… 3. Minecraft tickç³»çµ± - é‡å¯«ç‚ºçœŸæ­£çš„20 TPS');
                console.log('  âœ… 4. ä¸»é¸å–®æŒ‰éˆ•ç½®ä¸­ - ä¿®å¾©CSSä½ˆå±€');
                console.log('  âœ… 5. ç§»å‹•ç«¯æ“ä½œ - ä¿®å¾©æ–æ¡¿æ–¹å‘å’Œæ·»åŠ æ½›è¡ŒæŒ‰éˆ•');
                console.log('  âœ… è¦–é‡è·é›¢è¨­å®š (8-64æ ¼)');
                console.log('  âœ… æ»‘é¼ æ»¾è¼ªé¸æ“‡æ–¹å¡Š');
                console.log('  âœ… å®Œå…¨é‡å¯«çš„Minecraft Javaç‰ˆèŠå¤©ç³»çµ±');
                console.log('  âœ… çœŸå¯¦Minecraftç§»å‹•é€Ÿåº¦å’Œè·³èºé«˜åº¦ï¼ˆåŸºæ–¼tickï¼‰');
                console.log('  âœ… æ©˜è‰²ä¸»é¡Œé«˜ç´šUIè¨­è¨ˆ');
                console.log('  âœ… çœŸæ­£çš„é€æ˜åº¦æ¸²æŸ“ç³»çµ±');
                console.log('  âœ… åŠ ç²—ç»ç’ƒç·šæ¡†æ¸²æŸ“');
                console.log('  âœ… MinecraftåŸç‰ˆæ–¹å¡Šé¡è‰²');
                console.log('  âœ… éŸ¿æ‡‰å¼UIç³»çµ±');
                console.log('  âœ… å„ªåŒ–çš„ç‰©å“æ¬„æ»¾å‹•');
                console.log('  âœ… å®Œæ•´çš„/helpæŒ‡ä»¤ç³»çµ±');
                console.log('  âœ… ç§»å‹•ç«¯æ“ä½œä»‹é¢ï¼ˆä¿®å¾©æ–æ¡¿æ–¹å‘å’Œæ½›è¡ŒæŒ‰éˆ•ï¼‰');
                console.log('  âœ… æ€§èƒ½å„ªåŒ–å’Œæ•ˆæœå¢å¼·');
                console.log('  âœ… 20 TPS tickç³»çµ±å¯¦ç¾');
            } catch (error) {
                console.error('éŠæˆ²å•Ÿå‹•å¤±æ•—:', error);
                document.body.innerHTML = `
                    <div class="error-message">
                        <h3>âŒ å•Ÿå‹•å¤±æ•—</h3>
                        <p>éŠæˆ²å•Ÿå‹•æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}</p>
                        <button onclick="location.reload()">é‡æ–°å•Ÿå‹•</button>
                    </div>
                `;
            }
        });

        // å…¨åŸŸå‡½æ•¸
        window.toggleFullscreen = function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        };

        // æ€§èƒ½ç›£æ§
        window.addEventListener('beforeunload', () => {
            console.log('éŠæˆ²æœƒè©±çµæŸ');
            if (window.game && window.game.multiplayerManager.isConnected) {
                window.game.multiplayerManager.disconnect();
            }
        });

        // è™•ç†é é¢å¯è¦‹æ€§è®ŠåŒ–
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('éŠæˆ²æš«åœ - é é¢éš±è—');
            } else {
                console.log('éŠæˆ²æ¢å¾© - é é¢é¡¯ç¤º');
            }
        });

        // éŒ¯èª¤è™•ç†
        window.addEventListener('error', (event) => {
            console.error('å…¨åŸŸéŒ¯èª¤:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('æœªè™•ç†çš„Promiseæ‹’çµ•:', event.reason);
        });

    </script>
</body>

</html>
